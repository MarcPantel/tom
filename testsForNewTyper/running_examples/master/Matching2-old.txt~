
Code after type inference = 
Tom(concCode(TargetLanguageToCode(TL("\npackage master.matching2.term.types.term;\n\n\n\npublic final class ConsAnd extends master.matching2.term.types.term.And implements tom.library.sl.Visitable  {\n  \n  private static String symbolName = \"ConsAnd\";\n\n\n  private ConsAnd() {}\n  private int hashCode;\n  private static ConsAnd proto = new ConsAnd();\n  \n",TextPosition(1,1),TextPosition(15,1))),TomInclude(concCode(TomInclude(concCode(DeclarationToCode(TypeTermDecl(Name("char"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),Name("t1"),Type("char",TLType(" char "))),BQVariable(concOption(OriginTracking(Name("t2"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),Name("t2"),Type("char",TLType(" char "))),Code(" {0}=={1} "),OriginTracking(Name("equals"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),34,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),Name("t"),Type("char",TLType(" char "))),Code(" true "),OriginTracking(Name("is_sort"),34,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom"))),OriginTracking(Name("char"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom"))),TargetLanguageToCode(TL("\n",TextPosition(36,1),TextPosition(37,1))))),DeclarationToCode(TypeTermDecl(Name("String"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),36,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),Name("t1"),Type("String",TLType(" String "))),BQVariable(concOption(OriginTracking(Name("t2"),36,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),Name("t2"),Type("String",TLType(" String "))),Code(" {0}.equals({1}) "),OriginTracking(Name("equals"),36,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),Name("t"),Type("String",TLType(" String "))),Code(" {0} instanceof String "),OriginTracking(Name("is_sort"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom"))),OriginTracking(Name("String"),33,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom"))),DeclarationToCode(ListSymbolDecl(Name("concString"))),TargetLanguageToCode(TL("\n",TextPosition(46,1),TextPosition(47,1))))),DeclarationToCode(TypeTermDecl(Name("TermList"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("t1"),Type("TermList",TLType(" master.matching2.term.types.TermList "))),BQVariable(concOption(OriginTracking(Name("t2"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("t2"),Type("TermList",TLType(" master.matching2.term.types.TermList "))),Code(" ({0}=={1}) "),OriginTracking(Name("equals"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),19,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("t"),Type("TermList",TLType(" master.matching2.term.types.TermList "))),Code(" ({0} instanceof master.matching2.term.types.TermList) "),OriginTracking(Name("is_sort"),19,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t"))),OriginTracking(Name("TermList"),17,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t"))),DeclarationToCode(TypeTermDecl(Name("Term"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),29,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("t1"),Type("Term",TLType(" master.matching2.term.types.Term "))),BQVariable(concOption(OriginTracking(Name("t2"),29,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("t2"),Type("Term",TLType(" master.matching2.term.types.Term "))),Code(" ({0}=={1}) "),OriginTracking(Name("equals"),29,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),27,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("t"),Type("Term",TLType(" master.matching2.term.types.Term "))),Code(" ({0} instanceof master.matching2.term.types.Term) "),OriginTracking(Name("is_sort"),27,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t"))),OriginTracking(Name("Term"),25,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t"))),DeclarationToCode(SymbolDecl(Name("Emptyconc"))),DeclarationToCode(SymbolDecl(Name("Consconc"))),DeclarationToCode(SymbolDecl(Name("Variable"))),DeclarationToCode(SymbolDecl(Name("Appl"))),DeclarationToCode(SymbolDecl(Name("True"))),DeclarationToCode(SymbolDecl(Name("False"))),DeclarationToCode(SymbolDecl(Name("Match"))),DeclarationToCode(SymbolDecl(Name("EmptyAnd"))),DeclarationToCode(SymbolDecl(Name("ConsAnd"))),DeclarationToCode(SymbolDecl(Name("decomposeList"))),DeclarationToCode(ListSymbolDecl(Name("conc"))),DeclarationToCode(ListSymbolDecl(Name("And"))),TargetLanguageToCode(TL("\n  private master.matching2.term.types.Term _HeadAnd;\n  private master.matching2.term.types.Term _TailAnd;\n\n  /**\n   * Constructor that builds a term rooted by ConsAnd\n   *\n   * @return a term rooted by ConsAnd\n   */\n\n    public static master.matching2.term.types.Term make(master.matching2.term.types.Term head, master.matching2.term.types.Term tail) {\n  if (true) {    ",TextPosition(110,1),TextPosition(121,18))),InstructionToCode(Match(concConstraintInstruction(ConstraintInstruction(MatchConstraint(RecordAppl(concOption(OriginTracking(Name("And"),122,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),concTomName(Name("And")),concSlot(PairSlotAppl(EmptyName(),VariableStar(concOption(OriginTracking(Name("_"),122,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("_f_r_e_s_h_v_a_r_1"),TypeWithSymbol("Term",TLType(" master.matching2.term.types.Term "),Name("And")),concConstraint())),PairSlotAppl(EmptyName(),RecordAppl(concOption(OriginTracking(Name("False"),122,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),concTomName(Name("False")),concSlot(),concConstraint())),PairSlotAppl(EmptyName(),VariableStar(concOption(OriginTracking(Name("_"),122,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("_f_r_e_s_h_v_a_r_2"),TypeWithSymbol("Term",TLType(" master.matching2.term.types.Term "),Name("And")),concConstraint()))),concConstraint()),FunctionCall(Name("realMake"),Type("Term",TLType(" master.matching2.term.types.Term ")),concBQTerm(BQVariable(concOption(OriginTracking(Name("head"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("head"),Type("Term",TLType(" master.matching2.term.types.Term "))),BQVariable(concOption(OriginTracking(Name("tail"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("tail"),Type("Term",TLType(" master.matching2.term.types.Term ")))))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(122,25),TextPosition(122,34)))),BQTermToInstruction(Composite(CompositeBQTerm(BuildTerm(Name("False"),concBQTerm(),"default")))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(122,42),TextPosition(122,44))))))),concOption(OriginalText(Name("")))),ConstraintInstruction(MatchConstraint(RecordAppl(concOption(OriginTracking(Name("And"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),concTomName(Name("And")),concSlot(PairSlotAppl(EmptyName(),RecordAppl(concOption(OriginTracking(Name("True"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),concTomName(Name("True")),concSlot(),concConstraint())),PairSlotAppl(EmptyName(),VariableStar(concOption(OriginTracking(Name("Y"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("Y"),TypeWithSymbol("Term",TLType(" master.matching2.term.types.Term "),Name("And")),concConstraint()))),concConstraint()),FunctionCall(Name("realMake"),Type("Term",TLType(" master.matching2.term.types.Term ")),concBQTerm(BQVariable(concOption(OriginTracking(Name("head"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("head"),Type("Term",TLType(" master.matching2.term.types.Term "))),BQVariable(concOption(OriginTracking(Name("tail"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("tail"),Type("Term",TLType(" master.matching2.term.types.Term ")))))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(123,20),TextPosition(123,29)))),BQTermToInstruction(BQVariableStar(concOption(OriginTracking(Name("Y"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("Y"),TypeWithSymbol("Term",TLType(" master.matching2.term.types.Term "),Name("And")))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(123,32),TextPosition(123,34))))))),concOption(OriginalText(Name("")))),ConstraintInstruction(MatchConstraint(RecordAppl(concOption(OriginTracking(Name("And"),124,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),concTomName(Name("And")),concSlot(PairSlotAppl(EmptyName(),Variable(concOption(OriginTracking(Name("c"),124,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("c"),Type("Term",TLType(" master.matching2.term.types.Term ")),concConstraint())),PairSlotAppl(EmptyName(),VariableStar(concOption(OriginTracking(Name("Y"),124,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("Y"),TypeWithSymbol("Term",TLType(" master.matching2.term.types.Term "),Name("And")),concConstraint())),PairSlotAppl(EmptyName(),Variable(concOption(OriginTracking(Name("c"),124,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("c"),Type("Term",TLType(" master.matching2.term.types.Term ")),concConstraint())),PairSlotAppl(EmptyName(),VariableStar(concOption(OriginTracking(Name("Z"),124,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("Z"),TypeWithSymbol("Term",TLType(" master.matching2.term.types.Term "),Name("And")),concConstraint()))),concConstraint()),FunctionCall(Name("realMake"),Type("Term",TLType(" master.matching2.term.types.Term ")),concBQTerm(BQVariable(concOption(OriginTracking(Name("head"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("head"),Type("Term",TLType(" master.matching2.term.types.Term "))),BQVariable(concOption(OriginTracking(Name("tail"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("tail"),Type("Term",TLType(" master.matching2.term.types.Term ")))))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(124,22),TextPosition(124,31)))),BQTermToInstruction(Composite(CompositeBQTerm(BuildConsList(Name("And"),Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("c"),124,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t"),ModuleName("default")),Name("c"),Type("Term",TLType(" master.matching2.term.types.Term "))))),BuildAppendList(Name("And"),Composite(CompositeBQTerm(BQVariableStar(concOption(OriginTracking(Name("Y"),124,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("Y"),TypeWithSymbol("Term",TLType(" master.matching2.term.types.Term "),Name("And"))))),BuildAppendList(Name("And"),Composite(CompositeBQTerm(BQVariableStar(concOption(OriginTracking(Name("Z"),124,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("Z"),TypeWithSymbol("Term",TLType(" master.matching2.term.types.Term "),Name("And"))))),BuildEmptyList(Name("And")))))))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(124,46),TextPosition(124,48))))))),concOption(OriginalText(Name("")))),ConstraintInstruction(MatchConstraint(RecordAppl(concOption(OriginTracking(Name("And"),125,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),concTomName(Name("And")),concSlot(PairSlotAppl(EmptyName(),Variable(concOption(OriginTracking(Name("x"),125,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("x"),Type("Term",TLType(" master.matching2.term.types.Term ")),concConstraint()))),concConstraint()),FunctionCall(Name("realMake"),Type("Term",TLType(" master.matching2.term.types.Term ")),concBQTerm(BQVariable(concOption(OriginTracking(Name("head"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("head"),Type("Term",TLType(" master.matching2.term.types.Term "))),BQVariable(concOption(OriginTracking(Name("tail"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t")),Name("tail"),Type("Term",TLType(" master.matching2.term.types.Term ")))))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(125,11),TextPosition(125,20)))),BQTermToInstruction(BQVariable(concOption(OriginTracking(Name("x"),125,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t"),ModuleName("default")),Name("x"),Type("Term",TLType(" master.matching2.term.types.Term ")))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(125,23),TextPosition(125,24))))))),concOption(OriginalText(Name(""))))),concOption(OriginTracking(Name("Match"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp5270561916925364442.t"),ModuleName("default")))),TargetLanguageToCode(TL("\n}\n      return realMake( head,  tail);\n    }\n  \n  private static ConsAnd realMake(master.matching2.term.types.Term _HeadAnd, master.matching2.term.types.Term _TailAnd) {\n\n    // use the proto as a model\n    proto.initHashCode( _HeadAnd,  _TailAnd);\n    return (ConsAnd) factory.build(proto);\n\n  }\n\n  /**\n   * Initializes attributes and hashcode of the class\n   *\n   * @param  _HeadAnd\n   * @param _TailAnd\n   * @param hashCode hashCode of ConsAnd\n   */\n  private void init(master.matching2.term.types.Term _HeadAnd, master.matching2.term.types.Term _TailAnd, int hashCode) {\n    this._HeadAnd = _HeadAnd;\n    this._TailAnd = _TailAnd;\n\n    this.hashCode = hashCode;\n  }\n\n  /**\n   * Initializes attributes and hashcode of the class\n   *\n   * @param  _HeadAnd\n   * @param _TailAnd\n   */\n  private void initHashCode(master.matching2.term.types.Term _HeadAnd, master.matching2.term.types.Term _TailAnd) {\n    this._HeadAnd = _HeadAnd;\n    this._TailAnd = _TailAnd;\n\n    this.hashCode = hashFunction();\n  }\n\n  /* name and arity */\n\n  /**\n   * Returns the name of the symbol\n   *\n   * @return the name of the symbol\n   */\n  @Override\n  public String symbolName() {\n    return \"ConsAnd\";\n  }\n\n  /**\n   * Returns the arity of the symbol\n   *\n   * @return the arity of the symbol\n   */\n  private int getArity() {\n    return 2;\n  }\n\n  /**\n   * Copy the object and returns the copy\n   *\n   * @return a clone of the SharedObject\n   */\n  public shared.SharedObject duplicate() {\n    ConsAnd clone = new ConsAnd();\n    clone.init( _HeadAnd,  _TailAnd, hashCode);\n    return clone;\n  }\n  \n\n  /**\n   * Compares two terms. This functions implements a total lexicographic path ordering.\n   *\n   * @param o object to which this term is compared\n   * @return a negative integer, zero, or a positive integer as this\n   *         term is less than, equal to, or greater than the argument\n   * @throws ClassCastException in case of invalid arguments\n   * @throws RuntimeException if unable to compare childs\n   */\n  @Override\n  public int compareToLPO(Object o) {\n    /*\n     * We do not want to compare with any object, only members of the module\n     * In case of invalid argument, throw a ClassCastException, as the java api\n     * asks for it\n     */\n    master.matching2.term.TermAbstractType ao = (master.matching2.term.TermAbstractType) o;\n    /* return 0 for equality */\n    if (ao == this) { return 0; }\n    /* compare the symbols */\n    int symbCmp = this.symbolName().compareTo(ao.symbolName());\n    if (symbCmp != 0) { return symbCmp; }\n    /* compare the childs */\n    ConsAnd tco = (ConsAnd) ao;\n    int _HeadAndCmp = (this._HeadAnd).compareToLPO(tco._HeadAnd);\n    if(_HeadAndCmp != 0)\n      return _HeadAndCmp;\n\n    int _TailAndCmp = (this._TailAnd).compareToLPO(tco._TailAnd);\n    if(_TailAndCmp != 0)\n      return _TailAndCmp;\n\n    throw new RuntimeException(\"Unable to compare\");\n  }\n\n /**\n   * Compares two terms. This functions implements a total order.\n   *\n   * @param o object to which this term is compared\n   * @return a negative integer, zero, or a positive integer as this\n   *         term is less than, equal to, or greater than the argument\n   * @throws ClassCastException in case of invalid arguments\n   * @throws RuntimeException if unable to compare childs\n   */\n  @Override\n  public int compareTo(Object o) {\n    /*\n     * We do not want to compare with any object, only members of the module\n     * In case of invalid argument, throw a ClassCastException, as the java api\n     * asks for it\n     */\n    master.matching2.term.TermAbstractType ao = (master.matching2.term.TermAbstractType) o;\n    /* return 0 for equality */\n    if (ao == this) { return 0; }\n    /* use the hash values to discriminate */\n\n    if(hashCode != ao.hashCode()) { return (hashCode < ao.hashCode())?-1:1; }\n\n    /* If not, compare the symbols : back to the normal order */\n    int symbCmp = this.symbolName().compareTo(ao.symbolName());\n    if (symbCmp != 0) { return symbCmp; }\n    /* last resort: compare the childs */\n    ConsAnd tco = (ConsAnd) ao;\n    int _HeadAndCmp = (this._HeadAnd).compareTo(tco._HeadAnd);\n    if(_HeadAndCmp != 0)\n      return _HeadAndCmp;\n\n    int _TailAndCmp = (this._TailAnd).compareTo(tco._TailAnd);\n    if(_TailAndCmp != 0)\n      return _TailAndCmp;\n\n    throw new RuntimeException(\"Unable to compare\");\n  }\n\n //shared.SharedObject\n  /**\n   * Returns hashCode\n   *\n   * @return hashCode\n   */\n  @Override\n  public final int hashCode() {\n    return hashCode;\n  }\n\n  /**\n   * Checks if a SharedObject is equivalent to the current object\n   *\n   * @param obj SharedObject to test\n   * @return true if obj is a ConsAnd and its members are equal, else false\n   */\n  public final boolean equivalent(shared.SharedObject obj) {\n    if(obj instanceof ConsAnd) {\n\n      ConsAnd peer = (ConsAnd) obj;\n      return _HeadAnd==peer._HeadAnd && _TailAnd==peer._TailAnd && true;\n    }\n    return false;\n  }\n\n\n   //Term interface\n  /**\n   * Returns true if the term is rooted by the symbol ConsAnd\n   *\n   * @return true, because this is rooted by ConsAnd\n   */\n  @Override\n  public boolean isConsAnd() {\n    return true;\n  }\n  \n  /**\n   * Returns the attribute master.matching2.term.types.Term\n   *\n   * @return the attribute master.matching2.term.types.Term\n   */\n  @Override\n  public master.matching2.term.types.Term getHeadAnd() {\n    return _HeadAnd;\n  }\n\n  /**\n   * Sets and returns the attribute master.matching2.term.types.Term\n   *\n   * @param set_arg the argument to set\n   * @return the attribute master.matching2.term.types.Term which just has been set\n   */\n  @Override\n  public master.matching2.term.types.Term setHeadAnd(master.matching2.term.types.Term set_arg) {\n    return make(set_arg, _TailAnd);\n  }\n  \n  /**\n   * Returns the attribute master.matching2.term.types.Term\n   *\n   * @return the attribute master.matching2.term.types.Term\n   */\n  @Override\n  public master.matching2.term.types.Term getTailAnd() {\n    return _TailAnd;\n  }\n\n  /**\n   * Sets and returns the attribute master.matching2.term.types.Term\n   *\n   * @param set_arg the argument to set\n   * @return the attribute master.matching2.term.types.Term which just has been set\n   */\n  @Override\n  public master.matching2.term.types.Term setTailAnd(master.matching2.term.types.Term set_arg) {\n    return make(_HeadAnd, set_arg);\n  }\n  \n  /* AbstractType */\n  /**\n   * Returns an ATerm representation of this term.\n   *\n   * @return an ATerm representation of this term.\n   */\n  @Override\n  public aterm.ATerm toATerm() {\n    aterm.ATerm res = super.toATerm();\n    if(res != null) {\n      // the super class has produced an ATerm (may be a variadic operator)\n      return res;\n    }\n    return atermFactory.makeAppl(\n      atermFactory.makeAFun(symbolName(),getArity(),false),\n      new aterm.ATerm[] {getHeadAnd().toATerm(), getTailAnd().toATerm()});\n  }\n\n  /**\n   * Apply a conversion on the ATerm contained in the String and returns a master.matching2.term.types.Term from it\n   *\n   * @param trm ATerm to convert into a Gom term\n   * @param atConv ATerm Converter used to convert the ATerm\n   * @return the Gom term\n   */\n  public static master.matching2.term.types.Term fromTerm(aterm.ATerm trm, tom.library.utils.ATermConverter atConv) {\n    trm = atConv.convert(trm);\n    if(trm instanceof aterm.ATermAppl) {\n      aterm.ATermAppl appl = (aterm.ATermAppl) trm;\n      if(symbolName.equals(appl.getName()) && !appl.getAFun().isQuoted()) {\n        return make(\nmaster.matching2.term.types.Term.fromTerm(appl.getArgument(0),atConv), master.matching2.term.types.Term.fromTerm(appl.getArgument(1),atConv)\n        );\n      }\n    }\n    return null;\n  }\n\n  /* Visitable */\n  /**\n   * Returns the number of childs of the term\n   *\n   * @return the number of childs of the term\n   */\n  public int getChildCount() {\n    return 2;\n  }\n\n  /**\n   * Returns the child at the specified index\n   *\n   * @param index index of the child to return; must be\n             nonnegative and less than the childCount\n   * @return the child at the specified index\n   * @throws IndexOutOfBoundsException if the index out of range\n   */\n  public tom.library.sl.Visitable getChildAt(int index) {\n    switch(index) {\n      case 0: return _HeadAnd;\n      case 1: return _TailAnd;\n\n      default: throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Set the child at the specified index\n   *\n   * @param index index of the child to set; must be\n             nonnegative and less than the childCount\n   * @param v child to set at the specified index\n   * @return the child which was just set\n   * @throws IndexOutOfBoundsException if the index out of range\n   */\n  public tom.library.sl.Visitable setChildAt(int index, tom.library.sl.Visitable v) {\n    switch(index) {\n      case 0: return make((master.matching2.term.types.Term) v, _TailAnd);\n      case 1: return make(_HeadAnd, (master.matching2.term.types.Term) v);\n\n      default: throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Set children to the term\n   *\n   * @param childs array of children to set\n   * @return an array of children which just were set\n   * @throws IndexOutOfBoundsException if length of \"childs\" is different than 2\n   */\n  @SuppressWarnings(\"unchecked\")\n  public tom.library.sl.Visitable setChildren(tom.library.sl.Visitable[] childs) {\n    if (childs.length == 2  && childs[0] instanceof master.matching2.term.types.Term && childs[1] instanceof master.matching2.term.types.Term) {\n      return make((master.matching2.term.types.Term) childs[0], (master.matching2.term.types.Term) childs[1]);\n    } else {\n      throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Returns the whole children of the term\n   *\n   * @return the children of the term\n   */\n  public tom.library.sl.Visitable[] getChildren() {\n    return new tom.library.sl.Visitable[] {  _HeadAnd,  _TailAnd };\n  }\n\n    /**\n     * Compute a hashcode for this term.\n     * (for internal use)\n     *\n     * @return a hash value\n     */\n  protected int hashFunction() {\n    int a, b, c;\n    /* Set up the internal state */\n    a = 0x9e3779b9; /* the golden ratio; an arbitrary value */\n    b = (1528669362<<8);\n    c = getArity();\n    /* -------------------------------------- handle most of the key */\n    /* ------------------------------------ handle the last 11 bytes */\n    a += (_HeadAnd.hashCode() << 8);\n    a += (_TailAnd.hashCode());\n\n    a -= b; a -= c; a ^= (c >> 13);\n    b -= c; b -= a; b ^= (a << 8);\n    c -= a; c -= b; c ^= (b >> 13);\n    a -= b; a -= c; a ^= (c >> 12);\n    b -= c; b -= a; b ^= (a << 16);\n    c -= a; c -= b; c ^= (b >> 5);\n    a -= b; a -= c; a ^= (c >> 3);\n    b -= c; b -= a; b ^= (a << 10);\n    c -= a; c -= b; c ^= (b >> 15);\n    /* ------------------------------------------- report the result */\n    return c;\n  }\n\n}\n",TextPosition(126,5),TextPosition(492,1)))))

Code after type inference = 
Tom(concCode(TargetLanguageToCode(TL("\npackage master.matching2.term.types.term;\n\n\n\npublic final class decomposeList extends master.matching2.term.types.Term implements tom.library.sl.Visitable  {\n  \n  private static String symbolName = \"decomposeList\";\n\n\n  private decomposeList() {}\n  private int hashCode;\n  private static decomposeList proto = new decomposeList();\n  \n",TextPosition(1,1),TextPosition(15,1))),TomInclude(concCode(TomInclude(concCode(DeclarationToCode(TypeTermDecl(Name("char"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),Name("t1"),Type("char",TLType(" char "))),BQVariable(concOption(OriginTracking(Name("t2"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),Name("t2"),Type("char",TLType(" char "))),Code(" {0}=={1} "),OriginTracking(Name("equals"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),34,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),Name("t"),Type("char",TLType(" char "))),Code(" true "),OriginTracking(Name("is_sort"),34,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom"))),OriginTracking(Name("char"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom"))),TargetLanguageToCode(TL("\n",TextPosition(36,1),TextPosition(37,1))))),DeclarationToCode(TypeTermDecl(Name("String"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),36,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),Name("t1"),Type("String",TLType(" String "))),BQVariable(concOption(OriginTracking(Name("t2"),36,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),Name("t2"),Type("String",TLType(" String "))),Code(" {0}.equals({1}) "),OriginTracking(Name("equals"),36,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),Name("t"),Type("String",TLType(" String "))),Code(" {0} instanceof String "),OriginTracking(Name("is_sort"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom"))),OriginTracking(Name("String"),33,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom"))),DeclarationToCode(ListSymbolDecl(Name("concString"))),TargetLanguageToCode(TL("\n",TextPosition(46,1),TextPosition(47,1))))),DeclarationToCode(TypeTermDecl(Name("TermList"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),Name("t1"),Type("TermList",TLType(" master.matching2.term.types.TermList "))),BQVariable(concOption(OriginTracking(Name("t2"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),Name("t2"),Type("TermList",TLType(" master.matching2.term.types.TermList "))),Code(" ({0}=={1}) "),OriginTracking(Name("equals"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),19,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),Name("t"),Type("TermList",TLType(" master.matching2.term.types.TermList "))),Code(" ({0} instanceof master.matching2.term.types.TermList) "),OriginTracking(Name("is_sort"),19,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t"))),OriginTracking(Name("TermList"),17,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t"))),DeclarationToCode(TypeTermDecl(Name("Term"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),29,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),Name("t1"),Type("Term",TLType(" master.matching2.term.types.Term "))),BQVariable(concOption(OriginTracking(Name("t2"),29,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),Name("t2"),Type("Term",TLType(" master.matching2.term.types.Term "))),Code(" ({0}=={1}) "),OriginTracking(Name("equals"),29,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),27,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),Name("t"),Type("Term",TLType(" master.matching2.term.types.Term "))),Code(" ({0} instanceof master.matching2.term.types.Term) "),OriginTracking(Name("is_sort"),27,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t"))),OriginTracking(Name("Term"),25,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t"))),DeclarationToCode(SymbolDecl(Name("Emptyconc"))),DeclarationToCode(SymbolDecl(Name("Consconc"))),DeclarationToCode(SymbolDecl(Name("Variable"))),DeclarationToCode(SymbolDecl(Name("Appl"))),DeclarationToCode(SymbolDecl(Name("True"))),DeclarationToCode(SymbolDecl(Name("False"))),DeclarationToCode(SymbolDecl(Name("Match"))),DeclarationToCode(SymbolDecl(Name("EmptyAnd"))),DeclarationToCode(SymbolDecl(Name("ConsAnd"))),DeclarationToCode(SymbolDecl(Name("decomposeList"))),DeclarationToCode(ListSymbolDecl(Name("conc"))),DeclarationToCode(ListSymbolDecl(Name("And"))),TargetLanguageToCode(TL("\n  private master.matching2.term.types.TermList _l1;\n  private master.matching2.term.types.TermList _l2;\n\n  /**\n   * Constructor that builds a term rooted by decomposeList\n   *\n   * @return a term rooted by decomposeList\n   */\n\n    public static master.matching2.term.types.Term make(master.matching2.term.types.TermList arg_1, master.matching2.term.types.TermList arg_2) {\n  if (true) {    ",TextPosition(110,1),TextPosition(121,18))),InstructionToCode(Match(concConstraintInstruction(ConstraintInstruction(AndConstraint(MatchConstraint(RecordAppl(concOption(OriginTracking(Name("conc"),122,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),concTomName(Name("conc")),concSlot(),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_1"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),Name("arg_1"),Type("TermList",TLType(" master.matching2.term.types.TermList ")))),MatchConstraint(RecordAppl(concOption(OriginTracking(Name("conc"),122,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),concTomName(Name("conc")),concSlot(),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_2"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),Name("arg_2"),Type("TermList",TLType(" master.matching2.term.types.TermList "))))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(122,19),TextPosition(122,28)))),BQTermToInstruction(Composite(CompositeBQTerm(BuildTerm(Name("True"),concBQTerm(),"default")))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(122,35),TextPosition(122,37))))))),concOption(OriginalText(Name("")))),ConstraintInstruction(AndConstraint(MatchConstraint(RecordAppl(concOption(OriginTracking(Name("conc"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),concTomName(Name("conc")),concSlot(PairSlotAppl(EmptyName(),Variable(concOption(OriginTracking(Name("h1"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),Name("h1"),Type("Term",TLType(" master.matching2.term.types.Term ")),concConstraint())),PairSlotAppl(EmptyName(),VariableStar(concOption(OriginTracking(Name("t1"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),Name("t1"),TypeWithSymbol("TermList",TLType(" master.matching2.term.types.TermList "),Name("conc")),concConstraint()))),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_1"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),Name("arg_1"),Type("TermList",TLType(" master.matching2.term.types.TermList ")))),MatchConstraint(RecordAppl(concOption(OriginTracking(Name("conc"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),concTomName(Name("conc")),concSlot(PairSlotAppl(EmptyName(),Variable(concOption(OriginTracking(Name("h2"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),Name("h2"),Type("Term",TLType(" master.matching2.term.types.Term ")),concConstraint())),PairSlotAppl(EmptyName(),VariableStar(concOption(OriginTracking(Name("t2"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),Name("t2"),TypeWithSymbol("TermList",TLType(" master.matching2.term.types.TermList "),Name("conc")),concConstraint()))),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_2"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t")),Name("arg_2"),Type("TermList",TLType(" master.matching2.term.types.TermList "))))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(123,33),TextPosition(123,42)))),BQTermToInstruction(Composite(CompositeBQTerm(BuildConsList(Name("And"),Composite(CompositeBQTerm(BuildTerm(Name("Match"),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("h1"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t"),ModuleName("default")),Name("h1"),Type("Term",TLType(" master.matching2.term.types.Term "))))),Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("h2"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t"),ModuleName("default")),Name("h2"),Type("Term",TLType(" master.matching2.term.types.Term ")))))),"default"))),BuildConsList(Name("And"),Composite(CompositeBQTerm(BuildTerm(Name("decomposeList"),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("t1"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t"),ModuleName("default")),Name("t1"),TypeWithSymbol("TermList",TLType(" master.matching2.term.types.TermList "),Name("conc"))))),Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("t2"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t"),ModuleName("default")),Name("t2"),TypeWithSymbol("TermList",TLType(" master.matching2.term.types.TermList "),Name("conc")))))),"default"))),BuildEmptyList(Name("And"))))))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(123,84),TextPosition(123,86))))))),concOption(OriginalText(Name(""))))),concOption(OriginTracking(Name("Match"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp707167517230789308.t"),ModuleName("default")))),TargetLanguageToCode(TL("\n}\n      return realMake( arg_1,  arg_2);\n    }\n  \n  private static decomposeList realMake(master.matching2.term.types.TermList _l1, master.matching2.term.types.TermList _l2) {\n\n    // use the proto as a model\n    proto.initHashCode( _l1,  _l2);\n    return (decomposeList) factory.build(proto);\n\n  }\n\n  /**\n   * Initializes attributes and hashcode of the class\n   *\n   * @param  _l1\n   * @param _l2\n   * @param hashCode hashCode of decomposeList\n   */\n  private void init(master.matching2.term.types.TermList _l1, master.matching2.term.types.TermList _l2, int hashCode) {\n    this._l1 = _l1;\n    this._l2 = _l2;\n\n    this.hashCode = hashCode;\n  }\n\n  /**\n   * Initializes attributes and hashcode of the class\n   *\n   * @param  _l1\n   * @param _l2\n   */\n  private void initHashCode(master.matching2.term.types.TermList _l1, master.matching2.term.types.TermList _l2) {\n    this._l1 = _l1;\n    this._l2 = _l2;\n\n    this.hashCode = hashFunction();\n  }\n\n  /* name and arity */\n\n  /**\n   * Returns the name of the symbol\n   *\n   * @return the name of the symbol\n   */\n  @Override\n  public String symbolName() {\n    return \"decomposeList\";\n  }\n\n  /**\n   * Returns the arity of the symbol\n   *\n   * @return the arity of the symbol\n   */\n  private int getArity() {\n    return 2;\n  }\n\n  /**\n   * Copy the object and returns the copy\n   *\n   * @return a clone of the SharedObject\n   */\n  public shared.SharedObject duplicate() {\n    decomposeList clone = new decomposeList();\n    clone.init( _l1,  _l2, hashCode);\n    return clone;\n  }\n  \n  /**\n   * Appends a string representation of this term to the buffer given as argument.\n   *\n   * @param buffer the buffer to which a string represention of this term is appended.\n   */\n  @Override\n  public void toStringBuilder(java.lang.StringBuilder buffer) {\n    buffer.append(\"decomposeList(\");\n    _l1.toStringBuilder(buffer);\nbuffer.append(\",\");\n    _l2.toStringBuilder(buffer);\n\n    buffer.append(\")\");\n  }\n\n\n  /**\n   * Compares two terms. This functions implements a total lexicographic path ordering.\n   *\n   * @param o object to which this term is compared\n   * @return a negative integer, zero, or a positive integer as this\n   *         term is less than, equal to, or greater than the argument\n   * @throws ClassCastException in case of invalid arguments\n   * @throws RuntimeException if unable to compare childs\n   */\n  @Override\n  public int compareToLPO(Object o) {\n    /*\n     * We do not want to compare with any object, only members of the module\n     * In case of invalid argument, throw a ClassCastException, as the java api\n     * asks for it\n     */\n    master.matching2.term.TermAbstractType ao = (master.matching2.term.TermAbstractType) o;\n    /* return 0 for equality */\n    if (ao == this) { return 0; }\n    /* compare the symbols */\n    int symbCmp = this.symbolName().compareTo(ao.symbolName());\n    if (symbCmp != 0) { return symbCmp; }\n    /* compare the childs */\n    decomposeList tco = (decomposeList) ao;\n    int _l1Cmp = (this._l1).compareToLPO(tco._l1);\n    if(_l1Cmp != 0)\n      return _l1Cmp;\n\n    int _l2Cmp = (this._l2).compareToLPO(tco._l2);\n    if(_l2Cmp != 0)\n      return _l2Cmp;\n\n    throw new RuntimeException(\"Unable to compare\");\n  }\n\n /**\n   * Compares two terms. This functions implements a total order.\n   *\n   * @param o object to which this term is compared\n   * @return a negative integer, zero, or a positive integer as this\n   *         term is less than, equal to, or greater than the argument\n   * @throws ClassCastException in case of invalid arguments\n   * @throws RuntimeException if unable to compare childs\n   */\n  @Override\n  public int compareTo(Object o) {\n    /*\n     * We do not want to compare with any object, only members of the module\n     * In case of invalid argument, throw a ClassCastException, as the java api\n     * asks for it\n     */\n    master.matching2.term.TermAbstractType ao = (master.matching2.term.TermAbstractType) o;\n    /* return 0 for equality */\n    if (ao == this) { return 0; }\n    /* use the hash values to discriminate */\n\n    if(hashCode != ao.hashCode()) { return (hashCode < ao.hashCode())?-1:1; }\n\n    /* If not, compare the symbols : back to the normal order */\n    int symbCmp = this.symbolName().compareTo(ao.symbolName());\n    if (symbCmp != 0) { return symbCmp; }\n    /* last resort: compare the childs */\n    decomposeList tco = (decomposeList) ao;\n    int _l1Cmp = (this._l1).compareTo(tco._l1);\n    if(_l1Cmp != 0)\n      return _l1Cmp;\n\n    int _l2Cmp = (this._l2).compareTo(tco._l2);\n    if(_l2Cmp != 0)\n      return _l2Cmp;\n\n    throw new RuntimeException(\"Unable to compare\");\n  }\n\n //shared.SharedObject\n  /**\n   * Returns hashCode\n   *\n   * @return hashCode\n   */\n  @Override\n  public final int hashCode() {\n    return hashCode;\n  }\n\n  /**\n   * Checks if a SharedObject is equivalent to the current object\n   *\n   * @param obj SharedObject to test\n   * @return true if obj is a decomposeList and its members are equal, else false\n   */\n  public final boolean equivalent(shared.SharedObject obj) {\n    if(obj instanceof decomposeList) {\n\n      decomposeList peer = (decomposeList) obj;\n      return _l1==peer._l1 && _l2==peer._l2 && true;\n    }\n    return false;\n  }\n\n\n   //Term interface\n  /**\n   * Returns true if the term is rooted by the symbol decomposeList\n   *\n   * @return true, because this is rooted by decomposeList\n   */\n  @Override\n  public boolean isdecomposeList() {\n    return true;\n  }\n  \n  /**\n   * Returns the attribute master.matching2.term.types.TermList\n   *\n   * @return the attribute master.matching2.term.types.TermList\n   */\n  @Override\n  public master.matching2.term.types.TermList getl1() {\n    return _l1;\n  }\n\n  /**\n   * Sets and returns the attribute master.matching2.term.types.Term\n   *\n   * @param set_arg the argument to set\n   * @return the attribute master.matching2.term.types.TermList which just has been set\n   */\n  @Override\n  public master.matching2.term.types.Term setl1(master.matching2.term.types.TermList set_arg) {\n    return make(set_arg, _l2);\n  }\n  \n  /**\n   * Returns the attribute master.matching2.term.types.TermList\n   *\n   * @return the attribute master.matching2.term.types.TermList\n   */\n  @Override\n  public master.matching2.term.types.TermList getl2() {\n    return _l2;\n  }\n\n  /**\n   * Sets and returns the attribute master.matching2.term.types.Term\n   *\n   * @param set_arg the argument to set\n   * @return the attribute master.matching2.term.types.TermList which just has been set\n   */\n  @Override\n  public master.matching2.term.types.Term setl2(master.matching2.term.types.TermList set_arg) {\n    return make(_l1, set_arg);\n  }\n  \n  /* AbstractType */\n  /**\n   * Returns an ATerm representation of this term.\n   *\n   * @return an ATerm representation of this term.\n   */\n  @Override\n  public aterm.ATerm toATerm() {\n    aterm.ATerm res = super.toATerm();\n    if(res != null) {\n      // the super class has produced an ATerm (may be a variadic operator)\n      return res;\n    }\n    return atermFactory.makeAppl(\n      atermFactory.makeAFun(symbolName(),getArity(),false),\n      new aterm.ATerm[] {getl1().toATerm(), getl2().toATerm()});\n  }\n\n  /**\n   * Apply a conversion on the ATerm contained in the String and returns a master.matching2.term.types.Term from it\n   *\n   * @param trm ATerm to convert into a Gom term\n   * @param atConv ATerm Converter used to convert the ATerm\n   * @return the Gom term\n   */\n  public static master.matching2.term.types.Term fromTerm(aterm.ATerm trm, tom.library.utils.ATermConverter atConv) {\n    trm = atConv.convert(trm);\n    if(trm instanceof aterm.ATermAppl) {\n      aterm.ATermAppl appl = (aterm.ATermAppl) trm;\n      if(symbolName.equals(appl.getName()) && !appl.getAFun().isQuoted()) {\n        return make(\nmaster.matching2.term.types.TermList.fromTerm(appl.getArgument(0),atConv), master.matching2.term.types.TermList.fromTerm(appl.getArgument(1),atConv)\n        );\n      }\n    }\n    return null;\n  }\n\n  /* Visitable */\n  /**\n   * Returns the number of childs of the term\n   *\n   * @return the number of childs of the term\n   */\n  public int getChildCount() {\n    return 2;\n  }\n\n  /**\n   * Returns the child at the specified index\n   *\n   * @param index index of the child to return; must be\n             nonnegative and less than the childCount\n   * @return the child at the specified index\n   * @throws IndexOutOfBoundsException if the index out of range\n   */\n  public tom.library.sl.Visitable getChildAt(int index) {\n    switch(index) {\n      case 0: return _l1;\n      case 1: return _l2;\n\n      default: throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Set the child at the specified index\n   *\n   * @param index index of the child to set; must be\n             nonnegative and less than the childCount\n   * @param v child to set at the specified index\n   * @return the child which was just set\n   * @throws IndexOutOfBoundsException if the index out of range\n   */\n  public tom.library.sl.Visitable setChildAt(int index, tom.library.sl.Visitable v) {\n    switch(index) {\n      case 0: return make((master.matching2.term.types.TermList) v, _l2);\n      case 1: return make(_l1, (master.matching2.term.types.TermList) v);\n\n      default: throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Set children to the term\n   *\n   * @param childs array of children to set\n   * @return an array of children which just were set\n   * @throws IndexOutOfBoundsException if length of \"childs\" is different than 2\n   */\n  @SuppressWarnings(\"unchecked\")\n  public tom.library.sl.Visitable setChildren(tom.library.sl.Visitable[] childs) {\n    if (childs.length == 2  && childs[0] instanceof master.matching2.term.types.TermList && childs[1] instanceof master.matching2.term.types.TermList) {\n      return make((master.matching2.term.types.TermList) childs[0], (master.matching2.term.types.TermList) childs[1]);\n    } else {\n      throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Returns the whole children of the term\n   *\n   * @return the children of the term\n   */\n  public tom.library.sl.Visitable[] getChildren() {\n    return new tom.library.sl.Visitable[] {  _l1,  _l2 };\n  }\n\n    /**\n     * Compute a hashcode for this term.\n     * (for internal use)\n     *\n     * @return a hash value\n     */\n  protected int hashFunction() {\n    int a, b, c;\n    /* Set up the internal state */\n    a = 0x9e3779b9; /* the golden ratio; an arbitrary value */\n    b = (88757963<<8);\n    c = getArity();\n    /* -------------------------------------- handle most of the key */\n    /* ------------------------------------ handle the last 11 bytes */\n    a += (_l1.hashCode() << 8);\n    a += (_l2.hashCode());\n\n    a -= b; a -= c; a ^= (c >> 13);\n    b -= c; b -= a; b ^= (a << 8);\n    c -= a; c -= b; c ^= (b >> 13);\n    a -= b; a -= c; a ^= (c >> 12);\n    b -= c; b -= a; b ^= (a << 16);\n    c -= a; c -= b; c ^= (b >> 5);\n    a -= b; a -= c; a ^= (c >> 3);\n    b -= c; b -= a; b ^= (a << 10);\n    c -= a; c -= b; c ^= (b >> 15);\n    /* ------------------------------------------- report the result */\n    return c;\n  }\n\n}\n",TextPosition(124,5),TextPosition(505,1)))))

Code after type inference = 
Tom(concCode(TargetLanguageToCode(TL("\npackage master.matching2.term.types.term;\n\n\n\npublic final class Match extends master.matching2.term.types.Term implements tom.library.sl.Visitable  {\n  \n  private static String symbolName = \"Match\";\n\n\n  private Match() {}\n  private int hashCode;\n  private static Match proto = new Match();\n  \n",TextPosition(1,1),TextPosition(15,1))),TomInclude(concCode(TomInclude(concCode(DeclarationToCode(TypeTermDecl(Name("char"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),Name("t1"),Type("char",TLType(" char "))),BQVariable(concOption(OriginTracking(Name("t2"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),Name("t2"),Type("char",TLType(" char "))),Code(" {0}=={1} "),OriginTracking(Name("equals"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),34,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),Name("t"),Type("char",TLType(" char "))),Code(" true "),OriginTracking(Name("is_sort"),34,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom"))),OriginTracking(Name("char"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom"))),TargetLanguageToCode(TL("\n",TextPosition(36,1),TextPosition(37,1))))),DeclarationToCode(TypeTermDecl(Name("String"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),36,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),Name("t1"),Type("String",TLType(" String "))),BQVariable(concOption(OriginTracking(Name("t2"),36,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),Name("t2"),Type("String",TLType(" String "))),Code(" {0}.equals({1}) "),OriginTracking(Name("equals"),36,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),Name("t"),Type("String",TLType(" String "))),Code(" {0} instanceof String "),OriginTracking(Name("is_sort"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom"))),OriginTracking(Name("String"),33,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom"))),DeclarationToCode(ListSymbolDecl(Name("concString"))),TargetLanguageToCode(TL("\n",TextPosition(46,1),TextPosition(47,1))))),DeclarationToCode(TypeTermDecl(Name("TermList"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("t1"),Type("TermList",TLType(" master.matching2.term.types.TermList "))),BQVariable(concOption(OriginTracking(Name("t2"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("t2"),Type("TermList",TLType(" master.matching2.term.types.TermList "))),Code(" ({0}=={1}) "),OriginTracking(Name("equals"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),19,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("t"),Type("TermList",TLType(" master.matching2.term.types.TermList "))),Code(" ({0} instanceof master.matching2.term.types.TermList) "),OriginTracking(Name("is_sort"),19,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t"))),OriginTracking(Name("TermList"),17,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t"))),DeclarationToCode(TypeTermDecl(Name("Term"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),29,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("t1"),Type("Term",TLType(" master.matching2.term.types.Term "))),BQVariable(concOption(OriginTracking(Name("t2"),29,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("t2"),Type("Term",TLType(" master.matching2.term.types.Term "))),Code(" ({0}=={1}) "),OriginTracking(Name("equals"),29,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),27,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("t"),Type("Term",TLType(" master.matching2.term.types.Term "))),Code(" ({0} instanceof master.matching2.term.types.Term) "),OriginTracking(Name("is_sort"),27,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t"))),OriginTracking(Name("Term"),25,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t"))),DeclarationToCode(SymbolDecl(Name("Emptyconc"))),DeclarationToCode(SymbolDecl(Name("Consconc"))),DeclarationToCode(SymbolDecl(Name("Variable"))),DeclarationToCode(SymbolDecl(Name("Appl"))),DeclarationToCode(SymbolDecl(Name("True"))),DeclarationToCode(SymbolDecl(Name("False"))),DeclarationToCode(SymbolDecl(Name("Match"))),DeclarationToCode(SymbolDecl(Name("EmptyAnd"))),DeclarationToCode(SymbolDecl(Name("ConsAnd"))),DeclarationToCode(SymbolDecl(Name("decomposeList"))),DeclarationToCode(ListSymbolDecl(Name("conc"))),DeclarationToCode(ListSymbolDecl(Name("And"))),TargetLanguageToCode(TL("\n  private master.matching2.term.types.Term _pattern;\n  private master.matching2.term.types.Term _subject;\n\n  /**\n   * Constructor that builds a term rooted by Match\n   *\n   * @return a term rooted by Match\n   */\n\n    public static master.matching2.term.types.Term make(master.matching2.term.types.Term arg_1, master.matching2.term.types.Term arg_2) {\n  if (true) {    ",TextPosition(110,1),TextPosition(121,18))),InstructionToCode(Match(concConstraintInstruction(ConstraintInstruction(AndConstraint(MatchConstraint(RecordAppl(concOption(OriginTracking(Name("Appl"),122,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),concTomName(Name("Appl")),concSlot(PairSlotAppl(Name("name"),Variable(concOption(OriginTracking(Name("name"),122,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("name"),Type("String",TLType(" String ")),concConstraint())),PairSlotAppl(Name("args"),RecordAppl(concOption(OriginTracking(Name("conc"),122,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),concTomName(Name("conc")),concSlot(),concConstraint()))),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_1"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("arg_1"),Type("Term",TLType(" master.matching2.term.types.Term ")))),MatchConstraint(RecordAppl(concOption(OriginTracking(Name("Appl"),122,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),concTomName(Name("Appl")),concSlot(PairSlotAppl(Name("name"),Variable(concOption(OriginTracking(Name("name"),122,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("name"),Type("String",TLType(" String ")),concConstraint())),PairSlotAppl(Name("args"),RecordAppl(concOption(OriginTracking(Name("conc"),122,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),concTomName(Name("conc")),concSlot(),concConstraint()))),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_2"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("arg_2"),Type("Term",TLType(" master.matching2.term.types.Term "))))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(122,43),TextPosition(122,52)))),BQTermToInstruction(Composite(CompositeBQTerm(BuildTerm(Name("True"),concBQTerm(),"default")))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(122,59),TextPosition(122,61))))))),concOption(OriginalText(Name("")))),ConstraintInstruction(AndConstraint(MatchConstraint(RecordAppl(concOption(OriginTracking(Name("Appl"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),concTomName(Name("Appl")),concSlot(PairSlotAppl(Name("name"),Variable(concOption(OriginTracking(Name("name"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("name"),Type("String",TLType(" String ")),concConstraint())),PairSlotAppl(Name("args"),Variable(concOption(OriginTracking(Name("arg1"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("arg1"),Type("TermList",TLType(" master.matching2.term.types.TermList ")),concConstraint()))),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_1"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("arg_1"),Type("Term",TLType(" master.matching2.term.types.Term ")))),MatchConstraint(RecordAppl(concOption(OriginTracking(Name("Appl"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),concTomName(Name("Appl")),concSlot(PairSlotAppl(Name("name"),Variable(concOption(OriginTracking(Name("name"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("name"),Type("String",TLType(" String ")),concConstraint())),PairSlotAppl(Name("args"),Variable(concOption(OriginTracking(Name("arg2"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("arg2"),Type("TermList",TLType(" master.matching2.term.types.TermList ")),concConstraint()))),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_2"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("arg_2"),Type("Term",TLType(" master.matching2.term.types.Term "))))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(123,39),TextPosition(123,48)))),BQTermToInstruction(Composite(CompositeBQTerm(BuildTerm(Name("decomposeList"),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("arg1"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t"),ModuleName("default")),Name("arg1"),Type("TermList",TLType(" master.matching2.term.types.TermList "))))),Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("arg2"),123,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t"),ModuleName("default")),Name("arg2"),Type("TermList",TLType(" master.matching2.term.types.TermList ")))))),"default")))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(123,74),TextPosition(123,76))))))),concOption(OriginalText(Name("")))),ConstraintInstruction(AndConstraint(MatchConstraint(RecordAppl(concOption(OriginTracking(Name("Appl"),124,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),concTomName(Name("Appl")),concSlot(PairSlotAppl(Name("name"),Variable(concOption(OriginTracking(Name("name1"),124,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("name1"),Type("String",TLType(" String ")),concConstraint())),PairSlotAppl(Name("args"),Variable(concOption(OriginTracking(Name("arg1"),124,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("arg1"),Type("TermList",TLType(" master.matching2.term.types.TermList ")),concConstraint()))),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_1"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("arg_1"),Type("Term",TLType(" master.matching2.term.types.Term ")))),MatchConstraint(RecordAppl(concOption(OriginTracking(Name("Appl"),124,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),concTomName(Name("Appl")),concSlot(PairSlotAppl(Name("name"),Variable(concOption(OriginTracking(Name("name2"),124,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("name2"),Type("String",TLType(" String ")),concConstraint())),PairSlotAppl(Name("args"),Variable(concOption(OriginTracking(Name("arg2"),124,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("arg2"),Type("TermList",TLType(" master.matching2.term.types.TermList ")),concConstraint()))),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_2"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t")),Name("arg_2"),Type("Term",TLType(" master.matching2.term.types.Term "))))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(124,41),TextPosition(124,50)))),BQTermToInstruction(Composite(CompositeBQTerm(BuildTerm(Name("False"),concBQTerm(),"default")))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(124,58),TextPosition(124,60))))))),concOption(OriginalText(Name(""))))),concOption(OriginTracking(Name("Match"),121,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp797793937880741836.t"),ModuleName("default")))),TargetLanguageToCode(TL("\n}\n      return realMake( arg_1,  arg_2);\n    }\n  \n  private static Match realMake(master.matching2.term.types.Term _pattern, master.matching2.term.types.Term _subject) {\n\n    // use the proto as a model\n    proto.initHashCode( _pattern,  _subject);\n    return (Match) factory.build(proto);\n\n  }\n\n  /**\n   * Initializes attributes and hashcode of the class\n   *\n   * @param  _pattern\n   * @param _subject\n   * @param hashCode hashCode of Match\n   */\n  private void init(master.matching2.term.types.Term _pattern, master.matching2.term.types.Term _subject, int hashCode) {\n    this._pattern = _pattern;\n    this._subject = _subject;\n\n    this.hashCode = hashCode;\n  }\n\n  /**\n   * Initializes attributes and hashcode of the class\n   *\n   * @param  _pattern\n   * @param _subject\n   */\n  private void initHashCode(master.matching2.term.types.Term _pattern, master.matching2.term.types.Term _subject) {\n    this._pattern = _pattern;\n    this._subject = _subject;\n\n    this.hashCode = hashFunction();\n  }\n\n  /* name and arity */\n\n  /**\n   * Returns the name of the symbol\n   *\n   * @return the name of the symbol\n   */\n  @Override\n  public String symbolName() {\n    return \"Match\";\n  }\n\n  /**\n   * Returns the arity of the symbol\n   *\n   * @return the arity of the symbol\n   */\n  private int getArity() {\n    return 2;\n  }\n\n  /**\n   * Copy the object and returns the copy\n   *\n   * @return a clone of the SharedObject\n   */\n  public shared.SharedObject duplicate() {\n    Match clone = new Match();\n    clone.init( _pattern,  _subject, hashCode);\n    return clone;\n  }\n  \n  /**\n   * Appends a string representation of this term to the buffer given as argument.\n   *\n   * @param buffer the buffer to which a string represention of this term is appended.\n   */\n  @Override\n  public void toStringBuilder(java.lang.StringBuilder buffer) {\n    buffer.append(\"Match(\");\n    _pattern.toStringBuilder(buffer);\nbuffer.append(\",\");\n    _subject.toStringBuilder(buffer);\n\n    buffer.append(\")\");\n  }\n\n\n  /**\n   * Compares two terms. This functions implements a total lexicographic path ordering.\n   *\n   * @param o object to which this term is compared\n   * @return a negative integer, zero, or a positive integer as this\n   *         term is less than, equal to, or greater than the argument\n   * @throws ClassCastException in case of invalid arguments\n   * @throws RuntimeException if unable to compare childs\n   */\n  @Override\n  public int compareToLPO(Object o) {\n    /*\n     * We do not want to compare with any object, only members of the module\n     * In case of invalid argument, throw a ClassCastException, as the java api\n     * asks for it\n     */\n    master.matching2.term.TermAbstractType ao = (master.matching2.term.TermAbstractType) o;\n    /* return 0 for equality */\n    if (ao == this) { return 0; }\n    /* compare the symbols */\n    int symbCmp = this.symbolName().compareTo(ao.symbolName());\n    if (symbCmp != 0) { return symbCmp; }\n    /* compare the childs */\n    Match tco = (Match) ao;\n    int _patternCmp = (this._pattern).compareToLPO(tco._pattern);\n    if(_patternCmp != 0)\n      return _patternCmp;\n\n    int _subjectCmp = (this._subject).compareToLPO(tco._subject);\n    if(_subjectCmp != 0)\n      return _subjectCmp;\n\n    throw new RuntimeException(\"Unable to compare\");\n  }\n\n /**\n   * Compares two terms. This functions implements a total order.\n   *\n   * @param o object to which this term is compared\n   * @return a negative integer, zero, or a positive integer as this\n   *         term is less than, equal to, or greater than the argument\n   * @throws ClassCastException in case of invalid arguments\n   * @throws RuntimeException if unable to compare childs\n   */\n  @Override\n  public int compareTo(Object o) {\n    /*\n     * We do not want to compare with any object, only members of the module\n     * In case of invalid argument, throw a ClassCastException, as the java api\n     * asks for it\n     */\n    master.matching2.term.TermAbstractType ao = (master.matching2.term.TermAbstractType) o;\n    /* return 0 for equality */\n    if (ao == this) { return 0; }\n    /* use the hash values to discriminate */\n\n    if(hashCode != ao.hashCode()) { return (hashCode < ao.hashCode())?-1:1; }\n\n    /* If not, compare the symbols : back to the normal order */\n    int symbCmp = this.symbolName().compareTo(ao.symbolName());\n    if (symbCmp != 0) { return symbCmp; }\n    /* last resort: compare the childs */\n    Match tco = (Match) ao;\n    int _patternCmp = (this._pattern).compareTo(tco._pattern);\n    if(_patternCmp != 0)\n      return _patternCmp;\n\n    int _subjectCmp = (this._subject).compareTo(tco._subject);\n    if(_subjectCmp != 0)\n      return _subjectCmp;\n\n    throw new RuntimeException(\"Unable to compare\");\n  }\n\n //shared.SharedObject\n  /**\n   * Returns hashCode\n   *\n   * @return hashCode\n   */\n  @Override\n  public final int hashCode() {\n    return hashCode;\n  }\n\n  /**\n   * Checks if a SharedObject is equivalent to the current object\n   *\n   * @param obj SharedObject to test\n   * @return true if obj is a Match and its members are equal, else false\n   */\n  public final boolean equivalent(shared.SharedObject obj) {\n    if(obj instanceof Match) {\n\n      Match peer = (Match) obj;\n      return _pattern==peer._pattern && _subject==peer._subject && true;\n    }\n    return false;\n  }\n\n\n   //Term interface\n  /**\n   * Returns true if the term is rooted by the symbol Match\n   *\n   * @return true, because this is rooted by Match\n   */\n  @Override\n  public boolean isMatch() {\n    return true;\n  }\n  \n  /**\n   * Returns the attribute master.matching2.term.types.Term\n   *\n   * @return the attribute master.matching2.term.types.Term\n   */\n  @Override\n  public master.matching2.term.types.Term getpattern() {\n    return _pattern;\n  }\n\n  /**\n   * Sets and returns the attribute master.matching2.term.types.Term\n   *\n   * @param set_arg the argument to set\n   * @return the attribute master.matching2.term.types.Term which just has been set\n   */\n  @Override\n  public master.matching2.term.types.Term setpattern(master.matching2.term.types.Term set_arg) {\n    return make(set_arg, _subject);\n  }\n  \n  /**\n   * Returns the attribute master.matching2.term.types.Term\n   *\n   * @return the attribute master.matching2.term.types.Term\n   */\n  @Override\n  public master.matching2.term.types.Term getsubject() {\n    return _subject;\n  }\n\n  /**\n   * Sets and returns the attribute master.matching2.term.types.Term\n   *\n   * @param set_arg the argument to set\n   * @return the attribute master.matching2.term.types.Term which just has been set\n   */\n  @Override\n  public master.matching2.term.types.Term setsubject(master.matching2.term.types.Term set_arg) {\n    return make(_pattern, set_arg);\n  }\n  \n  /* AbstractType */\n  /**\n   * Returns an ATerm representation of this term.\n   *\n   * @return an ATerm representation of this term.\n   */\n  @Override\n  public aterm.ATerm toATerm() {\n    aterm.ATerm res = super.toATerm();\n    if(res != null) {\n      // the super class has produced an ATerm (may be a variadic operator)\n      return res;\n    }\n    return atermFactory.makeAppl(\n      atermFactory.makeAFun(symbolName(),getArity(),false),\n      new aterm.ATerm[] {getpattern().toATerm(), getsubject().toATerm()});\n  }\n\n  /**\n   * Apply a conversion on the ATerm contained in the String and returns a master.matching2.term.types.Term from it\n   *\n   * @param trm ATerm to convert into a Gom term\n   * @param atConv ATerm Converter used to convert the ATerm\n   * @return the Gom term\n   */\n  public static master.matching2.term.types.Term fromTerm(aterm.ATerm trm, tom.library.utils.ATermConverter atConv) {\n    trm = atConv.convert(trm);\n    if(trm instanceof aterm.ATermAppl) {\n      aterm.ATermAppl appl = (aterm.ATermAppl) trm;\n      if(symbolName.equals(appl.getName()) && !appl.getAFun().isQuoted()) {\n        return make(\nmaster.matching2.term.types.Term.fromTerm(appl.getArgument(0),atConv), master.matching2.term.types.Term.fromTerm(appl.getArgument(1),atConv)\n        );\n      }\n    }\n    return null;\n  }\n\n  /* Visitable */\n  /**\n   * Returns the number of childs of the term\n   *\n   * @return the number of childs of the term\n   */\n  public int getChildCount() {\n    return 2;\n  }\n\n  /**\n   * Returns the child at the specified index\n   *\n   * @param index index of the child to return; must be\n             nonnegative and less than the childCount\n   * @return the child at the specified index\n   * @throws IndexOutOfBoundsException if the index out of range\n   */\n  public tom.library.sl.Visitable getChildAt(int index) {\n    switch(index) {\n      case 0: return _pattern;\n      case 1: return _subject;\n\n      default: throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Set the child at the specified index\n   *\n   * @param index index of the child to set; must be\n             nonnegative and less than the childCount\n   * @param v child to set at the specified index\n   * @return the child which was just set\n   * @throws IndexOutOfBoundsException if the index out of range\n   */\n  public tom.library.sl.Visitable setChildAt(int index, tom.library.sl.Visitable v) {\n    switch(index) {\n      case 0: return make((master.matching2.term.types.Term) v, _subject);\n      case 1: return make(_pattern, (master.matching2.term.types.Term) v);\n\n      default: throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Set children to the term\n   *\n   * @param childs array of children to set\n   * @return an array of children which just were set\n   * @throws IndexOutOfBoundsException if length of \"childs\" is different than 2\n   */\n  @SuppressWarnings(\"unchecked\")\n  public tom.library.sl.Visitable setChildren(tom.library.sl.Visitable[] childs) {\n    if (childs.length == 2  && childs[0] instanceof master.matching2.term.types.Term && childs[1] instanceof master.matching2.term.types.Term) {\n      return make((master.matching2.term.types.Term) childs[0], (master.matching2.term.types.Term) childs[1]);\n    } else {\n      throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Returns the whole children of the term\n   *\n   * @return the children of the term\n   */\n  public tom.library.sl.Visitable[] getChildren() {\n    return new tom.library.sl.Visitable[] {  _pattern,  _subject };\n  }\n\n    /**\n     * Compute a hashcode for this term.\n     * (for internal use)\n     *\n     * @return a hash value\n     */\n  protected int hashFunction() {\n    int a, b, c;\n    /* Set up the internal state */\n    a = 0x9e3779b9; /* the golden ratio; an arbitrary value */\n    b = (-722832978<<8);\n    c = getArity();\n    /* -------------------------------------- handle most of the key */\n    /* ------------------------------------ handle the last 11 bytes */\n    a += (_pattern.hashCode() << 8);\n    a += (_subject.hashCode());\n\n    a -= b; a -= c; a ^= (c >> 13);\n    b -= c; b -= a; b ^= (a << 8);\n    c -= a; c -= b; c ^= (b >> 13);\n    a -= b; a -= c; a ^= (c >> 12);\n    b -= c; b -= a; b ^= (a << 16);\n    c -= a; c -= b; c ^= (b >> 5);\n    a -= b; a -= c; a ^= (c >> 3);\n    b -= c; b -= a; b ^= (a << 10);\n    c -= a; c -= b; c ^= (b >> 15);\n    /* ------------------------------------------- report the result */\n    return c;\n  }\n\n}\n",TextPosition(125,5),TextPosition(506,1)))))

Code after type inference = 
Tom(concCode(TargetLanguageToCode(TL("package master;\nimport master.matching2.term.types.*;\n\nclass Matching2 {\n  ",TextPosition(1,1),TextPosition(5,3))),TomInclude(concCode(TomInclude(concCode(TomInclude(concCode(DeclarationToCode(TypeTermDecl(Name("char"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),Name("t1"),Type("char",TLType(" char "))),BQVariable(concOption(OriginTracking(Name("t2"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),Name("t2"),Type("char",TLType(" char "))),Code(" {0}=={1} "),OriginTracking(Name("equals"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),34,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom")),Name("t"),Type("char",TLType(" char "))),Code(" true "),OriginTracking(Name("is_sort"),34,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom"))),OriginTracking(Name("char"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/char.tom"))),TargetLanguageToCode(TL("\n",TextPosition(36,1),TextPosition(37,1))))),DeclarationToCode(TypeTermDecl(Name("String"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),36,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),Name("t1"),Type("String",TLType(" String "))),BQVariable(concOption(OriginTracking(Name("t2"),36,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),Name("t2"),Type("String",TLType(" String "))),Code(" {0}.equals({1}) "),OriginTracking(Name("equals"),36,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom")),Name("t"),Type("String",TLType(" String "))),Code(" {0} instanceof String "),OriginTracking(Name("is_sort"),35,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom"))),OriginTracking(Name("String"),33,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/string.tom"))),DeclarationToCode(ListSymbolDecl(Name("concString"))),TargetLanguageToCode(TL("\n",TextPosition(46,1),TextPosition(47,1))))),DeclarationToCode(TypeTermDecl(Name("TermList"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),8,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/matching2/term/Term.tom")),Name("t1"),Type("TermList",TLType(" master.matching2.term.types.TermList "))),BQVariable(concOption(OriginTracking(Name("t2"),8,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/matching2/term/Term.tom")),Name("t2"),Type("TermList",TLType(" master.matching2.term.types.TermList "))),Code(" ({0}=={1}) "),OriginTracking(Name("equals"),8,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/matching2/term/Term.tom")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),6,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/matching2/term/Term.tom")),Name("t"),Type("TermList",TLType(" master.matching2.term.types.TermList "))),Code(" ({0} instanceof master.matching2.term.types.TermList) "),OriginTracking(Name("is_sort"),6,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/matching2/term/Term.tom"))),OriginTracking(Name("TermList"),4,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/matching2/term/Term.tom"))),DeclarationToCode(TypeTermDecl(Name("Term"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),16,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/matching2/term/Term.tom")),Name("t1"),Type("Term",TLType(" master.matching2.term.types.Term "))),BQVariable(concOption(OriginTracking(Name("t2"),16,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/matching2/term/Term.tom")),Name("t2"),Type("Term",TLType(" master.matching2.term.types.Term "))),Code(" ({0}=={1}) "),OriginTracking(Name("equals"),16,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/matching2/term/Term.tom")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),14,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/matching2/term/Term.tom")),Name("t"),Type("Term",TLType(" master.matching2.term.types.Term "))),Code(" ({0} instanceof master.matching2.term.types.Term) "),OriginTracking(Name("is_sort"),14,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/matching2/term/Term.tom"))),OriginTracking(Name("Term"),12,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/matching2/term/Term.tom"))),DeclarationToCode(SymbolDecl(Name("Emptyconc"))),DeclarationToCode(SymbolDecl(Name("Consconc"))),DeclarationToCode(SymbolDecl(Name("Variable"))),DeclarationToCode(SymbolDecl(Name("Appl"))),DeclarationToCode(SymbolDecl(Name("True"))),DeclarationToCode(SymbolDecl(Name("False"))),DeclarationToCode(SymbolDecl(Name("Match"))),DeclarationToCode(SymbolDecl(Name("EmptyAnd"))),DeclarationToCode(SymbolDecl(Name("ConsAnd"))),DeclarationToCode(SymbolDecl(Name("decomposeList"))),DeclarationToCode(ListSymbolDecl(Name("conc"))),DeclarationToCode(ListSymbolDecl(Name("And"))),TargetLanguageToCode(TL("\n",TextPosition(97,1),TextPosition(98,1))))),TargetLanguageToCode(TL("\n\n  //-------------------------------------------------------\n\n  public final static void main(String[] args) {\n    Term p1 = ",TextPosition(43,4),TextPosition(48,15))),BQTermToCode(Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"f\""))),Composite(CompositeBQTerm(BuildConsList(Name("conc"),Composite(CompositeBQTerm(BuildTerm(Name("Variable"),concBQTerm(Composite(CompositeTL(ITL("\"x\"")))),"default"))),BuildEmptyList(Name("conc")))))),"default")))),TargetLanguageToCode(TL(";\n    Term s1 = ",TextPosition(48,45),TextPosition(49,15))),BQTermToCode(Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"f\""))),Composite(CompositeBQTerm(BuildConsList(Name("conc"),Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"a\""))),Composite(CompositeBQTerm(BuildEmptyList(Name("conc"))))),"default"))),BuildEmptyList(Name("conc")))))),"default")))),TargetLanguageToCode(TL(";\n\n    Term p2 = ",TextPosition(49,48),TextPosition(51,15))),BQTermToCode(Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"f\""))),Composite(CompositeBQTerm(BuildConsList(Name("conc"),Composite(CompositeBQTerm(BuildTerm(Name("Variable"),concBQTerm(Composite(CompositeTL(ITL("\"x\"")))),"default"))),BuildConsList(Name("conc"),Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"g\""))),Composite(CompositeBQTerm(BuildConsList(Name("conc"),Composite(CompositeBQTerm(BuildTerm(Name("Variable"),concBQTerm(Composite(CompositeTL(ITL("\"y\"")))),"default"))),BuildEmptyList(Name("conc")))))),"default"))),BuildEmptyList(Name("conc"))))))),"default")))),TargetLanguageToCode(TL(";\n    Term s2 = ",TextPosition(51,75),TextPosition(52,15))),BQTermToCode(Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"f\""))),Composite(CompositeBQTerm(BuildConsList(Name("conc"),Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"a\""))),Composite(CompositeBQTerm(BuildEmptyList(Name("conc"))))),"default"))),BuildConsList(Name("conc"),Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"g\""))),Composite(CompositeBQTerm(BuildConsList(Name("conc"),Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"b\""))),Composite(CompositeBQTerm(BuildEmptyList(Name("conc"))))),"default"))),BuildEmptyList(Name("conc")))))),"default"))),BuildEmptyList(Name("conc"))))))),"default")))),TargetLanguageToCode(TL(";\n\n    Term p3 = ",TextPosition(52,81),TextPosition(54,15))),BQTermToCode(Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"f\""))),Composite(CompositeBQTerm(BuildConsList(Name("conc"),Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"a\""))),Composite(CompositeBQTerm(BuildEmptyList(Name("conc"))))),"default"))),BuildConsList(Name("conc"),Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"g\""))),Composite(CompositeBQTerm(BuildConsList(Name("conc"),Composite(CompositeBQTerm(BuildTerm(Name("Variable"),concBQTerm(Composite(CompositeTL(ITL("\"y\"")))),"default"))),BuildEmptyList(Name("conc")))))),"default"))),BuildEmptyList(Name("conc"))))))),"default")))),TargetLanguageToCode(TL(";\n    Term s3 = ",TextPosition(54,78),TextPosition(55,15))),BQTermToCode(Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"f\""))),Composite(CompositeBQTerm(BuildConsList(Name("conc"),Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"a\""))),Composite(CompositeBQTerm(BuildEmptyList(Name("conc"))))),"default"))),BuildConsList(Name("conc"),Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"g\""))),Composite(CompositeBQTerm(BuildConsList(Name("conc"),Composite(CompositeBQTerm(BuildTerm(Name("Appl"),concBQTerm(Composite(CompositeTL(ITL("\"b\""))),Composite(CompositeBQTerm(BuildEmptyList(Name("conc"))))),"default"))),BuildEmptyList(Name("conc")))))),"default"))),BuildEmptyList(Name("conc"))))))),"default")))),TargetLanguageToCode(TL(";\n\n    System.out.println(\"running...\");\n    System.out.println(\"p1 = \" + p1);\n    System.out.println(\"s1 = \" + s1);\n    System.out.println(\"match(p1,s1) = \" + ",TextPosition(55,81),TextPosition(60,44))),BQTermToCode(Composite(CompositeBQTerm(BuildTerm(Name("Match"),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("p1"),60,"Matching2.t"),ModuleName("default")),Name("p1"),Type("unknown type",EmptyType())))),Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("s1"),60,"Matching2.t"),ModuleName("default")),Name("s1"),Type("unknown type",EmptyType()))))),"default")))),TargetLanguageToCode(TL(");\n    System.out.println(\"p2 = \" + p2);\n    System.out.println(\"s2 = \" + s2);\n    System.out.println(\"match(p2,s2) = \" + ",TextPosition(60,57),TextPosition(63,44))),BQTermToCode(Composite(CompositeBQTerm(BuildTerm(Name("Match"),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("p2"),63,"Matching2.t"),ModuleName("default")),Name("p2"),Type("unknown type",EmptyType())))),Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("s2"),63,"Matching2.t"),ModuleName("default")),Name("s2"),Type("unknown type",EmptyType()))))),"default")))),TargetLanguageToCode(TL(");\n    System.out.println(\"match(p3,s3) = \" + ",TextPosition(63,57),TextPosition(64,44))),BQTermToCode(Composite(CompositeBQTerm(BuildTerm(Name("Match"),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("p3"),64,"Matching2.t"),ModuleName("default")),Name("p3"),Type("unknown type",EmptyType())))),Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("s3"),64,"Matching2.t"),ModuleName("default")),Name("s3"),Type("unknown type",EmptyType()))))),"default")))),TargetLanguageToCode(TL(");\n  }\n\n}\n\n",TextPosition(64,57),TextPosition(69,1)))))
NewTyper : newtyper = false
