
%include { string.tom }

%include { int.tom }

%typeterm Pattern {
  implement { lambda.types.Pattern }
  is_sort(t) { ($t instanceof lambda.types.Pattern) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm Fixpoint {
  implement { lambda.types.Fixpoint }
  is_sort(t) { ($t instanceof lambda.types.Fixpoint) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm Rules {
  implement { lambda.types.Rules }
  is_sort(t) { ($t instanceof lambda.types.Rules) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm RawClause {
  implement { lambda.types.RawClause }
  is_sort(t) { ($t instanceof lambda.types.RawClause) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm RawPatternList {
  implement { lambda.types.RawPatternList }
  is_sort(t) { ($t instanceof lambda.types.RawPatternList) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm RawLTermList {
  implement { lambda.types.RawLTermList }
  is_sort(t) { ($t instanceof lambda.types.RawLTermList) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm LTermList {
  implement { lambda.types.LTermList }
  is_sort(t) { ($t instanceof lambda.types.LTermList) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm Lam {
  implement { lambda.types.Lam }
  is_sort(t) { ($t instanceof lambda.types.Lam) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm RawFixpoint {
  implement { lambda.types.RawFixpoint }
  is_sort(t) { ($t instanceof lambda.types.RawFixpoint) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm RawLetin {
  implement { lambda.types.RawLetin }
  is_sort(t) { ($t instanceof lambda.types.RawLetin) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm PatternList {
  implement { lambda.types.PatternList }
  is_sort(t) { ($t instanceof lambda.types.PatternList) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm RawLTerm {
  implement { lambda.types.RawLTerm }
  is_sort(t) { ($t instanceof lambda.types.RawLTerm) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm LVar {
  implement { lambda.types.LVar }
  is_sort(t) { ($t instanceof lambda.types.LVar) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm Letin {
  implement { lambda.types.Letin }
  is_sort(t) { ($t instanceof lambda.types.Letin) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm RawRules {
  implement { lambda.types.RawRules }
  is_sort(t) { ($t instanceof lambda.types.RawRules) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm RawLam {
  implement { lambda.types.RawLam }
  is_sort(t) { ($t instanceof lambda.types.RawLam) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm Clause {
  implement { lambda.types.Clause }
  is_sort(t) { ($t instanceof lambda.types.Clause) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm LTerm {
  implement { lambda.types.LTerm }
  is_sort(t) { ($t instanceof lambda.types.LTerm) }

  equals(t1,t2) { ($t1==$t2) }

}

%typeterm RawPattern {
  implement { lambda.types.RawPattern }
  is_sort(t) { ($t instanceof lambda.types.RawPattern) }

  equals(t1,t2) { ($t1==$t2) }

}
%op Pattern PFun(f:String, children:PatternList) {
  is_fsym(t) { ($t instanceof lambda.types.pattern.PFun) }
  get_slot(f, t) { $t.getf() }
  get_slot(children, t) { $t.getchildren() }
  make(t0, t1) { lambda.types.pattern.PFun.make($t0, $t1) }
}

%op Pattern PVar(x:LVar) {
  is_fsym(t) { ($t instanceof lambda.types.pattern.PVar) }
  get_slot(x, t) { $t.getx() }
  make(t0) { lambda.types.pattern.PVar.make($t0) }
}

%op Fixpoint fixpoint(x:LVar, t:LTerm) {
  is_fsym(t) { ($t instanceof lambda.types.fixpoint.fixpoint) }
  get_slot(x, t) { $t.getx() }
  get_slot(t, t) { $t.gett() }
  make(t0, t1) { lambda.types.fixpoint.fixpoint.make($t0, $t1) }
}

%op Rules EmptyRList() {
  is_fsym(t) { ($t instanceof lambda.types.rules.EmptyRList) }
  make() { lambda.types.rules.EmptyRList.make() }
}

%op Rules ConsRList(HeadRList:Clause, TailRList:Rules) {
  is_fsym(t) { ($t instanceof lambda.types.rules.ConsRList) }
  get_slot(HeadRList, t) { $t.getHeadRList().refresh() }
  get_slot(TailRList, t) { $t.getTailRList() }
  make(t0, t1) { lambda.types.rules.ConsRList.make($t0, $t1) }
}

%op RawClause RawRule(p:RawPattern, t:RawLTerm) {
  is_fsym(t) { ($t instanceof lambda.types.rawclause.RawRule) }
  get_slot(p, t) { $t.getp() }
  get_slot(t, t) { $t.gett() }
  make(t0, t1) { lambda.types.rawclause.RawRule.make($t0, $t1) }
}

%op RawPatternList EmptyRawPList() {
  is_fsym(t) { ($t instanceof lambda.types.rawpatternlist.EmptyRawPList) }
  make() { lambda.types.rawpatternlist.EmptyRawPList.make() }
}

%op RawPatternList ConsRawPList(HeadRawPList:RawPattern, TailRawPList:RawPatternList) {
  is_fsym(t) { ($t instanceof lambda.types.rawpatternlist.ConsRawPList) }
  get_slot(HeadRawPList, t) { $t.getHeadRawPList() }
  get_slot(TailRawPList, t) { $t.getTailRawPList() }
  make(t0, t1) { lambda.types.rawpatternlist.ConsRawPList.make($t0, $t1) }
}

%op RawLTermList EmptyRawLTList() {
  is_fsym(t) { ($t instanceof lambda.types.rawltermlist.EmptyRawLTList) }
  make() { lambda.types.rawltermlist.EmptyRawLTList.make() }
}

%op RawLTermList ConsRawLTList(HeadRawLTList:RawLTerm, TailRawLTList:RawLTermList) {
  is_fsym(t) { ($t instanceof lambda.types.rawltermlist.ConsRawLTList) }
  get_slot(HeadRawLTList, t) { $t.getHeadRawLTList() }
  get_slot(TailRawLTList, t) { $t.getTailRawLTList() }
  make(t0, t1) { lambda.types.rawltermlist.ConsRawLTList.make($t0, $t1) }
}

%op LTermList EmptyLTList() {
  is_fsym(t) { ($t instanceof lambda.types.ltermlist.EmptyLTList) }
  make() { lambda.types.ltermlist.EmptyLTList.make() }
}

%op LTermList ConsLTList(HeadLTList:LTerm, TailLTList:LTermList) {
  is_fsym(t) { ($t instanceof lambda.types.ltermlist.ConsLTList) }
  get_slot(HeadLTList, t) { $t.getHeadLTList() }
  get_slot(TailLTList, t) { $t.getTailLTList() }
  make(t0, t1) { lambda.types.ltermlist.ConsLTList.make($t0, $t1) }
}

%op Lam lam(x:LVar, t:LTerm) {
  is_fsym(t) { ($t instanceof lambda.types.lam.lam) }
  get_slot(x, t) { $t.getx() }
  get_slot(t, t) { $t.gett() }
  make(t0, t1) { lambda.types.lam.lam.make($t0, $t1) }
}

%op RawFixpoint Rawfixpoint(x:String, t:RawLTerm) {
  is_fsym(t) { ($t instanceof lambda.types.rawfixpoint.Rawfixpoint) }
  get_slot(x, t) { $t.getx() }
  get_slot(t, t) { $t.gett() }
  make(t0, t1) { lambda.types.rawfixpoint.Rawfixpoint.make($t0, $t1) }
}

%op RawLetin Rawletin(x:String, u:RawLTerm, t:RawLTerm) {
  is_fsym(t) { ($t instanceof lambda.types.rawletin.Rawletin) }
  get_slot(x, t) { $t.getx() }
  get_slot(u, t) { $t.getu() }
  get_slot(t, t) { $t.gett() }
  make(t0, t1, t2) { lambda.types.rawletin.Rawletin.make($t0, $t1, $t2) }
}

%op PatternList EmptyPList() {
  is_fsym(t) { ($t instanceof lambda.types.patternlist.EmptyPList) }
  make() { lambda.types.patternlist.EmptyPList.make() }
}

%op PatternList ConsPList(HeadPList:Pattern, TailPList:PatternList) {
  is_fsym(t) { ($t instanceof lambda.types.patternlist.ConsPList) }
  get_slot(HeadPList, t) { $t.getHeadPList() }
  get_slot(TailPList, t) { $t.getTailPList() }
  make(t0, t1) { lambda.types.patternlist.ConsPList.make($t0, $t1) }
}

%op RawLTerm RawApp(t1:RawLTerm, t2:RawLTerm) {
  is_fsym(t) { ($t instanceof lambda.types.rawlterm.RawApp) }
  get_slot(t1, t) { $t.gett1() }
  get_slot(t2, t) { $t.gett2() }
  make(t0, t1) { lambda.types.rawlterm.RawApp.make($t0, $t1) }
}

%op RawLTerm RawAbs(a:RawLam) {
  is_fsym(t) { ($t instanceof lambda.types.rawlterm.RawAbs) }
  get_slot(a, t) { $t.geta() }
  make(t0) { lambda.types.rawlterm.RawAbs.make($t0) }
}

%op RawLTerm RawLet(b:RawLetin) {
  is_fsym(t) { ($t instanceof lambda.types.rawlterm.RawLet) }
  get_slot(b, t) { $t.getb() }
  make(t0) { lambda.types.rawlterm.RawLet.make($t0) }
}

%op RawLTerm RawFix(c:RawFixpoint) {
  is_fsym(t) { ($t instanceof lambda.types.rawlterm.RawFix) }
  get_slot(c, t) { $t.getc() }
  make(t0) { lambda.types.rawlterm.RawFix.make($t0) }
}

%op RawLTerm RawVar(x:String) {
  is_fsym(t) { ($t instanceof lambda.types.rawlterm.RawVar) }
  get_slot(x, t) { $t.getx() }
  make(t0) { lambda.types.rawlterm.RawVar.make($t0) }
}

%op RawLTerm RawConstr(f:String, children:RawLTermList) {
  is_fsym(t) { ($t instanceof lambda.types.rawlterm.RawConstr) }
  get_slot(f, t) { $t.getf() }
  get_slot(children, t) { $t.getchildren() }
  make(t0, t1) { lambda.types.rawlterm.RawConstr.make($t0, $t1) }
}

%op RawLTerm RawCase(subject:RawLTerm, rules:RawRules) {
  is_fsym(t) { ($t instanceof lambda.types.rawlterm.RawCase) }
  get_slot(subject, t) { $t.getsubject() }
  get_slot(rules, t) { $t.getrules() }
  make(t0, t1) { lambda.types.rawlterm.RawCase.make($t0, $t1) }
}

%op LVar LVar(n:int, hint:String) {
  is_fsym(t) { ($t instanceof lambda.types.lvar.LVar) }
  get_slot(n, t) { $t.getn() }
  get_slot(hint, t) { $t.gethint() }
  make(t0, t1) { lambda.types.lvar.LVar.make($t0, $t1) }
}

%op Letin letin(x:LVar, u:LTerm, t:LTerm) {
  is_fsym(t) { ($t instanceof lambda.types.letin.letin) }
  get_slot(x, t) { $t.getx() }
  get_slot(u, t) { $t.getu() }
  get_slot(t, t) { $t.gett() }
  make(t0, t1, t2) { lambda.types.letin.letin.make($t0, $t1, $t2) }
}

%op RawRules EmptyRawRList() {
  is_fsym(t) { ($t instanceof lambda.types.rawrules.EmptyRawRList) }
  make() { lambda.types.rawrules.EmptyRawRList.make() }
}

%op RawRules ConsRawRList(HeadRawRList:RawClause, TailRawRList:RawRules) {
  is_fsym(t) { ($t instanceof lambda.types.rawrules.ConsRawRList) }
  get_slot(HeadRawRList, t) { $t.getHeadRawRList() }
  get_slot(TailRawRList, t) { $t.getTailRawRList() }
  make(t0, t1) { lambda.types.rawrules.ConsRawRList.make($t0, $t1) }
}

%op RawLam Rawlam(x:String, t:RawLTerm) {
  is_fsym(t) { ($t instanceof lambda.types.rawlam.Rawlam) }
  get_slot(x, t) { $t.getx() }
  get_slot(t, t) { $t.gett() }
  make(t0, t1) { lambda.types.rawlam.Rawlam.make($t0, $t1) }
}

%op Clause Rule(p:Pattern, t:LTerm) {
  is_fsym(t) { ($t instanceof lambda.types.clause.Rule) }
  get_slot(p, t) { $t.getp() }
  get_slot(t, t) { $t.gett() }
  make(t0, t1) { lambda.types.clause.Rule.make($t0, $t1) }
}

%op LTerm App(t1:LTerm, t2:LTerm) {
  is_fsym(t) { ($t instanceof lambda.types.lterm.App) }
  get_slot(t1, t) { $t.gett1() }
  get_slot(t2, t) { $t.gett2() }
  make(t0, t1) { lambda.types.lterm.App.make($t0, $t1) }
}

%op LTerm Abs(a:Lam) {
  is_fsym(t) { ($t instanceof lambda.types.lterm.Abs) }
  get_slot(a, t) { $t.geta().refresh() }
  make(t0) { lambda.types.lterm.Abs.make($t0) }
}

%op LTerm Let(b:Letin) {
  is_fsym(t) { ($t instanceof lambda.types.lterm.Let) }
  get_slot(b, t) { $t.getb().refresh() }
  make(t0) { lambda.types.lterm.Let.make($t0) }
}

%op LTerm Fix(c:Fixpoint) {
  is_fsym(t) { ($t instanceof lambda.types.lterm.Fix) }
  get_slot(c, t) { $t.getc().refresh() }
  make(t0) { lambda.types.lterm.Fix.make($t0) }
}

%op LTerm Var(x:LVar) {
  is_fsym(t) { ($t instanceof lambda.types.lterm.Var) }
  get_slot(x, t) { $t.getx() }
  make(t0) { lambda.types.lterm.Var.make($t0) }
}

%op LTerm Constr(f:String, children:LTermList) {
  is_fsym(t) { ($t instanceof lambda.types.lterm.Constr) }
  get_slot(f, t) { $t.getf() }
  get_slot(children, t) { $t.getchildren() }
  make(t0, t1) { lambda.types.lterm.Constr.make($t0, $t1) }
}

%op LTerm Case(subject:LTerm, rules:Rules) {
  is_fsym(t) { ($t instanceof lambda.types.lterm.Case) }
  get_slot(subject, t) { $t.getsubject() }
  get_slot(rules, t) { $t.getrules() }
  make(t0, t1) { lambda.types.lterm.Case.make($t0, $t1) }
}

%op RawPattern RawPFun(f:String, children:RawPatternList) {
  is_fsym(t) { ($t instanceof lambda.types.rawpattern.RawPFun) }
  get_slot(f, t) { $t.getf() }
  get_slot(children, t) { $t.getchildren() }
  make(t0, t1) { lambda.types.rawpattern.RawPFun.make($t0, $t1) }
}

%op RawPattern RawPVar(x:String) {
  is_fsym(t) { ($t instanceof lambda.types.rawpattern.RawPVar) }
  get_slot(x, t) { $t.getx() }
  make(t0) { lambda.types.rawpattern.RawPVar.make($t0) }
}


%oplist Rules RList(Clause*) {
  is_fsym(t) { (($t instanceof lambda.types.rules.ConsRList) || ($t instanceof lambda.types.rules.EmptyRList)) }
  make_empty() { lambda.types.rules.EmptyRList.make() }
  make_insert(e,l) { lambda.types.rules.ConsRList.make($e,$l) }
  get_head(l) { $l.getHeadRList().refresh() }
  get_tail(l) { $l.getTailRList() }
  is_empty(l) { $l.isEmptyRList() }
}

%oplist RawPatternList RawPList(RawPattern*) {
  is_fsym(t) { (($t instanceof lambda.types.rawpatternlist.ConsRawPList) || ($t instanceof lambda.types.rawpatternlist.EmptyRawPList)) }
  make_empty() { lambda.types.rawpatternlist.EmptyRawPList.make() }
  make_insert(e,l) { lambda.types.rawpatternlist.ConsRawPList.make($e,$l) }
  get_head(l) { $l.getHeadRawPList() }
  get_tail(l) { $l.getTailRawPList() }
  is_empty(l) { $l.isEmptyRawPList() }
}

%oplist RawLTermList RawLTList(RawLTerm*) {
  is_fsym(t) { (($t instanceof lambda.types.rawltermlist.ConsRawLTList) || ($t instanceof lambda.types.rawltermlist.EmptyRawLTList)) }
  make_empty() { lambda.types.rawltermlist.EmptyRawLTList.make() }
  make_insert(e,l) { lambda.types.rawltermlist.ConsRawLTList.make($e,$l) }
  get_head(l) { $l.getHeadRawLTList() }
  get_tail(l) { $l.getTailRawLTList() }
  is_empty(l) { $l.isEmptyRawLTList() }
}

%oplist LTermList LTList(LTerm*) {
  is_fsym(t) { (($t instanceof lambda.types.ltermlist.ConsLTList) || ($t instanceof lambda.types.ltermlist.EmptyLTList)) }
  make_empty() { lambda.types.ltermlist.EmptyLTList.make() }
  make_insert(e,l) { lambda.types.ltermlist.ConsLTList.make($e,$l) }
  get_head(l) { $l.getHeadLTList() }
  get_tail(l) { $l.getTailLTList() }
  is_empty(l) { $l.isEmptyLTList() }
}

%oplist PatternList PList(Pattern*) {
  is_fsym(t) { (($t instanceof lambda.types.patternlist.ConsPList) || ($t instanceof lambda.types.patternlist.EmptyPList)) }
  make_empty() { lambda.types.patternlist.EmptyPList.make() }
  make_insert(e,l) { lambda.types.patternlist.ConsPList.make($e,$l) }
  get_head(l) { $l.getHeadPList() }
  get_tail(l) { $l.getTailPList() }
  is_empty(l) { $l.isEmptyPList() }
}

%oplist RawRules RawRList(RawClause*) {
  is_fsym(t) { (($t instanceof lambda.types.rawrules.ConsRawRList) || ($t instanceof lambda.types.rawrules.EmptyRawRList)) }
  make_empty() { lambda.types.rawrules.EmptyRawRList.make() }
  make_insert(e,l) { lambda.types.rawrules.ConsRawRList.make($e,$l) }
  get_head(l) { $l.getHeadRawRList() }
  get_tail(l) { $l.getTailRawRList() }
  is_empty(l) { $l.isEmptyRawRList() }
}
