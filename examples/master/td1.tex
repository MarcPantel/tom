\documentclass[11pt]{article}
\usepackage[latin1]{inputenc}
%% \usepackage{fullpage}
\usepackage{color}
\usepackage{aeguill}
\usepackage{comment}

%% \textwidth=5.5in
\textheight=8in

%% \includecomment{versionProf}
\specialcomment{versionProf}
    {\begingroup\bf}{\endgroup}

%% UNCOMMENT IF YOU WANT THE SHORT VERSION
\excludecomment{versionProf}

\title{Termes, réécriture, filtrage syntaxique}
%\date{2005-2006}
%\author{M1}


\begin{document}

%% \thispagestyle{empty}
%% \centerline{\LARGE\textbf{Termes, réécriture, filtrage syntaxique}}
%% \bigskip
%% \bigskip
\maketitle

Ce premier TD a pour but de vous familiariser la réécriture sur les
termes et avec la notion sous-jacente de filtrage. Nous abordons dans
ce TD seulement le filtrage syntaxique.

\section{Arithmétique  de Peano}

On souhaite écrire le système de réécriture permettant de calculer la
somme d'entiers de Peano. \\
\textit{Rappel}: L'entier $n$ est représenté par le terme
suc(suc(...(suc($0$)))) avec $n$ occurrences de «suc» et la somme est
calculée en utilisant les définitions suivantes:
%
\begin{itemize}
\item[] x + zero = x
\item[] x + suc(y) = suc(x + y)
\item[] x * zero = zero 
\item[] x * suc(y) = x + (x*y)
\end{itemize}

En utilisant le système obtenu calculer les sommes $2+2$ et $1+1+1+1$. 

\begin{versionProf}
\begin{verbatim}
x + zero -> x
x + suc(y) -> suc(x + y)
x * zero -> zero 
x * suc(y) -> x + (x*y)

Start = plus(suc(suc(zero)),suc(suc(zero))) 
Step = suc(plus(suc(suc(zero)),suc(zero)))
Step = suc(suc(plus(suc(suc(zero)),zero)))
Step = suc(suc(suc(suc(zero))))
Step = suc(suc(suc(suc(zero))))

Start = plus(plus(suc(zero),suc(zero)),plus(suc(zero),suc(zero)))
Step = plus(plus(suc(zero),suc(zero)),suc(plus(suc(zero),zero)))
Step = suc(plus(plus(suc(zero),suc(zero)),plus(suc(zero),zero)))
Step = suc(plus(plus(suc(zero),suc(zero)),suc(zero)))
Step = suc(suc(plus(plus(suc(zero),suc(zero)),zero)))
Step = suc(suc(plus(suc(zero),suc(zero))))
Step = suc(suc(suc(plus(suc(zero),zero))))
Step = suc(suc(suc(suc(zero))))
Step = suc(suc(suc(suc(zero))))

Start = plus(suc(zero),plus(suc(zero),plus(suc(zero),suc(zero))))
Step = plus(suc(zero),plus(suc(zero),suc(plus(suc(zero),zero))))
Step = plus(suc(zero),suc(plus(suc(zero),plus(suc(zero),zero))))
Step = suc(plus(suc(zero),plus(suc(zero),plus(suc(zero),zero))))
Step = suc(plus(suc(zero),plus(suc(zero),suc(zero))))
Step = suc(plus(suc(zero),suc(plus(suc(zero),zero))))
Step = suc(suc(plus(suc(zero),plus(suc(zero),zero))))
Step = suc(suc(plus(suc(zero),suc(zero))))
Step = suc(suc(suc(plus(suc(zero),zero))))
Step = suc(suc(suc(suc(zero))))
Step = suc(suc(suc(suc(zero))))

\end{verbatim}
\end{versionProf}

\section{Fibonacci}

On souhaite écrire le système de réécriture permettant de calculer la
suite de Fibonacci:
\begin{itemize}
\item[] fib(0) = 1
\item[] fib(1) = 1
\item[] fib(n) = fib(n-1)+fib(n-2)
\end{itemize}

\begin{versionProf}
Il faut utiliser la réécriture conditionnelle: 
\begin{verbatim}
fib(0) -> 1
fib(1) -> 1
fib(n) -> fib(n-1)+fib(n-2)     if n>1
\end{verbatim}
\end{versionProf}


\section{Polynômes}

On considère des polynômes à une variable avec de coefficients entiers
naturels (par exemple, $2X^3+4X^2+5X+1$) et on souhaite calculer leur
dérivée par rapport à $X$.

\subsection{Dérivée}
On souhaite écrire le système de réécriture permettant de calculer la
dérivée de tout polynôme en sachant que:
\begin{itemize}
\item[] $deriv(n,X) = 0$
\item[] $deriv(m*X^n,X) = m*n*X^{n-1}$
\item[] $deriv(P1+P2,X) = deriv(P1,X) + deriv(P2,X)$
\item[] $deriv(P1*P2,X) = deriv(P1,X) * P2 + deriv(P2,X) * P1$
\end{itemize}

Montrer les étapes de réduction pour obtenir la dérivée des polynômes
$3*X^2+X+7$ et $5*X^2+3*X+4$ ainsi que de leur somme.

\begin{versionProf}
\begin{itemize}
\item[] $deriv(n,X) -> 0$
\item[] $deriv(mX^n,X) -> mnX^{n-1}$
\item[] $deriv(P1+P2,X) -> deriv(P1,X) + deriv(P2,X)$
\item[] $deriv(P1*P2,X) -> deriv(P1,X) * P2 + deriv(P2,X) * P1$
\end{itemize}

$6*X+1 + 10*X+3$
\end{versionProf}


\subsection{Simplification}

Le résultat obtenu à la question précédente n'est pas en forme
canonique; c.a.d. un seul monôme pour chaque puissance de $X$ et les
monômes triés par ordre décroissant.

Proposez un système de réécriture permettant de résoudre ce
problème. Appliquez-le au résultat obtenu précédemment.

\begin{versionProf}
\begin{itemize}
\item[] $simplify(m_1 X^n + m_2 X^n) -> (m_1+m_2) X^n$
\item[] $simplify(m_1 X^{n_1} + m_2 X^{n_2}) -> m_2 X^{n_2} + m_1 X^{n_1}$
  ~~~~~~if $n_1 < n_2$

\item[] $simplify(m_1 X^n + (m_2 X^n + P)) -> (m_1+m_2) X^n + P$
\item[] $simplify(m_1 X^{n_1} + (m_2 X^{n_2} + P)) -> 
  m_2 X^{n_2} + (m_1 X^{n_1} + P)$
  ~~~~~~if $n_1 < n_2$

\item[] $simplify((P_1 + P_2) + P_3) -> P_1 + (P_2 + P_3) X^n$
\end{itemize}
\end{versionProf}

%% \subsection{Multiplication}



\section{Filtrage syntaxique}

\begin{enumerate}
\item
On considère des problèmes de filtrage linéaires syntaxique sur les
entiers de Peano. On souhaite écrire le système de réécriture
permettant de résoudre ces problèmes.

Par exemple, le résultat du problème $(x+0)+(y+0) \ll (0+0)+(0+0)$
doit être $x\ll 0 \wedge y\ll 0$ et  $(x+0)+(y+0) \ll (0+0)+(0+1)$
doit être réduit a $False$.

\begin{versionProf}
\begin{verbatim}
    // Delete
    Match(zero(),zero()) -> True()
      
    // Decompose
      Match(suc(x),suc(y)) -> Match(x,y)
      Match(plus(x1,x2),plus(y1,y2)) -> And(Match(x1,y1),Match(x2,y2))
        
    // SymbolClash
      Match(suc(_),zero()) -> False() 
      Match(zero(),suc(_)) -> False() 
      Match(plus(_,_),zero()) -> False() 
      Match(zero(),plus(_,_)) -> False() 
      Match(suc(_),plus(_,_)) -> False() 
      Match(plus(_,_),suc(_)) -> False() 

    // PropagateClash
    And(False(),_) -> False()
    And(_,False()) -> False()

    // PropagateSuccess
      And(True(),X) -> X
      And(X,True()) -> X

    // Merging
    And(X,X) -> X
\end{verbatim}

\begin{verbatim}
Match(plus(plus(var("x"),zero),plus(var("x"),zero)),
      plus(plus(zero,zero),plus(zero,zero)))
= 
And(Match(var("x"),zero),True)

Match(plus(plus(var("x"),zero),plus(var("y"),zero)),
      plus(plus(zero,zero),plus(zero,zero)))
= 
And(And(Match(var("x"),zero),True),And(Match(var("y"),zero),True))
\end{verbatim}
si on oublie la Com pour Propagate

\begin{verbatim}
Match(plus(plus(var("x"),zero),plus(var("x"),zero)),
      plus(plus(zero,zero),plus(zero,zero)))
= 
Match(var("x")e,zero)

Match(plus(plus(var("x"),zero),plus(var("y"),zero)),
      plus(plus(zero,zero),plus(zero,zero)))
= 
And(Match(var("x"),zero),Match(var("y"),zero))
\end{verbatim}
\end{versionProf}

\item
On souhaite généraliser le système de réécriture obtenu afin de
résoudre des problèmes de filtrage non-linéaires.

Par exemple, le résultat du problème $(x+y)+(z+x) \ll (0+0)+(0+0)$
doit être $x\ll 0 \wedge y\ll 0 \wedge z\ll 0$ et $(x+y)+(y+x) \ll
(0+0)+(0+1)$ doit être réduit a $False$.

\begin{versionProf}
\begin{verbatim}
    // Delete
      Match(zero(),zero()) -> True()
      
    // Decompose
      Match(suc(x),suc(y)) -> Match(x,y)
      Match(plus(x1,x2),plus(y1,y2)) -> And(Match(x1,y1),Match(x2,y2))
        
    // SymbolClash
      Match(suc(_),zero()) -> False() 
      Match(zero(),suc(_)) -> False() 
      Match(plus(_,_),zero()) -> False() 
      Match(zero(),plus(_,_)) -> False() 
      Match(suc(_),plus(_,_)) -> False() 
      Match(plus(_,_),suc(_)) -> False() 

    // PropagateClash
      And(False(),_) -> False()
      And(_,False()) -> False()

    // PropagateSuccess
      And(True(),X) -> X
      And(X,True()) -> X

    // Merging
      And(X,X) -> X
      And(X,And(X,Y)) ->  And(X,Y)

    // MergingFail
      And(Match(var(x),X),Match(var(x),Y)) -> False() 
        if(X!=Y)
      And(Match(var(x),X),And(Match(var(x),Y),P)) -> False() 
        if(X!=Y)

    // Sort
      And(Match(var(x),X),Match(var(y),Y)) -> 
         And(Match(var(y),Y),Match(var(x),X)) ;
            if(x.compareTo(y)<0){
      And(Match(var(x),X),And(Match(var(y),Y),P)) -> 
         And(Match(var(y),Y),And(Match(var(x),X),P)) 
            if(x.compareTo(y)<0)
    
    // Assoc
      And(And(p1,p2),p3) -> And(p1, And(p2,p3))

    // congruence
      And(p1,p2) -> And(solve(p1),solve(p2))
\end{verbatim}
\end{versionProf}
\end{enumerate}

\end{document}
