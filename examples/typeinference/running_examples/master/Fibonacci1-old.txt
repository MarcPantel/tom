TyperPlugin : newtyper = false

Code after type inference = 
Tom(concCode(TargetLanguageToCode(TL("\npackage master.fibonacci1.peano.types.nat;\n\n\n\npublic final class plus extends master.fibonacci1.peano.types.Nat implements tom.library.sl.Visitable  {\n  \n  private static String symbolName = \"plus\";\n\n\n  private plus() {}\n  private int hashCode;\n  private static plus proto = new plus();\n  \n",TextPosition(1,1),TextPosition(15,1))),TomInclude(concCode(DeclarationToCode(TypeTermDecl(Name("int"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),Name("t1"),Type("int",TLType(" int "))),BQVariable(concOption(OriginTracking(Name("t2"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),Name("t2"),Type("int",TLType(" int "))),Code(" {0}=={1} "),OriginTracking(Name("equals"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),31,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),Name("t"),Type("int",TLType(" int "))),Code(" true "),OriginTracking(Name("is_sort"),31,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom"))),OriginTracking(Name("int"),29,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom"))),TargetLanguageToCode(TL("\n",TextPosition(33,1),TextPosition(34,1))))),DeclarationToCode(TypeTermDecl(Name("Nat"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t")),Name("t1"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))),BQVariable(concOption(OriginTracking(Name("t2"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t")),Name("t2"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))),Code(" ({0}=={1}) "),OriginTracking(Name("equals"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),19,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t")),Name("t"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))),Code(" ({0} instanceof master.fibonacci1.peano.types.Nat) "),OriginTracking(Name("is_sort"),19,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t"))),OriginTracking(Name("Nat"),17,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t"))),DeclarationToCode(SymbolDecl(Name("zero"))),DeclarationToCode(SymbolDecl(Name("suc"))),DeclarationToCode(SymbolDecl(Name("plus"))),DeclarationToCode(SymbolDecl(Name("mult"))),DeclarationToCode(SymbolDecl(Name("fib"))),TargetLanguageToCode(TL("\n\n  private master.fibonacci1.peano.types.Nat _x1;\n  private master.fibonacci1.peano.types.Nat _x2;\n\n  /**\n   * Constructor that builds a term rooted by plus\n   *\n   * @return a term rooted by plus\n   */\n\n    public static master.fibonacci1.peano.types.Nat make(master.fibonacci1.peano.types.Nat arg_1, master.fibonacci1.peano.types.Nat arg_2) {\n  if (true) {    ",TextPosition(53,1),TextPosition(65,18))),InstructionToCode(Match(concConstraintInstruction(ConstraintInstruction(AndConstraint(MatchConstraint(Variable(concOption(OriginTracking(Name("x"),66,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t")),Name("x"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_1"),65,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t")),Name("arg_1"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")))),MatchConstraint(RecordAppl(concOption(OriginTracking(Name("zero"),66,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t")),concTomName(Name("zero")),concSlot(),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_2"),65,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t")),Name("arg_2"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(66,14),TextPosition(66,23)))),BQTermToInstruction(BQVariable(concOption(OriginTracking(Name("x"),66,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t"),ModuleName("default")),Name("x"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(66,26),TextPosition(66,27))))))),concOption(OriginalText(Name("")))),ConstraintInstruction(AndConstraint(MatchConstraint(Variable(concOption(OriginTracking(Name("x"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t")),Name("x"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_1"),65,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t")),Name("arg_1"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")))),MatchConstraint(RecordAppl(concOption(OriginTracking(Name("suc"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t")),concTomName(Name("suc")),concSlot(PairSlotAppl(Name("pred"),Variable(concOption(OriginTracking(Name("y"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t")),Name("y"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")),concConstraint()))),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_2"),65,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t")),Name("arg_2"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(67,14),TextPosition(67,23)))),BQTermToInstruction(Composite(CompositeBQTerm(BuildTerm(Name("suc"),concBQTerm(Composite(CompositeBQTerm(BuildTerm(Name("plus"),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("x"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t"),ModuleName("default")),Name("x"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))))),Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("y"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t"),ModuleName("default")),Name("y"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")))))),"default")))),"default")))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(67,39),TextPosition(67,41))))))),concOption(OriginalText(Name(""))))),concOption(OriginTracking(Name("Match"),65,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp8322758977978800134.t"),ModuleName("default")))),TargetLanguageToCode(TL("\n}\n      return realMake( arg_1,  arg_2);\n    }\n  \n  private static plus realMake(master.fibonacci1.peano.types.Nat _x1, master.fibonacci1.peano.types.Nat _x2) {\n\n    // use the proto as a model\n    proto.initHashCode( _x1,  _x2);\n    return (plus) factory.build(proto);\n\n  }\n\n  /**\n   * Initializes attributes and hashcode of the class\n   *\n   * @param  _x1\n   * @param _x2\n   * @param hashCode hashCode of plus\n   */\n  private void init(master.fibonacci1.peano.types.Nat _x1, master.fibonacci1.peano.types.Nat _x2, int hashCode) {\n    this._x1 = _x1;\n    this._x2 = _x2;\n\n    this.hashCode = hashCode;\n  }\n\n  /**\n   * Initializes attributes and hashcode of the class\n   *\n   * @param  _x1\n   * @param _x2\n   */\n  private void initHashCode(master.fibonacci1.peano.types.Nat _x1, master.fibonacci1.peano.types.Nat _x2) {\n    this._x1 = _x1;\n    this._x2 = _x2;\n\n    this.hashCode = hashFunction();\n  }\n\n  /* name and arity */\n\n  /**\n   * Returns the name of the symbol\n   *\n   * @return the name of the symbol\n   */\n  @Override\n  public String symbolName() {\n    return \"plus\";\n  }\n\n  /**\n   * Returns the arity of the symbol\n   *\n   * @return the arity of the symbol\n   */\n  private int getArity() {\n    return 2;\n  }\n\n  /**\n   * Copy the object and returns the copy\n   *\n   * @return a clone of the SharedObject\n   */\n  public shared.SharedObject duplicate() {\n    plus clone = new plus();\n    clone.init( _x1,  _x2, hashCode);\n    return clone;\n  }\n  \n  /**\n   * Appends a string representation of this term to the buffer given as argument.\n   *\n   * @param buffer the buffer to which a string represention of this term is appended.\n   */\n  @Override\n  public void toStringBuilder(java.lang.StringBuilder buffer) {\n    buffer.append(\"plus(\");\n    _x1.toStringBuilder(buffer);\nbuffer.append(\",\");\n    _x2.toStringBuilder(buffer);\n\n    buffer.append(\")\");\n  }\n\n\n  /**\n   * Compares two terms. This functions implements a total lexicographic path ordering.\n   *\n   * @param o object to which this term is compared\n   * @return a negative integer, zero, or a positive integer as this\n   *         term is less than, equal to, or greater than the argument\n   * @throws ClassCastException in case of invalid arguments\n   * @throws RuntimeException if unable to compare childs\n   */\n  @Override\n  public int compareToLPO(Object o) {\n    /*\n     * We do not want to compare with any object, only members of the module\n     * In case of invalid argument, throw a ClassCastException, as the java api\n     * asks for it\n     */\n    master.fibonacci1.peano.PeanoAbstractType ao = (master.fibonacci1.peano.PeanoAbstractType) o;\n    /* return 0 for equality */\n    if (ao == this) { return 0; }\n    /* compare the symbols */\n    int symbCmp = this.symbolName().compareTo(ao.symbolName());\n    if (symbCmp != 0) { return symbCmp; }\n    /* compare the childs */\n    plus tco = (plus) ao;\n    int _x1Cmp = (this._x1).compareToLPO(tco._x1);\n    if(_x1Cmp != 0)\n      return _x1Cmp;\n\n    int _x2Cmp = (this._x2).compareToLPO(tco._x2);\n    if(_x2Cmp != 0)\n      return _x2Cmp;\n\n    throw new RuntimeException(\"Unable to compare\");\n  }\n\n /**\n   * Compares two terms. This functions implements a total order.\n   *\n   * @param o object to which this term is compared\n   * @return a negative integer, zero, or a positive integer as this\n   *         term is less than, equal to, or greater than the argument\n   * @throws ClassCastException in case of invalid arguments\n   * @throws RuntimeException if unable to compare childs\n   */\n  @Override\n  public int compareTo(Object o) {\n    /*\n     * We do not want to compare with any object, only members of the module\n     * In case of invalid argument, throw a ClassCastException, as the java api\n     * asks for it\n     */\n    master.fibonacci1.peano.PeanoAbstractType ao = (master.fibonacci1.peano.PeanoAbstractType) o;\n    /* return 0 for equality */\n    if (ao == this) { return 0; }\n    /* use the hash values to discriminate */\n\n    if(hashCode != ao.hashCode()) { return (hashCode < ao.hashCode())?-1:1; }\n\n    /* If not, compare the symbols : back to the normal order */\n    int symbCmp = this.symbolName().compareTo(ao.symbolName());\n    if (symbCmp != 0) { return symbCmp; }\n    /* last resort: compare the childs */\n    plus tco = (plus) ao;\n    int _x1Cmp = (this._x1).compareTo(tco._x1);\n    if(_x1Cmp != 0)\n      return _x1Cmp;\n\n    int _x2Cmp = (this._x2).compareTo(tco._x2);\n    if(_x2Cmp != 0)\n      return _x2Cmp;\n\n    throw new RuntimeException(\"Unable to compare\");\n  }\n\n //shared.SharedObject\n  /**\n   * Returns hashCode\n   *\n   * @return hashCode\n   */\n  @Override\n  public final int hashCode() {\n    return hashCode;\n  }\n\n  /**\n   * Checks if a SharedObject is equivalent to the current object\n   *\n   * @param obj SharedObject to test\n   * @return true if obj is a plus and its members are equal, else false\n   */\n  public final boolean equivalent(shared.SharedObject obj) {\n    if(obj instanceof plus) {\n\n      plus peer = (plus) obj;\n      return _x1==peer._x1 && _x2==peer._x2 && true;\n    }\n    return false;\n  }\n\n\n   //Nat interface\n  /**\n   * Returns true if the term is rooted by the symbol plus\n   *\n   * @return true, because this is rooted by plus\n   */\n  @Override\n  public boolean isplus() {\n    return true;\n  }\n  \n  /**\n   * Returns the attribute master.fibonacci1.peano.types.Nat\n   *\n   * @return the attribute master.fibonacci1.peano.types.Nat\n   */\n  @Override\n  public master.fibonacci1.peano.types.Nat getx1() {\n    return _x1;\n  }\n\n  /**\n   * Sets and returns the attribute master.fibonacci1.peano.types.Nat\n   *\n   * @param set_arg the argument to set\n   * @return the attribute master.fibonacci1.peano.types.Nat which just has been set\n   */\n  @Override\n  public master.fibonacci1.peano.types.Nat setx1(master.fibonacci1.peano.types.Nat set_arg) {\n    return make(set_arg, _x2);\n  }\n  \n  /**\n   * Returns the attribute master.fibonacci1.peano.types.Nat\n   *\n   * @return the attribute master.fibonacci1.peano.types.Nat\n   */\n  @Override\n  public master.fibonacci1.peano.types.Nat getx2() {\n    return _x2;\n  }\n\n  /**\n   * Sets and returns the attribute master.fibonacci1.peano.types.Nat\n   *\n   * @param set_arg the argument to set\n   * @return the attribute master.fibonacci1.peano.types.Nat which just has been set\n   */\n  @Override\n  public master.fibonacci1.peano.types.Nat setx2(master.fibonacci1.peano.types.Nat set_arg) {\n    return make(_x1, set_arg);\n  }\n  \n  /* AbstractType */\n  /**\n   * Returns an ATerm representation of this term.\n   *\n   * @return an ATerm representation of this term.\n   */\n  @Override\n  public aterm.ATerm toATerm() {\n    aterm.ATerm res = super.toATerm();\n    if(res != null) {\n      // the super class has produced an ATerm (may be a variadic operator)\n      return res;\n    }\n    return atermFactory.makeAppl(\n      atermFactory.makeAFun(symbolName(),getArity(),false),\n      new aterm.ATerm[] {getx1().toATerm(), getx2().toATerm()});\n  }\n\n  /**\n   * Apply a conversion on the ATerm contained in the String and returns a master.fibonacci1.peano.types.Nat from it\n   *\n   * @param trm ATerm to convert into a Gom term\n   * @param atConv ATerm Converter used to convert the ATerm\n   * @return the Gom term\n   */\n  public static master.fibonacci1.peano.types.Nat fromTerm(aterm.ATerm trm, tom.library.utils.ATermConverter atConv) {\n    trm = atConv.convert(trm);\n    if(trm instanceof aterm.ATermAppl) {\n      aterm.ATermAppl appl = (aterm.ATermAppl) trm;\n      if(symbolName.equals(appl.getName()) && !appl.getAFun().isQuoted()) {\n        return make(\nmaster.fibonacci1.peano.types.Nat.fromTerm(appl.getArgument(0),atConv), master.fibonacci1.peano.types.Nat.fromTerm(appl.getArgument(1),atConv)\n        );\n      }\n    }\n    return null;\n  }\n\n  /* Visitable */\n  /**\n   * Returns the number of childs of the term\n   *\n   * @return the number of childs of the term\n   */\n  public int getChildCount() {\n    return 2;\n  }\n\n  /**\n   * Returns the child at the specified index\n   *\n   * @param index index of the child to return; must be\n             nonnegative and less than the childCount\n   * @return the child at the specified index\n   * @throws IndexOutOfBoundsException if the index out of range\n   */\n  public tom.library.sl.Visitable getChildAt(int index) {\n    switch(index) {\n      case 0: return _x1;\n      case 1: return _x2;\n\n      default: throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Set the child at the specified index\n   *\n   * @param index index of the child to set; must be\n             nonnegative and less than the childCount\n   * @param v child to set at the specified index\n   * @return the child which was just set\n   * @throws IndexOutOfBoundsException if the index out of range\n   */\n  public tom.library.sl.Visitable setChildAt(int index, tom.library.sl.Visitable v) {\n    switch(index) {\n      case 0: return make((master.fibonacci1.peano.types.Nat) v, _x2);\n      case 1: return make(_x1, (master.fibonacci1.peano.types.Nat) v);\n\n      default: throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Set children to the term\n   *\n   * @param childs array of children to set\n   * @return an array of children which just were set\n   * @throws IndexOutOfBoundsException if length of \"childs\" is different than 2\n   */\n  @SuppressWarnings(\"unchecked\")\n  public tom.library.sl.Visitable setChildren(tom.library.sl.Visitable[] childs) {\n    if (childs.length == 2  && childs[0] instanceof master.fibonacci1.peano.types.Nat && childs[1] instanceof master.fibonacci1.peano.types.Nat) {\n      return make((master.fibonacci1.peano.types.Nat) childs[0], (master.fibonacci1.peano.types.Nat) childs[1]);\n    } else {\n      throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Returns the whole children of the term\n   *\n   * @return the children of the term\n   */\n  public tom.library.sl.Visitable[] getChildren() {\n    return new tom.library.sl.Visitable[] {  _x1,  _x2 };\n  }\n\n    /**\n     * Compute a hashcode for this term.\n     * (for internal use)\n     *\n     * @return a hash value\n     */\n  protected int hashFunction() {\n    int a, b, c;\n    /* Set up the internal state */\n    a = 0x9e3779b9; /* the golden ratio; an arbitrary value */\n    b = (1295190456<<8);\n    c = getArity();\n    /* -------------------------------------- handle most of the key */\n    /* ------------------------------------ handle the last 11 bytes */\n    a += (_x1.hashCode() << 8);\n    a += (_x2.hashCode());\n\n    a -= b; a -= c; a ^= (c >> 13);\n    b -= c; b -= a; b ^= (a << 8);\n    c -= a; c -= b; c ^= (b >> 13);\n    a -= b; a -= c; a ^= (c >> 12);\n    b -= c; b -= a; b ^= (a << 16);\n    c -= a; c -= b; c ^= (b >> 5);\n    a -= b; a -= c; a ^= (c >> 3);\n    b -= c; b -= a; b ^= (a << 10);\n    c -= a; c -= b; c ^= (b >> 15);\n    /* ------------------------------------------- report the result */\n    return c;\n  }\n\n}\n",TextPosition(68,5),TextPosition(449,1)))))
NewTyper : newtyper = false
TyperPlugin : newtyper = false

Code after type inference = 
Tom(concCode(TargetLanguageToCode(TL("\npackage master.fibonacci1.peano.types.nat;\n\n\n\npublic final class fib extends master.fibonacci1.peano.types.Nat implements tom.library.sl.Visitable  {\n  \n  private static String symbolName = \"fib\";\n\n\n  private fib() {}\n  private int hashCode;\n  private static fib proto = new fib();\n  \n",TextPosition(1,1),TextPosition(15,1))),TomInclude(concCode(DeclarationToCode(TypeTermDecl(Name("int"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),Name("t1"),Type("int",TLType(" int "))),BQVariable(concOption(OriginTracking(Name("t2"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),Name("t2"),Type("int",TLType(" int "))),Code(" {0}=={1} "),OriginTracking(Name("equals"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),31,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),Name("t"),Type("int",TLType(" int "))),Code(" true "),OriginTracking(Name("is_sort"),31,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom"))),OriginTracking(Name("int"),29,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom"))),TargetLanguageToCode(TL("\n",TextPosition(33,1),TextPosition(34,1))))),DeclarationToCode(TypeTermDecl(Name("Nat"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t")),Name("t1"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))),BQVariable(concOption(OriginTracking(Name("t2"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t")),Name("t2"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))),Code(" ({0}=={1}) "),OriginTracking(Name("equals"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),19,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t")),Name("t"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))),Code(" ({0} instanceof master.fibonacci1.peano.types.Nat) "),OriginTracking(Name("is_sort"),19,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t"))),OriginTracking(Name("Nat"),17,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t"))),DeclarationToCode(SymbolDecl(Name("zero"))),DeclarationToCode(SymbolDecl(Name("suc"))),DeclarationToCode(SymbolDecl(Name("plus"))),DeclarationToCode(SymbolDecl(Name("mult"))),DeclarationToCode(SymbolDecl(Name("fib"))),TargetLanguageToCode(TL("\n\n  private master.fibonacci1.peano.types.Nat _x;\n\n  /**\n   * Constructor that builds a term rooted by fib\n   *\n   * @return a term rooted by fib\n   */\n\n    public static master.fibonacci1.peano.types.Nat make(master.fibonacci1.peano.types.Nat arg_1) {\n  if (true) {    ",TextPosition(53,1),TextPosition(64,18))),InstructionToCode(Match(concConstraintInstruction(ConstraintInstruction(MatchConstraint(RecordAppl(concOption(OriginTracking(Name("zero"),65,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t")),concTomName(Name("zero")),concSlot(),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_1"),64,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t")),Name("arg_1"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(65,11),TextPosition(65,20)))),BQTermToInstruction(Composite(CompositeBQTerm(BuildTerm(Name("suc"),concBQTerm(Composite(CompositeBQTerm(BuildTerm(Name("zero"),concBQTerm(),"default")))),"default")))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(65,32),TextPosition(65,34))))))),concOption(OriginalText(Name("")))),ConstraintInstruction(MatchConstraint(RecordAppl(concOption(OriginTracking(Name("suc"),66,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t")),concTomName(Name("suc")),concSlot(PairSlotAppl(Name("pred"),RecordAppl(concOption(OriginTracking(Name("zero"),66,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t")),concTomName(Name("zero")),concSlot(),concConstraint()))),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_1"),64,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t")),Name("arg_1"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(66,16),TextPosition(66,25)))),BQTermToInstruction(Composite(CompositeBQTerm(BuildTerm(Name("suc"),concBQTerm(Composite(CompositeBQTerm(BuildTerm(Name("zero"),concBQTerm(),"default")))),"default")))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(66,37),TextPosition(66,39))))))),concOption(OriginalText(Name("")))),ConstraintInstruction(MatchConstraint(RecordAppl(concOption(OriginTracking(Name("suc"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t")),concTomName(Name("suc")),concSlot(PairSlotAppl(Name("pred"),RecordAppl(concOption(OriginTracking(Name("suc"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t")),concTomName(Name("suc")),concSlot(PairSlotAppl(Name("pred"),Variable(concOption(OriginTracking(Name("x"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t")),Name("x"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")),concConstraint()))),concConstraint()))),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_1"),64,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t")),Name("arg_1"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(67,16),TextPosition(67,25)))),BQTermToInstruction(Composite(CompositeBQTerm(BuildTerm(Name("plus"),concBQTerm(Composite(CompositeBQTerm(BuildTerm(Name("fib"),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("x"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t"),ModuleName("default")),Name("x"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")))))),"default"))),Composite(CompositeBQTerm(BuildTerm(Name("fib"),concBQTerm(Composite(CompositeBQTerm(BuildTerm(Name("suc"),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("x"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t"),ModuleName("default")),Name("x"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")))))),"default")))),"default")))),"default")))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(67,51),TextPosition(67,53))))))),concOption(OriginalText(Name(""))))),concOption(OriginTracking(Name("Match"),64,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp7365783915354428884.t"),ModuleName("default")))),TargetLanguageToCode(TL("\n}\n      return realMake( arg_1);\n    }\n  \n  private static fib realMake(master.fibonacci1.peano.types.Nat _x) {\n\n    // use the proto as a model\n    proto.initHashCode( _x);\n    return (fib) factory.build(proto);\n\n  }\n\n  /**\n   * Initializes attributes and hashcode of the class\n   *\n   * @param  _x\n   * @param hashCode hashCode of fib\n   */\n  private void init(master.fibonacci1.peano.types.Nat _x, int hashCode) {\n    this._x = _x;\n\n    this.hashCode = hashCode;\n  }\n\n  /**\n   * Initializes attributes and hashcode of the class\n   *\n   * @param  _x\n   */\n  private void initHashCode(master.fibonacci1.peano.types.Nat _x) {\n    this._x = _x;\n\n    this.hashCode = hashFunction();\n  }\n\n  /* name and arity */\n\n  /**\n   * Returns the name of the symbol\n   *\n   * @return the name of the symbol\n   */\n  @Override\n  public String symbolName() {\n    return \"fib\";\n  }\n\n  /**\n   * Returns the arity of the symbol\n   *\n   * @return the arity of the symbol\n   */\n  private int getArity() {\n    return 1;\n  }\n\n  /**\n   * Copy the object and returns the copy\n   *\n   * @return a clone of the SharedObject\n   */\n  public shared.SharedObject duplicate() {\n    fib clone = new fib();\n    clone.init( _x, hashCode);\n    return clone;\n  }\n  \n  /**\n   * Appends a string representation of this term to the buffer given as argument.\n   *\n   * @param buffer the buffer to which a string represention of this term is appended.\n   */\n  @Override\n  public void toStringBuilder(java.lang.StringBuilder buffer) {\n    buffer.append(\"fib(\");\n    _x.toStringBuilder(buffer);\n\n    buffer.append(\")\");\n  }\n\n\n  /**\n   * Compares two terms. This functions implements a total lexicographic path ordering.\n   *\n   * @param o object to which this term is compared\n   * @return a negative integer, zero, or a positive integer as this\n   *         term is less than, equal to, or greater than the argument\n   * @throws ClassCastException in case of invalid arguments\n   * @throws RuntimeException if unable to compare childs\n   */\n  @Override\n  public int compareToLPO(Object o) {\n    /*\n     * We do not want to compare with any object, only members of the module\n     * In case of invalid argument, throw a ClassCastException, as the java api\n     * asks for it\n     */\n    master.fibonacci1.peano.PeanoAbstractType ao = (master.fibonacci1.peano.PeanoAbstractType) o;\n    /* return 0 for equality */\n    if (ao == this) { return 0; }\n    /* compare the symbols */\n    int symbCmp = this.symbolName().compareTo(ao.symbolName());\n    if (symbCmp != 0) { return symbCmp; }\n    /* compare the childs */\n    fib tco = (fib) ao;\n    int _xCmp = (this._x).compareToLPO(tco._x);\n    if(_xCmp != 0)\n      return _xCmp;\n\n    throw new RuntimeException(\"Unable to compare\");\n  }\n\n /**\n   * Compares two terms. This functions implements a total order.\n   *\n   * @param o object to which this term is compared\n   * @return a negative integer, zero, or a positive integer as this\n   *         term is less than, equal to, or greater than the argument\n   * @throws ClassCastException in case of invalid arguments\n   * @throws RuntimeException if unable to compare childs\n   */\n  @Override\n  public int compareTo(Object o) {\n    /*\n     * We do not want to compare with any object, only members of the module\n     * In case of invalid argument, throw a ClassCastException, as the java api\n     * asks for it\n     */\n    master.fibonacci1.peano.PeanoAbstractType ao = (master.fibonacci1.peano.PeanoAbstractType) o;\n    /* return 0 for equality */\n    if (ao == this) { return 0; }\n    /* use the hash values to discriminate */\n\n    if(hashCode != ao.hashCode()) { return (hashCode < ao.hashCode())?-1:1; }\n\n    /* If not, compare the symbols : back to the normal order */\n    int symbCmp = this.symbolName().compareTo(ao.symbolName());\n    if (symbCmp != 0) { return symbCmp; }\n    /* last resort: compare the childs */\n    fib tco = (fib) ao;\n    int _xCmp = (this._x).compareTo(tco._x);\n    if(_xCmp != 0)\n      return _xCmp;\n\n    throw new RuntimeException(\"Unable to compare\");\n  }\n\n //shared.SharedObject\n  /**\n   * Returns hashCode\n   *\n   * @return hashCode\n   */\n  @Override\n  public final int hashCode() {\n    return hashCode;\n  }\n\n  /**\n   * Checks if a SharedObject is equivalent to the current object\n   *\n   * @param obj SharedObject to test\n   * @return true if obj is a fib and its members are equal, else false\n   */\n  public final boolean equivalent(shared.SharedObject obj) {\n    if(obj instanceof fib) {\n\n      fib peer = (fib) obj;\n      return _x==peer._x && true;\n    }\n    return false;\n  }\n\n\n   //Nat interface\n  /**\n   * Returns true if the term is rooted by the symbol fib\n   *\n   * @return true, because this is rooted by fib\n   */\n  @Override\n  public boolean isfib() {\n    return true;\n  }\n  \n  /**\n   * Returns the attribute master.fibonacci1.peano.types.Nat\n   *\n   * @return the attribute master.fibonacci1.peano.types.Nat\n   */\n  @Override\n  public master.fibonacci1.peano.types.Nat getx() {\n    return _x;\n  }\n\n  /**\n   * Sets and returns the attribute master.fibonacci1.peano.types.Nat\n   *\n   * @param set_arg the argument to set\n   * @return the attribute master.fibonacci1.peano.types.Nat which just has been set\n   */\n  @Override\n  public master.fibonacci1.peano.types.Nat setx(master.fibonacci1.peano.types.Nat set_arg) {\n    return make(set_arg);\n  }\n  \n  /* AbstractType */\n  /**\n   * Returns an ATerm representation of this term.\n   *\n   * @return an ATerm representation of this term.\n   */\n  @Override\n  public aterm.ATerm toATerm() {\n    aterm.ATerm res = super.toATerm();\n    if(res != null) {\n      // the super class has produced an ATerm (may be a variadic operator)\n      return res;\n    }\n    return atermFactory.makeAppl(\n      atermFactory.makeAFun(symbolName(),getArity(),false),\n      new aterm.ATerm[] {getx().toATerm()});\n  }\n\n  /**\n   * Apply a conversion on the ATerm contained in the String and returns a master.fibonacci1.peano.types.Nat from it\n   *\n   * @param trm ATerm to convert into a Gom term\n   * @param atConv ATerm Converter used to convert the ATerm\n   * @return the Gom term\n   */\n  public static master.fibonacci1.peano.types.Nat fromTerm(aterm.ATerm trm, tom.library.utils.ATermConverter atConv) {\n    trm = atConv.convert(trm);\n    if(trm instanceof aterm.ATermAppl) {\n      aterm.ATermAppl appl = (aterm.ATermAppl) trm;\n      if(symbolName.equals(appl.getName()) && !appl.getAFun().isQuoted()) {\n        return make(\nmaster.fibonacci1.peano.types.Nat.fromTerm(appl.getArgument(0),atConv)\n        );\n      }\n    }\n    return null;\n  }\n\n  /* Visitable */\n  /**\n   * Returns the number of childs of the term\n   *\n   * @return the number of childs of the term\n   */\n  public int getChildCount() {\n    return 1;\n  }\n\n  /**\n   * Returns the child at the specified index\n   *\n   * @param index index of the child to return; must be\n             nonnegative and less than the childCount\n   * @return the child at the specified index\n   * @throws IndexOutOfBoundsException if the index out of range\n   */\n  public tom.library.sl.Visitable getChildAt(int index) {\n    switch(index) {\n      case 0: return _x;\n\n      default: throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Set the child at the specified index\n   *\n   * @param index index of the child to set; must be\n             nonnegative and less than the childCount\n   * @param v child to set at the specified index\n   * @return the child which was just set\n   * @throws IndexOutOfBoundsException if the index out of range\n   */\n  public tom.library.sl.Visitable setChildAt(int index, tom.library.sl.Visitable v) {\n    switch(index) {\n      case 0: return make((master.fibonacci1.peano.types.Nat) v);\n\n      default: throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Set children to the term\n   *\n   * @param childs array of children to set\n   * @return an array of children which just were set\n   * @throws IndexOutOfBoundsException if length of \"childs\" is different than 1\n   */\n  @SuppressWarnings(\"unchecked\")\n  public tom.library.sl.Visitable setChildren(tom.library.sl.Visitable[] childs) {\n    if (childs.length == 1  && childs[0] instanceof master.fibonacci1.peano.types.Nat) {\n      return make((master.fibonacci1.peano.types.Nat) childs[0]);\n    } else {\n      throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Returns the whole children of the term\n   *\n   * @return the children of the term\n   */\n  public tom.library.sl.Visitable[] getChildren() {\n    return new tom.library.sl.Visitable[] {  _x };\n  }\n\n    /**\n     * Compute a hashcode for this term.\n     * (for internal use)\n     *\n     * @return a hash value\n     */\n  protected int hashFunction() {\n    int a, b, c;\n    /* Set up the internal state */\n    a = 0x9e3779b9; /* the golden ratio; an arbitrary value */\n    b = (166155791<<8);\n    c = getArity();\n    /* -------------------------------------- handle most of the key */\n    /* ------------------------------------ handle the last 11 bytes */\n    a += (_x.hashCode());\n\n    a -= b; a -= c; a ^= (c >> 13);\n    b -= c; b -= a; b ^= (a << 8);\n    c -= a; c -= b; c ^= (b >> 13);\n    a -= b; a -= c; a ^= (c >> 12);\n    b -= c; b -= a; b ^= (a << 16);\n    c -= a; c -= b; c ^= (b >> 5);\n    a -= b; a -= c; a ^= (c >> 3);\n    b -= c; b -= a; b ^= (a << 10);\n    c -= a; c -= b; c ^= (b >> 15);\n    /* ------------------------------------------- report the result */\n    return c;\n  }\n\n}\n",TextPosition(68,5),TextPosition(411,1)))))
NewTyper : newtyper = false
TyperPlugin : newtyper = false

Code after type inference = 
Tom(concCode(TargetLanguageToCode(TL("\npackage master.fibonacci1.peano.types.nat;\n\n\n\npublic final class mult extends master.fibonacci1.peano.types.Nat implements tom.library.sl.Visitable  {\n  \n  private static String symbolName = \"mult\";\n\n\n  private mult() {}\n  private int hashCode;\n  private static mult proto = new mult();\n  \n",TextPosition(1,1),TextPosition(15,1))),TomInclude(concCode(DeclarationToCode(TypeTermDecl(Name("int"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),Name("t1"),Type("int",TLType(" int "))),BQVariable(concOption(OriginTracking(Name("t2"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),Name("t2"),Type("int",TLType(" int "))),Code(" {0}=={1} "),OriginTracking(Name("equals"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),31,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),Name("t"),Type("int",TLType(" int "))),Code(" true "),OriginTracking(Name("is_sort"),31,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom"))),OriginTracking(Name("int"),29,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom"))),TargetLanguageToCode(TL("\n",TextPosition(33,1),TextPosition(34,1))))),DeclarationToCode(TypeTermDecl(Name("Nat"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t")),Name("t1"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))),BQVariable(concOption(OriginTracking(Name("t2"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t")),Name("t2"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))),Code(" ({0}=={1}) "),OriginTracking(Name("equals"),21,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),19,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t")),Name("t"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))),Code(" ({0} instanceof master.fibonacci1.peano.types.Nat) "),OriginTracking(Name("is_sort"),19,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t"))),OriginTracking(Name("Nat"),17,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t"))),DeclarationToCode(SymbolDecl(Name("zero"))),DeclarationToCode(SymbolDecl(Name("suc"))),DeclarationToCode(SymbolDecl(Name("plus"))),DeclarationToCode(SymbolDecl(Name("mult"))),DeclarationToCode(SymbolDecl(Name("fib"))),TargetLanguageToCode(TL("\n\n  private master.fibonacci1.peano.types.Nat _x1;\n  private master.fibonacci1.peano.types.Nat _x2;\n\n  /**\n   * Constructor that builds a term rooted by mult\n   *\n   * @return a term rooted by mult\n   */\n\n    public static master.fibonacci1.peano.types.Nat make(master.fibonacci1.peano.types.Nat arg_1, master.fibonacci1.peano.types.Nat arg_2) {\n  if (true) {    ",TextPosition(53,1),TextPosition(65,18))),InstructionToCode(Match(concConstraintInstruction(ConstraintInstruction(AndConstraint(MatchConstraint(Variable(concOption(OriginTracking(Name("x"),66,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t")),Name("x"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_1"),65,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t")),Name("arg_1"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")))),MatchConstraint(RecordAppl(concOption(OriginTracking(Name("zero"),66,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t")),concTomName(Name("zero")),concSlot(),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_2"),65,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t")),Name("arg_2"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(66,14),TextPosition(66,23)))),BQTermToInstruction(Composite(CompositeBQTerm(BuildTerm(Name("zero"),concBQTerm(),"default")))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(66,30),TextPosition(66,32))))))),concOption(OriginalText(Name("")))),ConstraintInstruction(AndConstraint(MatchConstraint(Variable(concOption(OriginTracking(Name("x"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t")),Name("x"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_1"),65,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t")),Name("arg_1"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")))),MatchConstraint(RecordAppl(concOption(OriginTracking(Name("suc"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t")),concTomName(Name("suc")),concSlot(PairSlotAppl(Name("pred"),Variable(concOption(OriginTracking(Name("y"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t")),Name("y"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")),concConstraint()))),concConstraint()),BQVariable(concOption(OriginTracking(Name("arg_2"),65,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t")),Name("arg_2"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return ",TextPosition(67,14),TextPosition(67,23)))),BQTermToInstruction(Composite(CompositeBQTerm(BuildTerm(Name("plus"),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("x"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t"),ModuleName("default")),Name("x"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))))),Composite(CompositeBQTerm(BuildTerm(Name("mult"),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("x"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t"),ModuleName("default")),Name("x"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))))),Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("y"),67,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t"),ModuleName("default")),Name("y"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat ")))))),"default")))),"default")))),CodeToInstruction(TargetLanguageToCode(TL("; ",TextPosition(67,43),TextPosition(67,45))))))),concOption(OriginalText(Name(""))))),concOption(OriginTracking(Name("Match"),65,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/tmp2540047721446462583.t"),ModuleName("default")))),TargetLanguageToCode(TL("\n}\n      return realMake( arg_1,  arg_2);\n    }\n  \n  private static mult realMake(master.fibonacci1.peano.types.Nat _x1, master.fibonacci1.peano.types.Nat _x2) {\n\n    // use the proto as a model\n    proto.initHashCode( _x1,  _x2);\n    return (mult) factory.build(proto);\n\n  }\n\n  /**\n   * Initializes attributes and hashcode of the class\n   *\n   * @param  _x1\n   * @param _x2\n   * @param hashCode hashCode of mult\n   */\n  private void init(master.fibonacci1.peano.types.Nat _x1, master.fibonacci1.peano.types.Nat _x2, int hashCode) {\n    this._x1 = _x1;\n    this._x2 = _x2;\n\n    this.hashCode = hashCode;\n  }\n\n  /**\n   * Initializes attributes and hashcode of the class\n   *\n   * @param  _x1\n   * @param _x2\n   */\n  private void initHashCode(master.fibonacci1.peano.types.Nat _x1, master.fibonacci1.peano.types.Nat _x2) {\n    this._x1 = _x1;\n    this._x2 = _x2;\n\n    this.hashCode = hashFunction();\n  }\n\n  /* name and arity */\n\n  /**\n   * Returns the name of the symbol\n   *\n   * @return the name of the symbol\n   */\n  @Override\n  public String symbolName() {\n    return \"mult\";\n  }\n\n  /**\n   * Returns the arity of the symbol\n   *\n   * @return the arity of the symbol\n   */\n  private int getArity() {\n    return 2;\n  }\n\n  /**\n   * Copy the object and returns the copy\n   *\n   * @return a clone of the SharedObject\n   */\n  public shared.SharedObject duplicate() {\n    mult clone = new mult();\n    clone.init( _x1,  _x2, hashCode);\n    return clone;\n  }\n  \n  /**\n   * Appends a string representation of this term to the buffer given as argument.\n   *\n   * @param buffer the buffer to which a string represention of this term is appended.\n   */\n  @Override\n  public void toStringBuilder(java.lang.StringBuilder buffer) {\n    buffer.append(\"mult(\");\n    _x1.toStringBuilder(buffer);\nbuffer.append(\",\");\n    _x2.toStringBuilder(buffer);\n\n    buffer.append(\")\");\n  }\n\n\n  /**\n   * Compares two terms. This functions implements a total lexicographic path ordering.\n   *\n   * @param o object to which this term is compared\n   * @return a negative integer, zero, or a positive integer as this\n   *         term is less than, equal to, or greater than the argument\n   * @throws ClassCastException in case of invalid arguments\n   * @throws RuntimeException if unable to compare childs\n   */\n  @Override\n  public int compareToLPO(Object o) {\n    /*\n     * We do not want to compare with any object, only members of the module\n     * In case of invalid argument, throw a ClassCastException, as the java api\n     * asks for it\n     */\n    master.fibonacci1.peano.PeanoAbstractType ao = (master.fibonacci1.peano.PeanoAbstractType) o;\n    /* return 0 for equality */\n    if (ao == this) { return 0; }\n    /* compare the symbols */\n    int symbCmp = this.symbolName().compareTo(ao.symbolName());\n    if (symbCmp != 0) { return symbCmp; }\n    /* compare the childs */\n    mult tco = (mult) ao;\n    int _x1Cmp = (this._x1).compareToLPO(tco._x1);\n    if(_x1Cmp != 0)\n      return _x1Cmp;\n\n    int _x2Cmp = (this._x2).compareToLPO(tco._x2);\n    if(_x2Cmp != 0)\n      return _x2Cmp;\n\n    throw new RuntimeException(\"Unable to compare\");\n  }\n\n /**\n   * Compares two terms. This functions implements a total order.\n   *\n   * @param o object to which this term is compared\n   * @return a negative integer, zero, or a positive integer as this\n   *         term is less than, equal to, or greater than the argument\n   * @throws ClassCastException in case of invalid arguments\n   * @throws RuntimeException if unable to compare childs\n   */\n  @Override\n  public int compareTo(Object o) {\n    /*\n     * We do not want to compare with any object, only members of the module\n     * In case of invalid argument, throw a ClassCastException, as the java api\n     * asks for it\n     */\n    master.fibonacci1.peano.PeanoAbstractType ao = (master.fibonacci1.peano.PeanoAbstractType) o;\n    /* return 0 for equality */\n    if (ao == this) { return 0; }\n    /* use the hash values to discriminate */\n\n    if(hashCode != ao.hashCode()) { return (hashCode < ao.hashCode())?-1:1; }\n\n    /* If not, compare the symbols : back to the normal order */\n    int symbCmp = this.symbolName().compareTo(ao.symbolName());\n    if (symbCmp != 0) { return symbCmp; }\n    /* last resort: compare the childs */\n    mult tco = (mult) ao;\n    int _x1Cmp = (this._x1).compareTo(tco._x1);\n    if(_x1Cmp != 0)\n      return _x1Cmp;\n\n    int _x2Cmp = (this._x2).compareTo(tco._x2);\n    if(_x2Cmp != 0)\n      return _x2Cmp;\n\n    throw new RuntimeException(\"Unable to compare\");\n  }\n\n //shared.SharedObject\n  /**\n   * Returns hashCode\n   *\n   * @return hashCode\n   */\n  @Override\n  public final int hashCode() {\n    return hashCode;\n  }\n\n  /**\n   * Checks if a SharedObject is equivalent to the current object\n   *\n   * @param obj SharedObject to test\n   * @return true if obj is a mult and its members are equal, else false\n   */\n  public final boolean equivalent(shared.SharedObject obj) {\n    if(obj instanceof mult) {\n\n      mult peer = (mult) obj;\n      return _x1==peer._x1 && _x2==peer._x2 && true;\n    }\n    return false;\n  }\n\n\n   //Nat interface\n  /**\n   * Returns true if the term is rooted by the symbol mult\n   *\n   * @return true, because this is rooted by mult\n   */\n  @Override\n  public boolean ismult() {\n    return true;\n  }\n  \n  /**\n   * Returns the attribute master.fibonacci1.peano.types.Nat\n   *\n   * @return the attribute master.fibonacci1.peano.types.Nat\n   */\n  @Override\n  public master.fibonacci1.peano.types.Nat getx1() {\n    return _x1;\n  }\n\n  /**\n   * Sets and returns the attribute master.fibonacci1.peano.types.Nat\n   *\n   * @param set_arg the argument to set\n   * @return the attribute master.fibonacci1.peano.types.Nat which just has been set\n   */\n  @Override\n  public master.fibonacci1.peano.types.Nat setx1(master.fibonacci1.peano.types.Nat set_arg) {\n    return make(set_arg, _x2);\n  }\n  \n  /**\n   * Returns the attribute master.fibonacci1.peano.types.Nat\n   *\n   * @return the attribute master.fibonacci1.peano.types.Nat\n   */\n  @Override\n  public master.fibonacci1.peano.types.Nat getx2() {\n    return _x2;\n  }\n\n  /**\n   * Sets and returns the attribute master.fibonacci1.peano.types.Nat\n   *\n   * @param set_arg the argument to set\n   * @return the attribute master.fibonacci1.peano.types.Nat which just has been set\n   */\n  @Override\n  public master.fibonacci1.peano.types.Nat setx2(master.fibonacci1.peano.types.Nat set_arg) {\n    return make(_x1, set_arg);\n  }\n  \n  /* AbstractType */\n  /**\n   * Returns an ATerm representation of this term.\n   *\n   * @return an ATerm representation of this term.\n   */\n  @Override\n  public aterm.ATerm toATerm() {\n    aterm.ATerm res = super.toATerm();\n    if(res != null) {\n      // the super class has produced an ATerm (may be a variadic operator)\n      return res;\n    }\n    return atermFactory.makeAppl(\n      atermFactory.makeAFun(symbolName(),getArity(),false),\n      new aterm.ATerm[] {getx1().toATerm(), getx2().toATerm()});\n  }\n\n  /**\n   * Apply a conversion on the ATerm contained in the String and returns a master.fibonacci1.peano.types.Nat from it\n   *\n   * @param trm ATerm to convert into a Gom term\n   * @param atConv ATerm Converter used to convert the ATerm\n   * @return the Gom term\n   */\n  public static master.fibonacci1.peano.types.Nat fromTerm(aterm.ATerm trm, tom.library.utils.ATermConverter atConv) {\n    trm = atConv.convert(trm);\n    if(trm instanceof aterm.ATermAppl) {\n      aterm.ATermAppl appl = (aterm.ATermAppl) trm;\n      if(symbolName.equals(appl.getName()) && !appl.getAFun().isQuoted()) {\n        return make(\nmaster.fibonacci1.peano.types.Nat.fromTerm(appl.getArgument(0),atConv), master.fibonacci1.peano.types.Nat.fromTerm(appl.getArgument(1),atConv)\n        );\n      }\n    }\n    return null;\n  }\n\n  /* Visitable */\n  /**\n   * Returns the number of childs of the term\n   *\n   * @return the number of childs of the term\n   */\n  public int getChildCount() {\n    return 2;\n  }\n\n  /**\n   * Returns the child at the specified index\n   *\n   * @param index index of the child to return; must be\n             nonnegative and less than the childCount\n   * @return the child at the specified index\n   * @throws IndexOutOfBoundsException if the index out of range\n   */\n  public tom.library.sl.Visitable getChildAt(int index) {\n    switch(index) {\n      case 0: return _x1;\n      case 1: return _x2;\n\n      default: throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Set the child at the specified index\n   *\n   * @param index index of the child to set; must be\n             nonnegative and less than the childCount\n   * @param v child to set at the specified index\n   * @return the child which was just set\n   * @throws IndexOutOfBoundsException if the index out of range\n   */\n  public tom.library.sl.Visitable setChildAt(int index, tom.library.sl.Visitable v) {\n    switch(index) {\n      case 0: return make((master.fibonacci1.peano.types.Nat) v, _x2);\n      case 1: return make(_x1, (master.fibonacci1.peano.types.Nat) v);\n\n      default: throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Set children to the term\n   *\n   * @param childs array of children to set\n   * @return an array of children which just were set\n   * @throws IndexOutOfBoundsException if length of \"childs\" is different than 2\n   */\n  @SuppressWarnings(\"unchecked\")\n  public tom.library.sl.Visitable setChildren(tom.library.sl.Visitable[] childs) {\n    if (childs.length == 2  && childs[0] instanceof master.fibonacci1.peano.types.Nat && childs[1] instanceof master.fibonacci1.peano.types.Nat) {\n      return make((master.fibonacci1.peano.types.Nat) childs[0], (master.fibonacci1.peano.types.Nat) childs[1]);\n    } else {\n      throw new IndexOutOfBoundsException();\n    }\n  }\n\n  /**\n   * Returns the whole children of the term\n   *\n   * @return the children of the term\n   */\n  public tom.library.sl.Visitable[] getChildren() {\n    return new tom.library.sl.Visitable[] {  _x1,  _x2 };\n  }\n\n    /**\n     * Compute a hashcode for this term.\n     * (for internal use)\n     *\n     * @return a hash value\n     */\n  protected int hashFunction() {\n    int a, b, c;\n    /* Set up the internal state */\n    a = 0x9e3779b9; /* the golden ratio; an arbitrary value */\n    b = (244895893<<8);\n    c = getArity();\n    /* -------------------------------------- handle most of the key */\n    /* ------------------------------------ handle the last 11 bytes */\n    a += (_x1.hashCode() << 8);\n    a += (_x2.hashCode());\n\n    a -= b; a -= c; a ^= (c >> 13);\n    b -= c; b -= a; b ^= (a << 8);\n    c -= a; c -= b; c ^= (b >> 13);\n    a -= b; a -= c; a ^= (c >> 12);\n    b -= c; b -= a; b ^= (a << 16);\n    c -= a; c -= b; c ^= (b >> 5);\n    a -= b; a -= c; a ^= (c >> 3);\n    b -= c; b -= a; b ^= (a << 10);\n    c -= a; c -= b; c ^= (b >> 15);\n    /* ------------------------------------------- report the result */\n    return c;\n  }\n\n}\n",TextPosition(68,5),TextPosition(449,1)))))
NewTyper : newtyper = false
TyperPlugin : newtyper = false

Code after type inference = 
Tom(concCode(TargetLanguageToCode(TL("/*\n * Copyright (c) 2004-2010, INPL, INRIA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *  - Redistributions of source code must retain the above copyright\n *  notice, this list of conditions and the following disclaimer.\n *  - Redistributions in binary form must reproduce the above copyright\n *  notice, this list of conditions and the following disclaimer in the\n *  documentation and/or other materials provided with the distribution.\n *  - Neither the name of the INRIA nor the names of its\n *  contributors may be used to endorse or promote products derived from\n *  this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage master;\n\nimport master.fibonacci1.peano.types.*;\n\npublic class Fibonacci1 {\n\n  ",TextPosition(1,1),TextPosition(35,3))),TomInclude(concCode(TomInclude(concCode(DeclarationToCode(TypeTermDecl(Name("int"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),Name("t1"),Type("int",TLType(" int "))),BQVariable(concOption(OriginTracking(Name("t2"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),Name("t2"),Type("int",TLType(" int "))),Code(" {0}=={1} "),OriginTracking(Name("equals"),32,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),31,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom")),Name("t"),Type("int",TLType(" int "))),Code(" true "),OriginTracking(Name("is_sort"),31,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom"))),OriginTracking(Name("int"),29,"/Users/claudia/Doctorat/tom/workspace/git-jtom/src/dist/share/tom/java/int.tom"))),TargetLanguageToCode(TL("\n",TextPosition(33,1),TextPosition(34,1))))),DeclarationToCode(TypeTermDecl(Name("Nat"),concDeclaration(EqualTermDecl(BQVariable(concOption(OriginTracking(Name("t1"),8,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/fibonacci1/peano/Peano.tom")),Name("t1"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))),BQVariable(concOption(OriginTracking(Name("t2"),8,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/fibonacci1/peano/Peano.tom")),Name("t2"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))),Code(" ({0}=={1}) "),OriginTracking(Name("equals"),8,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/fibonacci1/peano/Peano.tom")),IsSortDecl(BQVariable(concOption(OriginTracking(Name("t"),6,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/fibonacci1/peano/Peano.tom")),Name("t"),Type("Nat",TLType(" master.fibonacci1.peano.types.Nat "))),Code(" ({0} instanceof master.fibonacci1.peano.types.Nat) "),OriginTracking(Name("is_sort"),6,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/fibonacci1/peano/Peano.tom"))),OriginTracking(Name("Nat"),4,"/Users/claudia/Doctorat/tom/workspace/git-jtom/examples/master/master/fibonacci1/peano/Peano.tom"))),DeclarationToCode(SymbolDecl(Name("zero"))),DeclarationToCode(SymbolDecl(Name("suc"))),DeclarationToCode(SymbolDecl(Name("plus"))),DeclarationToCode(SymbolDecl(Name("mult"))),DeclarationToCode(SymbolDecl(Name("fib"))),TargetLanguageToCode(TL("\n\n",TextPosition(40,1),TextPosition(42,1))))),TargetLanguageToCode(TL("\n\n  public int fibint(int n) {\n    ",TextPosition(56,4),TextPosition(59,5))),InstructionToCode(Match(concConstraintInstruction(ConstraintInstruction(MatchConstraint(RecordAppl(concOption(OriginTracking(Name("0"),60,"Fibonacci1.t"),Constant()),concTomName(Name("0")),concSlot(),concConstraint()),BQVariable(concOption(OriginTracking(Name("n"),59,"Fibonacci1.t")),Name("n"),Type("int",TLType(" int ")))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return 1; ",TextPosition(60,12),TextPosition(60,24))))))),concOption(OriginalText(Name("")))),ConstraintInstruction(MatchConstraint(RecordAppl(concOption(OriginTracking(Name("1"),61,"Fibonacci1.t"),Constant()),concTomName(Name("1")),concSlot(),concConstraint()),BQVariable(concOption(OriginTracking(Name("n"),59,"Fibonacci1.t")),Name("n"),Type("int",TLType(" int ")))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL(" return 1; ",TextPosition(61,12),TextPosition(61,24))))))),concOption(OriginalText(Name("")))),ConstraintInstruction(MatchConstraint(Variable(concOption(OriginTracking(Name("x"),62,"Fibonacci1.t")),Name("x"),Type("int",TLType(" int ")),concConstraint()),BQVariable(concOption(OriginTracking(Name("n"),59,"Fibonacci1.t")),Name("n"),Type("int",TLType(" int ")))),RawAction(AbstractBlock(concInstruction(CodeToInstruction(TargetLanguageToCode(TL("\n        if(",TextPosition(62,12),TextPosition(63,12)))),BQTermToInstruction(BQVariable(concOption(OriginTracking(Name("x"),63,"Fibonacci1.t"),ModuleName("default")),Name("x"),Type("int",TLType(" int ")))),CodeToInstruction(TargetLanguageToCode(TL(">1) {\n          return ",TextPosition(63,15),TextPosition(64,18)))),BQTermToInstruction(Composite(CompositeBQTerm(FunctionCall(Name("fibint"),EmptyType(),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("x"),64,"Fibonacci1.t"),ModuleName("default")),Name("x"),Type("int",TLType(" int ")))),CompositeTL(ITL("-")),CompositeTL(ITL("1")))))))),CodeToInstruction(TargetLanguageToCode(TL(" + ",TextPosition(64,30),TextPosition(64,33)))),BQTermToInstruction(Composite(CompositeBQTerm(FunctionCall(Name("fibint"),EmptyType(),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("x"),64,"Fibonacci1.t"),ModuleName("default")),Name("x"),Type("int",TLType(" int ")))),CompositeTL(ITL("-")),CompositeTL(ITL("2")))))))),CodeToInstruction(TargetLanguageToCode(TL(";\n        }\n      ",TextPosition(64,45),TextPosition(66,7))))))),concOption(OriginalText(Name(""))))),concOption(OriginTracking(Name("Match"),59,"Fibonacci1.t"),ModuleName("default")))),TargetLanguageToCode(TL("\n    return -1;\n  }\n\n  //-------------------------------------------------------\n\n  public void run() {\n    System.out.println(\"running...\");\n    Nat one = ",TextPosition(67,5),TextPosition(75,15))),BQTermToCode(Composite(CompositeBQTerm(BuildTerm(Name("suc"),concBQTerm(Composite(CompositeBQTerm(BuildTerm(Name("zero"),concBQTerm(),"default")))),"default")))),TargetLanguageToCode(TL(";\n    Nat two = ",TextPosition(75,27),TextPosition(76,15))),BQTermToCode(Composite(CompositeBQTerm(BuildTerm(Name("suc"),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("one"),76,"Fibonacci1.t"),ModuleName("default")),Name("one"),Type("unknown type",EmptyType()))))),"default")))),TargetLanguageToCode(TL(";\n\n    System.out.println(\"plus(one,two) = \" + ",TextPosition(76,24),TextPosition(78,45))),BQTermToCode(Composite(CompositeBQTerm(BuildTerm(Name("plus"),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("one"),78,"Fibonacci1.t"),ModuleName("default")),Name("one"),Type("unknown type",EmptyType())))),Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("two"),78,"Fibonacci1.t"),ModuleName("default")),Name("two"),Type("unknown type",EmptyType()))))),"default")))),TargetLanguageToCode(TL(");\n    System.out.println(\"mult(two,two) = \" + ",TextPosition(78,59),TextPosition(79,45))),BQTermToCode(Composite(CompositeBQTerm(BuildTerm(Name("mult"),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("two"),79,"Fibonacci1.t"),ModuleName("default")),Name("two"),Type("unknown type",EmptyType())))),Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("two"),79,"Fibonacci1.t"),ModuleName("default")),Name("two"),Type("unknown type",EmptyType()))))),"default")))),TargetLanguageToCode(TL(");\n    System.out.println(\"fibint(4) = \" + ",TextPosition(79,59),TextPosition(80,41))),BQTermToCode(Composite(CompositeBQTerm(FunctionCall(Name("fibint"),EmptyType(),concBQTerm(Composite(CompositeTL(ITL("4")))))))),TargetLanguageToCode(TL(");\n    System.out.println(\"fib(four) = \" + ",TextPosition(80,51),TextPosition(81,41))),BQTermToCode(Composite(CompositeBQTerm(BuildTerm(Name("fib"),concBQTerm(Composite(CompositeBQTerm(BuildTerm(Name("mult"),concBQTerm(Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("two"),81,"Fibonacci1.t"),ModuleName("default")),Name("two"),Type("unknown type",EmptyType())))),Composite(CompositeBQTerm(BQVariable(concOption(OriginTracking(Name("two"),81,"Fibonacci1.t"),ModuleName("default")),Name("two"),Type("unknown type",EmptyType()))))),"default")))),"default")))),TargetLanguageToCode(TL(");\n  }\n\n  public final static void main(String[] args) {\n    Fibonacci1 test = new Fibonacci1();\n    test.run();\n  }\n\n}\n",TextPosition(81,60),TextPosition(90,1)))))
NewTyper : newtyper = false
