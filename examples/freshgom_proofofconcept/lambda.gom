module lambda
imports int String
abstract syntax

RLTerm =
  | rapp(t1:RLTerm,t2:RLTerm)
  | rabs(x:String,t:RLTerm)
  | rvar(x:String)

Atom = atom(n:int,hint:String)

LTerm =
  | app(t1:LTerm,t2:LTerm)
  | abs(x:Atom,t:LTerm)
  | var(x:Atom)

sort LTerm:block() {
  public abstract void rename(int i,int j);
  private static int counter = 0;
  public static freshgom_proofofconcept.lambda.types.Atom 
   freshAtom(String hint) { return `atom(++counter,hint); }
}

sort Atom:block() {
  public boolean equals(freshgom_proofofconcept.lambda.types.Atom o) {
    return this.getn() == o.getn();
  }
}

abs:block() {
  private static int counter = 0;

  private void refresh() {
    int old = getx().getn();
    freshgom_proofofconcept.lambda.types.Atom fresh = freshAtom(getx().gethint());
    setx(fresh);
    gett().rename(old,fresh.getn());
  }

  public freshgom_proofofconcept.lambda.types.Atom safe_getx() {
    refresh();
    return getx();
  }

  public freshgom_proofofconcept.lambda.types.LTerm safe_gett() {
    refresh();
    return gett();
  }

  public void rename(int i, int j) {
    if(getx().getn() == i) throw new RuntimeException("should not happen");
    else gett().rename(i,j);
  }
}

app:block() {
  public void rename(int i, int j) {
    gett1().rename(i,j);
    gett2().rename(i,j);
  }
}

var:block() {
  public void rename(int i, int j) {
    if(getx().getn() == i) setx(`atom(j,getx().gethint()));
  }
}
