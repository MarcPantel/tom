%include { string.tom }
%include { int.tom }

%typeterm RLTerm {
  implement { freshgom_proofofconcept.lambda.types.RLTerm }
  is_sort(t) { ($t instanceof freshgom_proofofconcept.lambda.types.RLTerm) }
  equals(t1,t2) { ($t1.equals($t2)) }

}

%op RLTerm RawApp(t1:RLTerm, t2:RLTerm) {
  is_fsym(t) { ($t instanceof freshgom_proofofconcept.lambda.types.rlterm.RawApp) }
  get_slot(t1, t) { $t.gett1() }
  get_slot(t2, t) { $t.gett2() }
  make(t0, t1) { freshgom_proofofconcept.lambda.types.rlterm.RawApp.make($t0, $t1) }
}

%op RLTerm RawAbs(x:String, t:RLTerm) {
  is_fsym(t) { ($t instanceof freshgom_proofofconcept.lambda.types.rlterm.RawAbs) }
  get_slot(x, t) { $t.getx() }
  get_slot(t, t) { $t.gett() }
  make(t0, t1) { freshgom_proofofconcept.lambda.types.rlterm.RawAbs.make($t0, $t1) }
}

%op RLTerm RawLet(x:String, t:RLTerm, u:RLTerm) {
  is_fsym(t) { ($t instanceof freshgom_proofofconcept.lambda.types.rlterm.RawLet) }
  get_slot(x, t) { $t.getx() }
  get_slot(t, t) { $t.gett() }
  get_slot(u, t) { $t.getu() }
  make(t0, t1, t2) { freshgom_proofofconcept.lambda.types.rlterm.RawLet.make($t0, $t1, $t2) }
}

%op RLTerm RawVar(x:String) {
  is_fsym(t) { ($t instanceof freshgom_proofofconcept.lambda.types.rlterm.RawVar) }
  get_slot(x, t) { $t.getx() }
  make(t0) { freshgom_proofofconcept.lambda.types.rlterm.RawVar.make($t0) }
}



%typeterm LVar {
  implement { freshgom_proofofconcept.lambda.types.LVar }
  is_sort(t) { ($t instanceof freshgom_proofofconcept.lambda.types.LVar) }
  equals(t1,t2) { ($t1.equals($t2)) }
}

%typeterm LTerm {
  implement { freshgom_proofofconcept.lambda.types.LTerm }
  is_sort(t) { ($t instanceof freshgom_proofofconcept.lambda.types.LTerm) }
  equals(t1,t2) { ($t1.equals($t2)) }
}

/* the details of how LVar is implemented should be hidden

%op LVar LVar(n:int, hint:String) {
  is_fsym(t) { ($t instanceof freshgom_proofofconcept.lambda.types.LVar.LVar) }
  get_slot(n, t) { $t.getn() }
  get_slot(hint, t) { $t.gethint() }
  make(t0, t1) { freshgom_proofofconcept.lambda.types.LVar.LVar.make($t0, $t1) }
}
*/

%op LTerm App(t1:LTerm, t2:LTerm) {
  is_fsym(t) { ($t instanceof freshgom_proofofconcept.lambda.types.lterm.App) }
  get_slot(t1, t) { $t.gett1() }
  get_slot(t2, t) { $t.gett2() }
  make(t0, t1) { freshgom_proofofconcept.lambda.types.lterm.App.make($t0, $t1) }
}

%op LTerm Abs(x:LVar, t:LTerm) {
  is_fsym(t) { ($t instanceof freshgom_proofofconcept.lambda.types.lterm.Abs) }
  // modified here
  get_slot(x, t) { ((freshgom_proofofconcept.lambda.types.lterm.Abs)$t).safe_getx() }
  // modified here
  get_slot(t, t) { ((freshgom_proofofconcept.lambda.types.lterm.Abs)$t).safe_gett() }
  make(t0, t1) { freshgom_proofofconcept.lambda.types.lterm.Abs.make($t0, $t1) }
}

%op LTerm Let(x:LVar, t:LTerm, u:LTerm) {
  is_fsym(t) { ($t instanceof freshgom_proofofconcept.lambda.types.lterm.Let) }
  get_slot(x, t) { ((freshgom_proofofconcept.lambda.types.lterm.Let)$t).safe_getx() }
  get_slot(t, t) {((freshgom_proofofconcept.lambda.types.lterm.Let)$t).safe_gett() }
  get_slot(u, t) { ((freshgom_proofofconcept.lambda.types.lterm.Let)$t).safe_getu() }
  make(t0, t1, t2) { freshgom_proofofconcept.lambda.types.lterm.Let.make($t0, $t1, $t2) }
}

%op LTerm Var(x:LVar) {
  is_fsym(t) { ($t instanceof freshgom_proofofconcept.lambda.types.lterm.Var) }
  get_slot(x, t) { $t.getx() }
  make(t0) { freshgom_proofofconcept.lambda.types.lterm.Var.make($t0) }
}

