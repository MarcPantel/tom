module polygraphes.Polygraphes
imports int String
abstract syntax
TwoPath = 
      | id(Value:int)
      | g(Name:String, Source:int, Target:int)
      | c0( TwoPath* )
      | c1( TwoPath* )

/*
 * C0(0,G) = G
 * C0(G,0) = G
 */
c0:make_insert(x,y) {
  %match(x,y) {
    c0(),g -> { return `g; }
    g,c0() -> { return `g; }
    c0(X*),g -> { return `c0(X*,g); }
    c1(),g -> { return `g; }

    id(0),g -> { return `g; }
    g,id(0) -> { return `g; }
    /* id(m),id(n) is handled by AU :-) */
    id(m),c0(id(n),tail*) -> { return `c0(id(n+m),tail*); }
  }
}

/*
 * C1(m,G) = G if m=G.source
 * C1(G,n) = G if n=G.target
 */
c1:make_insert(x,y) {
  %match(x,y) {
    c1(),g -> { return `g; }
    g,c1() -> { return `g; }
    c1(X*),g -> { 
      if(getTarget(x)!=getSource(y)) { throws new RuntimeException("bad number of lines: " + x + " " + y); }
      return `c1(X*,g);
    }
    c0(),g -> { return `g; }
    
    id(m), g -> { 
      if(getTarget(x)!=getSource(y)) { throws new RuntimeException("bad number of lines: " + x + " " + y); }
      return `g;
    }
    g, id(n) -> { 
      if(getTarget(x)!=getSource(y)) { throws new RuntimeException("bad number of lines: " + x + " " + y); }
      return `g;
    }
    c1(),_ -> { return l; }
    c1(subL*),_ -> { return `c1(subL*,l*); }
  }
}

