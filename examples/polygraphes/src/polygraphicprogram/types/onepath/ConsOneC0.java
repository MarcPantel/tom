/* Generated by TOM (version 20071002 (src)): Do not edit this file */

package polygraphicprogram.types.onepath;


public final class ConsOneC0 extends polygraphicprogram.types.onepath.OneC0 implements tom.library.sl.Visitable  {

private ConsOneC0() {}

private int hashCode;
private static ConsOneC0 proto = new ConsOneC0();
/* Generated by TOM (version 20071002 (src)): Do not edit this file */
/* Generated by TOM (version 20071002 (src)): Do not edit this file */
private static boolean tom_equal_term_char(char t1, char t2) { return (t1==t2) 
;
}
private static boolean tom_is_sort_char(char t) { return  true ;
}
private static boolean tom_equal_term_String(String t1, String t2) { return (t1.equals(t2)) 
;
}
private static boolean tom_is_sort_String(String t) { return  t instanceof String ;
}
private static boolean tom_equal_term_ThreePath(Object t1, Object t2) { return t1.equals(t2) 
;
}
private static boolean tom_is_sort_ThreePath(Object t) { return  t instanceof polygraphicprogram.types.ThreePath ;
}
private static boolean tom_equal_term_CellType(Object t1, Object t2) { return t1.equals(t2) 
;
}
private static boolean tom_is_sort_CellType(Object t) { return  t instanceof polygraphicprogram.types.CellType ;
}
private static boolean tom_equal_term_TwoPath(Object t1, Object t2) { return t1.equals(t2) 
;
}
private static boolean tom_is_sort_TwoPath(Object t) { return  t instanceof polygraphicprogram.types.TwoPath ;
}
private static boolean tom_equal_term_OnePath(Object t1, Object t2) { return t1.equals(t2) 
;
}
private static boolean tom_is_sort_OnePath(Object t) { return  t instanceof polygraphicprogram.types.OnePath ;
}
private static  polygraphicprogram.types.OnePath  tom_make_Id() { return  polygraphicprogram.types.onepath.Id.make() ; }
private polygraphicprogram.types.OnePath _HeadOneC0;
private polygraphicprogram.types.OnePath _TailOneC0;

/* static constructor */

private static ConsOneC0 realMake(polygraphicprogram.types.OnePath _HeadOneC0, polygraphicprogram.types.OnePath _TailOneC0) {
proto.initHashCode( _HeadOneC0,  _TailOneC0);
return (ConsOneC0) factory.build(proto);
}

public static polygraphicprogram.types.OnePath make(polygraphicprogram.types.OnePath head, polygraphicprogram.types.OnePath tail) {
if (true) {if (head == 
tom_make_Id()) { return tail; }
if (tail ==  
tom_make_Id()) { return head; }
}if (true) {if (head.isEmptyOneC0()) { return tail; }
if (tail.isEmptyOneC0()) { return head; }
if (head.isConsOneC0()) { return make(head.getHeadOneC0(),make(head.getTailOneC0(),tail)); }
}
return realMake( head,  tail);
}

private void init(polygraphicprogram.types.OnePath _HeadOneC0, polygraphicprogram.types.OnePath _TailOneC0, int hashCode) {
this._HeadOneC0 = _HeadOneC0;
this._TailOneC0 = _TailOneC0;

this.hashCode = hashCode;
}

private void initHashCode(polygraphicprogram.types.OnePath _HeadOneC0, polygraphicprogram.types.OnePath _TailOneC0) {
this._HeadOneC0 = _HeadOneC0;
this._TailOneC0 = _TailOneC0;

this.hashCode = hashFunction();
}

/* name and arity */
@Override
public String symbolName() {
return "ConsOneC0";
}

private int getArity() {
return 2;
}

public shared.SharedObject duplicate() {
ConsOneC0 clone = new ConsOneC0();
clone.init( _HeadOneC0,  _TailOneC0, hashCode);
return clone;
}



/**
* This method implements a lexicographic order
*/
@Override
public int compareToLPO(Object o) {
/*
* We do not want to compare with any object, only members of the module
* In case of invalid argument, throw a ClassCastException, as the java api
* asks for it
*/
polygraphicprogram.PolygraphicProgramAbstractType ao = (polygraphicprogram.PolygraphicProgramAbstractType) o;
/* return 0 for equality */
if (ao == this)
return 0;
/* compare the symbols */
int symbCmp = this.symbolName().compareTo(ao.symbolName());
if (symbCmp != 0)
return symbCmp;
/* compare the childs */
ConsOneC0 tco = (ConsOneC0) ao;
int _HeadOneC0Cmp = (this._HeadOneC0).compareToLPO(tco._HeadOneC0);
if(_HeadOneC0Cmp != 0)
return _HeadOneC0Cmp;

int _TailOneC0Cmp = (this._TailOneC0).compareToLPO(tco._TailOneC0);
if(_TailOneC0Cmp != 0)
return _TailOneC0Cmp;

throw new RuntimeException("Unable to compare");
}

@Override
public int compareTo(Object o) {
/*
* We do not want to compare with any object, only members of the module
* In case of invalid argument, throw a ClassCastException, as the java api
* asks for it
*/
polygraphicprogram.PolygraphicProgramAbstractType ao = (polygraphicprogram.PolygraphicProgramAbstractType) o;
/* return 0 for equality */
if (ao == this)
return 0;
/* use the hash values to discriminate */

if(hashCode != ao.hashCode())
return (hashCode < ao.hashCode())?-1:1;

/* If not, compare the symbols : back to the normal order */
int symbCmp = this.symbolName().compareTo(ao.symbolName());
if (symbCmp != 0)
return symbCmp;
/* last resort: compare the childs */
ConsOneC0 tco = (ConsOneC0) ao;
int _HeadOneC0Cmp = (this._HeadOneC0).compareTo(tco._HeadOneC0);
if(_HeadOneC0Cmp != 0)
return _HeadOneC0Cmp;

int _TailOneC0Cmp = (this._TailOneC0).compareTo(tco._TailOneC0);
if(_TailOneC0Cmp != 0)
return _TailOneC0Cmp;

throw new RuntimeException("Unable to compare");
}

/* shared.SharedObject */
@Override
public final int hashCode() {
return hashCode;
}

public final boolean equivalent(shared.SharedObject obj) {
if(obj instanceof ConsOneC0) {

ConsOneC0 peer = (ConsOneC0) obj;
return _HeadOneC0==peer._HeadOneC0 && _TailOneC0==peer._TailOneC0 && true;
}
return false;
}

/* OnePath interface */
@Override
public boolean isConsOneC0() {
return true;
}

@Override
public polygraphicprogram.types.OnePath getHeadOneC0() {
return _HeadOneC0;
}

@Override
public polygraphicprogram.types.OnePath setHeadOneC0(polygraphicprogram.types.OnePath set_arg) {
return make(set_arg, _TailOneC0);
}
@Override
public polygraphicprogram.types.OnePath getTailOneC0() {
return _TailOneC0;
}

@Override
public polygraphicprogram.types.OnePath setTailOneC0(polygraphicprogram.types.OnePath set_arg) {
return make(_HeadOneC0, set_arg);
}
/* AbstractType */
@Override
public aterm.ATerm toATerm() {
return atermFactory.makeAppl(
atermFactory.makeAFun(symbolName(),getArity(),false),
new aterm.ATerm[] {getHeadOneC0().toATerm(), getTailOneC0().toATerm()});
}

public static polygraphicprogram.types.OnePath fromTerm(aterm.ATerm trm) {
if(trm instanceof aterm.ATermAppl) {
aterm.ATermAppl appl = (aterm.ATermAppl) trm;
if(proto.symbolName().equals(appl.getName())) {
return make(
polygraphicprogram.types.OnePath.fromTerm(appl.getArgument(0)), polygraphicprogram.types.OnePath.fromTerm(appl.getArgument(1))
);
}
}
return null;
}


/* Visitable */
public int getChildCount() {
return 2;
}

public tom.library.sl.Visitable getChildAt(int index) {
switch(index) {
case 0: return _HeadOneC0;
case 1: return _TailOneC0;

default: throw new IndexOutOfBoundsException();
}
}

public tom.library.sl.Visitable setChildAt(int index, tom.library.sl.Visitable v) {
switch(index) {
case 0: return make((polygraphicprogram.types.OnePath) v, _TailOneC0);
case 1: return make(_HeadOneC0, (polygraphicprogram.types.OnePath) v);

default: throw new IndexOutOfBoundsException();
}
}

public tom.library.sl.Visitable setChildren(tom.library.sl.Visitable[] childs) {
if (childs.length == 2) {
return make((polygraphicprogram.types.OnePath) childs[0], (polygraphicprogram.types.OnePath) childs[1]);
} else {
throw new IndexOutOfBoundsException();
}
}

public tom.library.sl.Visitable[] getChildren() {
return new tom.library.sl.Visitable[] {  _HeadOneC0,  _TailOneC0 };
}

/* internal use */
protected  int hashFunction() {
int a, b, c;
/* Set up the internal state */
a = 0x9e3779b9; /* the golden ratio; an arbitrary value */
b = (-1217640184<<8);
c = getArity();
/* -------------------------------------- handle most of the key */
/* ------------------------------------ handle the last 11 bytes */
a += (_HeadOneC0.hashCode() << 8);
a += (_TailOneC0.hashCode());

a -= b; a -= c; a ^= (c >> 13);
b -= c; b -= a; b ^= (a << 8);
c -= a; c -= b; c ^= (b >> 13);
a -= b; a -= c; a ^= (c >> 12);
b -= c; b -= a; b ^= (a << 16);
c -= a; c -= b; c ^= (b >> 5);
a -= b; a -= c; a ^= (c >> 3);
b -= c; b -= a; b ^= (a << 10);
c -= a; c -= b; c ^= (b >> 15);
/* ------------------------------------------- report the result */
return c;
}

}
