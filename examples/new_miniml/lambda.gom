module Lambda
imports int String
abstract syntax

/* pure calculus */

atom LVar 

LType = Atom(n:String)
      | Arrow(t1:LType,t2:LType)
      | TypeVar(i:int)

LTerm = App(t1:LTerm,t2:LTerm)
      | Abs(a:<Lam>)
      | Let(b:<Letin>)
      | Fix(c:<Fixpoint>)
      | Var(x:LVar)
      | Constr(f:String, children:LTermList)
      | Case(subject:LTerm,rules:Rules)

Rules = RList(<Clause>*)

Clause binds LVar = Rule(p:Pattern, inner t:LTerm) 

Pattern binds LVar = PFun(neutral f:String, children:PatternList)
                   | PVar(x:LVar, neutral ty:LType)

LTermList = LTList(LTerm*) 

PatternList binds LVar = PList(Pattern*)

Lam binds LVar = lam(x:LVar, neutral ty:LType, inner t:LTerm)
Letin binds LVar = letin(x:LVar, outer u:LTerm, inner t:LTerm)
Fixpoint binds LVar = fixpoint(x:LVar, neutral ty:LType, inner t:LTerm)

/* type reconstruction */

Constraint = Constraint(ty1:LType,ty2:LType)
ConstraintList = CList(Constraint*)
ReconResult = Pair(ty:LType,cl:ConstraintList)
Domain = Domain(LType*)
Range = Range(dom:Domain,codom:LType)
Jugement = Jugement(v:LVar,ty:LType)
         | RangeOf(c:String,r:Range)
Context = Context(Jugement*)
Mapping = MapsTo(i:int,ty:LType)
Substitution = MList(Mapping*)
ContextAndResult = CRPair(c:Context,r:ReconResult)
ContextAndConstraints = CCPair(c:Context,cl:ConstraintList)
