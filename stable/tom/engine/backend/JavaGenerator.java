/*
 *
 * TOM - To One Matching Compiler
 *
 * Copyright (c) 2000-2012, INPL, INRIA
 * Nancy, France.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 *
 * Pierre-Etienne Moreau  e-mail: Pierre-Etienne.Moreau@loria.fr
 *
 **/

package tom.engine.backend;

import java.io.IOException;
import java.util.ArrayList;

import tom.engine.TomBase;
import tom.engine.tools.OutputCode;

import tom.engine.adt.tomsignature.*;
import tom.engine.adt.tomconstraint.types.*;
import tom.engine.adt.tomdeclaration.types.*;
import tom.engine.adt.tomexpression.types.*;
import tom.engine.adt.tominstruction.types.*;
import tom.engine.adt.tomname.types.*;
import tom.engine.adt.tomoption.types.*;
import tom.engine.adt.tomsignature.types.*;
import tom.engine.adt.tomterm.types.*;
import tom.engine.adt.tomslot.types.*;
import tom.engine.adt.tomtype.types.*;
import tom.engine.adt.code.types.*;

import tom.engine.tools.SymbolTable;
import tom.platform.OptionManager;
import tom.engine.exception.TomRuntimeException;

public class JavaGenerator extends CFamilyGenerator {

  /* modifier associated to classes generated by %strategy */
  protected String stratmodifier = "";

  public JavaGenerator(OutputCode output, OptionManager optionManager,
                       SymbolTable symbolTable) {
    super(output, optionManager, symbolTable);
    /* Even if this field is not used here, we /must/ initialize it correctly,
     * as it is used by CFamilyGenerator */
    this.modifier += "private " ;
    if( ((Boolean)optionManager.getOptionValue("protected")).booleanValue() ) {
      this.stratmodifier += "protected " ;
    } else {
      this.stratmodifier += "public " ; // public by default to make constructor of strategies reusable
    }

    if(!((Boolean)optionManager.getOptionValue("noStatic")).booleanValue()) {
      this.modifier += "static " ;
      this.stratmodifier += "static " ;
    }
  }

// ------------------------------------------------------------
      
// ------------------------------------------------------------

  protected void buildExpBottom(int deep, TomType type, String moduleName) throws IOException {
    String typeName = TomBase.getTomType(type);
    if(getSymbolTable(moduleName).isIntType(typeName)
        || getSymbolTable(moduleName).isCharType(typeName)
        || getSymbolTable(moduleName).isLongType(typeName)
        || getSymbolTable(moduleName).isFloatType(typeName)
        || getSymbolTable(moduleName).isDoubleType(typeName)
        ) {
      output.write(" 0 ");
    } else if(getSymbolTable(moduleName).isBooleanType(typeName)) {
      output.write(" false ");
    } else if(getSymbolTable(moduleName).isStringType(typeName)) {
      output.write(" \"\" ");
    } else {
      output.write(" null ");
    }
  }

  protected void buildExpTrue(int deep) throws IOException {
    output.write(" true ");
  }

  protected void buildExpFalse(int deep) throws IOException {
    output.write(" false ");
  }

  protected void buildNamedBlock(int deep, String blockName, InstructionList instList, String moduleName) throws IOException {
    output.writeln(blockName + ": {");
    generateInstructionList(deep+1,instList,moduleName);
    output.writeln("}");
  }
  
  protected void buildIntrospectorClass(int deep, String tomName, Declaration declaration, String moduleName) throws IOException {
    output.write("public static class " + tomName+ " implements tom.library.sl.Introspector {");
    generateDeclaration(deep,declaration,moduleName);
    output.write(deep,"}");
  }

  protected void buildClass(int deep, String tomName, TomType extendsType, BQTerm superTerm, Declaration declaration, String moduleName) throws IOException {
    TomSymbol tomSymbol = getSymbolTable(moduleName).getSymbolFromName(tomName);
    TomTypeList tomTypes = TomBase.getSymbolDomain(tomSymbol);
    ArrayList<String> names = new ArrayList<String>();
    ArrayList<String> types = new ArrayList<String>();
    ArrayList<Integer> stratChild = new ArrayList<Integer>(); // child of type Strategy.

    //initialize arrayList with argument names
    int index = 0;
    while(!tomTypes.isEmptyconcTomType()) {
	    TomType type = tomTypes.getHeadconcTomType();
	    types.add(TomBase.getTLType(type));
      String name = TomBase.getSlotName(tomSymbol, index).getString();
      names.add(name);

      // test if the argument is a Strategy
      {{if ( (((Object)type) instanceof tom.engine.adt.tomtype.types.TomType) ) {if ( ((( tom.engine.adt.tomtype.types.TomType )((Object)type)) instanceof tom.engine.adt.tomtype.types.TomType) ) {if ( ((( tom.engine.adt.tomtype.types.TomType )(( tom.engine.adt.tomtype.types.TomType )((Object)type))) instanceof tom.engine.adt.tomtype.types.tomtype.Type) ) { String  tomMatch100_1= (( tom.engine.adt.tomtype.types.TomType )((Object)type)).getTomType() ;if ( true ) {if ( "Strategy".equals(tomMatch100_1) ) {

          stratChild.add(Integer.valueOf(index));
        }}}}}}}


	    tomTypes = tomTypes.getTailconcTomType();
	    index++;
    }
    output.write(deep, stratmodifier + "class " + tomName);
    //write extends
matchblock: {
              {{if ( (((Object)extendsType) instanceof tom.engine.adt.tomtype.types.TomType) ) {if ( ((( tom.engine.adt.tomtype.types.TomType )((Object)extendsType)) instanceof tom.engine.adt.tomtype.types.TomType) ) {if ( ((( tom.engine.adt.tomtype.types.TomType )(( tom.engine.adt.tomtype.types.TomType )((Object)extendsType))) instanceof tom.engine.adt.tomtype.types.tomtype.Type) ) { tom.engine.adt.tomtype.types.TargetLanguageType  tomMatch101_1= (( tom.engine.adt.tomtype.types.TomType )((Object)extendsType)).getTlType() ;if ( (tomMatch101_1 instanceof tom.engine.adt.tomtype.types.TargetLanguageType) ) {if ( ((( tom.engine.adt.tomtype.types.TargetLanguageType )tomMatch101_1) instanceof tom.engine.adt.tomtype.types.targetlanguagetype.TLType) ) {

				output.write(deep," extends " +  tomMatch101_1.getString() );
        break matchblock;
			}}}}}}{if ( (((Object)extendsType) instanceof tom.engine.adt.tomtype.types.TomType) ) {if ( ((( tom.engine.adt.tomtype.types.TomType )((Object)extendsType)) instanceof tom.engine.adt.tomtype.types.TomType) ) {if ( ((( tom.engine.adt.tomtype.types.TomType )(( tom.engine.adt.tomtype.types.TomType )((Object)extendsType))) instanceof tom.engine.adt.tomtype.types.tomtype.Type) ) { tom.engine.adt.tomtype.types.TargetLanguageType  tomMatch101_9= (( tom.engine.adt.tomtype.types.TomType )((Object)extendsType)).getTlType() ;if ( (tomMatch101_9 instanceof tom.engine.adt.tomtype.types.TargetLanguageType) ) {if ( ((( tom.engine.adt.tomtype.types.TargetLanguageType )tomMatch101_9) instanceof tom.engine.adt.tomtype.types.targetlanguagetype.EmptyTargetLanguageType) ) {


				output.write(deep," extends " +  (( tom.engine.adt.tomtype.types.TomType )((Object)extendsType)).getTomType() );
        break matchblock;
			}}}}}}}

            }
    output.writeln(deep," {");
    int args = names.size();
    //write Declarations
    for(int i = 0 ; i < args ; i++) {
      output.writeln(deep, "private " + types.get(i) + " " + names.get(i) + ";");
    }

    //write constructor
    output.write(deep, "public " + tomName + "(");
    //write constructor parameters
    for(int i = 0 ; i < args ; i++) {
	    output.write(deep,types.get(i) + " " + names.get(i));
	    if(i+1<args) {//if many parameters
		    output.write(deep,", ");
	    }
    }

    //write constructor initialization
    output.writeln(deep,") {");
    output.write(deep+1,"super(");
    generateBQTerm(deep,superTerm,moduleName);
    output.writeln(");");

    //here index represents the parameter number
    for(int i = 0 ; i < args ; i++) {
	    String param = names.get(i);
	    output.writeln(deep+1, "this." + param + "=" + param + ";");
    }
    output.writeln(deep,"}");

    // write getters
    for(int i = 0 ; i < args ; i++) {
      output.writeln(deep, "public " + types.get(i) + " get" + names.get(i) + "() {");
      output.writeln(deep+1,"return " + names.get(i) + ";");
      output.writeln(deep,"}");
    }

    // write getChildCount (= 1 + stratChildCount because of the %strategy `extends' which is the first child)
    int stratChildCount = stratChild.size();

    output.writeln(deep, "public tom.library.sl.Visitable[] getChildren() {");
    output.writeln(deep, "tom.library.sl.Visitable[] stratChildren = new tom.library.sl.Visitable[getChildCount()];");
    output.writeln(deep, "stratChildren[0] = super.getChildAt(0);");
    for(int i = 0; i < stratChildCount; i++) {
      int j = (stratChild.get(i)).intValue();
      output.writeln(deep, "stratChildren[" + (i+1) + "] = get" + names.get(j) + "();");
    }
    output.writeln(deep, "return stratChildren;}");

    output.writeln(deep, "public tom.library.sl.Visitable setChildren(tom.library.sl.Visitable[] children) {");
    output.writeln(deep,"super.setChildAt(0, children[0]);");
    for(int i = 0; i < stratChildCount; i++) {
      int j = (stratChild.get(i)).intValue();
      output.writeln(deep, names.get(j) + " = (" + types.get(j) + ") children[" + (i+1) + "];");
    }
    output.writeln(deep, "return this;");
    output.writeln(deep, "}");

    output.writeln(deep, "public int getChildCount() {");
    output.writeln(deep, "return " + (stratChildCount + 1) + ";");
    output.writeln(deep, "}");

    // write getChildAt
    output.writeln(deep, "public tom.library.sl.Visitable getChildAt(int index) {");
    output.writeln(deep, "switch (index) {");
    output.writeln(deep, "case 0: return super.getChildAt(0);");
    for (int i = 0; i < stratChildCount; i++) {
      int j = (stratChild.get(i)).intValue();
      output.writeln(deep, "case " + (i+1) + ": return get" + names.get(j) + "();");
    }
    output.writeln(deep, "default: throw new IndexOutOfBoundsException();");
    output.writeln(deep, "}");
    output.writeln(deep, "}");

    // write setChildAt
    output.writeln(deep, "public tom.library.sl.Visitable setChildAt(int index, tom.library.sl.Visitable child) {");
    output.writeln(deep, "switch (index) {");
    output.writeln(deep, "case 0: return super.setChildAt(0, child);");
    for (int i = 0; i < stratChildCount; i++) {
      int j = (stratChild.get(i)).intValue();
      output.writeln(deep, "case " + (i+1) + ": " + names.get(j) + " = (" + types.get(j) + ")child; return this;");
    }
    output.writeln(deep, "default: throw new IndexOutOfBoundsException();");
    output.writeln(deep, "}");
    output.writeln(deep, "}");

    generateDeclaration(deep,declaration,moduleName);
    output.writeln(deep,"}");
  }

  protected void buildFunctionDef(int deep, String tomName, BQTermList argList, TomType codomain, TomType throwsType, Instruction instruction, String moduleName) throws IOException {
    buildMethod(deep,tomName,argList,codomain,throwsType,instruction,moduleName,this.modifier);
  }

  protected void buildMethodDef(int deep, String tomName, BQTermList argList, TomType codomain, TomType throwsType, Instruction instruction, String moduleName) throws IOException {
    buildMethod(deep,tomName,argList,codomain,throwsType,instruction,moduleName,"public ");
  }

  private void buildMethod(int deep, String tomName, BQTermList varList, TomType codomain, TomType throwsType, Instruction instruction, String moduleName, String methodModifier) throws IOException {
    output.writeln(deep, "@SuppressWarnings(\"unchecked\")");
    output.write(deep, methodModifier + TomBase.getTLType(codomain) + " " + tomName + "(");
    while(!varList.isEmptyconcBQTerm()) {
      BQTerm localVar = varList.getHeadconcBQTerm();
      matchBlock: {
        {{if ( (((Object)localVar) instanceof tom.engine.adt.code.types.BQTerm) ) {if ( ((( tom.engine.adt.code.types.BQTerm )((Object)localVar)) instanceof tom.engine.adt.code.types.BQTerm) ) {if ( ((( tom.engine.adt.code.types.BQTerm )(( tom.engine.adt.code.types.BQTerm )((Object)localVar))) instanceof tom.engine.adt.code.types.bqterm.BQVariable) ) {

            output.write(deep,TomBase.getTLType( (( tom.engine.adt.code.types.BQTerm )((Object)localVar)).getAstType() ) + " ");
            generateBQTerm(deep,(( tom.engine.adt.code.types.BQTerm )((Object)localVar)),moduleName);
            break matchBlock;
          }}}}{if ( (((Object)localVar) instanceof tom.engine.adt.code.types.BQTerm) ) {

            System.out.println("MakeFunction: strange term: " + localVar);
            throw new TomRuntimeException("MakeFunction: strange term: " + localVar);
          }}}

      }
      varList = varList.getTailconcBQTerm();
      if(!varList.isEmptyconcBQTerm()) {
        output.write(deep,", ");
      }
    }
    output.writeln(deep,")");
matchblock: {
    {{if ( (((Object)throwsType) instanceof tom.engine.adt.tomtype.types.TomType) ) {if ( ((( tom.engine.adt.tomtype.types.TomType )((Object)throwsType)) instanceof tom.engine.adt.tomtype.types.TomType) ) {if ( ((( tom.engine.adt.tomtype.types.TomType )(( tom.engine.adt.tomtype.types.TomType )((Object)throwsType))) instanceof tom.engine.adt.tomtype.types.tomtype.Type) ) { tom.engine.adt.tomtype.types.TargetLanguageType  tomMatch103_1= (( tom.engine.adt.tomtype.types.TomType )((Object)throwsType)).getTlType() ;if ( (tomMatch103_1 instanceof tom.engine.adt.tomtype.types.TargetLanguageType) ) {if ( ((( tom.engine.adt.tomtype.types.TargetLanguageType )tomMatch103_1) instanceof tom.engine.adt.tomtype.types.targetlanguagetype.TLType) ) {

				output.write(deep," throws " +  tomMatch103_1.getString() );
        break matchblock;
			}}}}}}{if ( (((Object)throwsType) instanceof tom.engine.adt.tomtype.types.TomType) ) {if ( ((( tom.engine.adt.tomtype.types.TomType )((Object)throwsType)) instanceof tom.engine.adt.tomtype.types.TomType) ) {if ( ((( tom.engine.adt.tomtype.types.TomType )(( tom.engine.adt.tomtype.types.TomType )((Object)throwsType))) instanceof tom.engine.adt.tomtype.types.tomtype.Type) ) { tom.engine.adt.tomtype.types.TargetLanguageType  tomMatch103_9= (( tom.engine.adt.tomtype.types.TomType )((Object)throwsType)).getTlType() ;if ( (tomMatch103_9 instanceof tom.engine.adt.tomtype.types.TargetLanguageType) ) {if ( ((( tom.engine.adt.tomtype.types.TargetLanguageType )tomMatch103_9) instanceof tom.engine.adt.tomtype.types.targetlanguagetype.EmptyTargetLanguageType) ) {


				output.write(deep," throws " +  (( tom.engine.adt.tomtype.types.TomType )((Object)throwsType)).getTomType() );
        break matchblock;
			}}}}}}}

  }

    output.writeln(" {");
    generateInstruction(deep,instruction,moduleName);
    output.writeln(deep,"}");
  }

}
