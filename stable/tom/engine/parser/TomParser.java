// $ANTLR 2.7.6 (20060516): "TomLanguage.g" -> "TomParser.java"$

/*
 * 
 * TOM - To One Matching Compiler
 * 
 * Copyright (c) 2000-2006, INRIA
 * Nancy, France.
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 * 
 * Pierre-Etienne Moreau  e-mail: Pierre-Etienne.Moreau@loria.fr
 *
 **/

package tom.engine.parser;


import antlr.TokenBuffer;
import antlr.TokenStreamException;
import antlr.TokenStreamIOException;
import antlr.ANTLRException;
import antlr.LLkParser;
import antlr.Token;
import antlr.TokenStream;
import antlr.RecognitionException;
import antlr.NoViableAltException;
import antlr.MismatchedTokenException;
import antlr.SemanticException;
import antlr.ParserSharedInputState;
import antlr.collections.impl.BitSet;

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import tom.engine.TomBase;
import tom.engine.TomMessage;
import tom.engine.adt.tomsignature.types.*;
import tom.engine.exception.TomException;
import tom.engine.tools.SymbolTable;
import tom.engine.tools.ASTFactory;
import tom.engine.xml.Constants;
import tom.platform.OptionManager;
import tom.platform.PlatformLogRecord;
import aterm.*;
import antlr.TokenStreamSelector;

public class TomParser extends antlr.LLkParser       implements TomParserTokenTypes
 {

    //--------------------------
    /* Generated by TOM (version 2.4alpha): Do not edit this file *//* Generated by TOM (version 2.4alpha): Do not edit this file *//*  *  * Copyright (c) 2004-2006, Pierre-Etienne Moreau  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:   *  - Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.    *  - Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in the  *  documentation and/or other materials provided with the distribution.  *  - Neither the name of the INRIA nor the names of its  *  contributors may be used to endorse or promote products derived from  *  this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *   **/  /* Generated by TOM (version 2.4alpha): Do not edit this file *//*  *  * Copyright (c) 2004-2006, Pierre-Etienne Moreau  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:   *  - Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.    *  - Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in the  *  documentation and/or other materials provided with the distribution.  *  - Neither the name of the INRIA nor the names of its  *  contributors may be used to endorse or promote products derived from  *  this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *   **/  private static boolean tom_terms_equal_char( char  t1,  char  t2) {  return  (t1==t2)  ;}private static boolean tom_terms_equal_Character(Object t1, Object t2) {  return  (t1.equals(t2))  ;} private static boolean tom_terms_equal_String( String  t1,  String  t2) {  return  (t1.equals(t2))  ;}  /* Generated by TOM (version 2.4alpha): Do not edit this file *//*  * Copyright (c) 2004-2006, Pierre-Etienne Moreau  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:   *  - Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.    *  - Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in the  *  documentation and/or other materials provided with the distribution.  *  - Neither the name of the INRIA nor the names of its  *  contributors may be used to endorse or promote products derived from  *  this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */ private static boolean tom_terms_equal_int( int  t1,  int  t2) {  return  (t1==t2)  ;} /* Generated by TOM (version 2.4alpha): Do not edit this file *//*  *  * Copyright (c) 2004-2006, Pierre-Etienne Moreau  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:   *  - Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.    *  - Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in the  *  documentation and/or other materials provided with the distribution.  *  - Neither the name of the INRIA nor the names of its  *  contributors may be used to endorse or promote products derived from  *  this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *   **/  private static boolean tom_terms_equal_double( double  t1,  double  t2) {  return  (t1==t2)  ;} /* Generated by TOM (version 2.4alpha): Do not edit this file *//*  *  * Copyright (c) 2004-2006, Pierre-Etienne Moreau  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:   *  - Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.    *  - Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in the  *  documentation and/or other materials provided with the distribution.  *  - Neither the name of the INRIA nor the names of its  *  contributors may be used to endorse or promote products derived from  *  this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *   **/  private static boolean tom_terms_equal_ATerm(Object t1, Object t2) {  return  t1 == t2 ;} /* Generated by TOM (version 2.4alpha): Do not edit this file *//*  *  * Copyright (c) 2004-2006, Pierre-Etienne Moreau  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:   *  - Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.    *  - Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in the  *  documentation and/or other materials provided with the distribution.  *  - Neither the name of the INRIA nor the names of its  *  contributors may be used to endorse or promote products derived from  *  this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *   **/  private static boolean tom_terms_equal_ATermList(Object l1, Object l2) {  return  l1==l2  ;} private static boolean tom_terms_equal_Expression(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_Instruction(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.Instruction tom_make_RawAction( tom.engine.adt.tomsignature.types.Instruction t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeInstruction_RawAction(t0); }private static  tom.engine.adt.tomsignature.types.Instruction tom_make_EqualityCondition( tom.engine.adt.tomsignature.types.TomTerm t0,  tom.engine.adt.tomsignature.types.TomTerm t1) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeInstruction_EqualityCondition(t0, t1); }private static  tom.engine.adt.tomsignature.types.Instruction tom_make_MatchingCondition( tom.engine.adt.tomsignature.types.TomTerm t0,  tom.engine.adt.tomsignature.types.TomTerm t1) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeInstruction_MatchingCondition(t0, t1); }private static  tom.engine.adt.tomsignature.types.Instruction tom_make_Match( tom.engine.adt.tomsignature.types.TomTerm t0,  tom.engine.adt.tomsignature.types.PatternInstructionList t1,  tom.engine.adt.tomsignature.types.OptionList t2) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeInstruction_Match(t0, t1, t2); }private static  tom.engine.adt.tomsignature.types.Instruction tom_make_AbstractBlock( tom.engine.adt.tomsignature.types.InstructionList t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeInstruction_AbstractBlock(t0); }private static  tom.engine.adt.tomsignature.types.Instruction tom_make_Return( tom.engine.adt.tomsignature.types.TomTerm t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeInstruction_Return(t0); }private static  tom.engine.adt.tomsignature.types.Instruction tom_make_TargetLanguageToInstruction( tom.engine.adt.tomsignature.types.TargetLanguage t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeInstruction_TargetLanguageToInstruction(t0); }private static boolean tom_terms_equal_InstructionList(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.InstructionList tom_make_emptyInstructionList() { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeInstructionList(); }private static boolean tom_terms_equal_KeyEntry(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_NameList(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_is_fun_sym_concTomName( tom.engine.adt.tomsignature.types.NameList t) {  return (t!= null) && t.isSortNameList() ;}private static  tom.engine.adt.tomsignature.types.NameList tom_empty_list_concTomName() { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeNameList(); }private static  tom.engine.adt.tomsignature.types.NameList tom_cons_list_concTomName( tom.engine.adt.tomsignature.types.TomName e,  tom.engine.adt.tomsignature.types.NameList l) { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeNameList(e,l); }private static  tom.engine.adt.tomsignature.types.TomName tom_get_head_concTomName_NameList( tom.engine.adt.tomsignature.types.NameList l) {  return l.getHead() ;}private static  tom.engine.adt.tomsignature.types.NameList tom_get_tail_concTomName_NameList( tom.engine.adt.tomsignature.types.NameList l) {  return l.getTail() ;}private static boolean tom_is_empty_concTomName_NameList( tom.engine.adt.tomsignature.types.NameList l) {  return l.isEmpty() ;}private static  tom.engine.adt.tomsignature.types.NameList tom_append_list_concTomName( tom.engine.adt.tomsignature.types.NameList l1,  tom.engine.adt.tomsignature.types.NameList l2) {    if(tom_is_empty_concTomName_NameList(l1)) {     return l2;    } else if(tom_is_empty_concTomName_NameList(l2)) {     return l1;    } else if(tom_is_empty_concTomName_NameList(( tom.engine.adt.tomsignature.types.NameList)tom_get_tail_concTomName_NameList(l1))) {     return ( tom.engine.adt.tomsignature.types.NameList)tom_cons_list_concTomName(( tom.engine.adt.tomsignature.types.TomName)tom_get_head_concTomName_NameList(l1),l2);    } else {      return ( tom.engine.adt.tomsignature.types.NameList)tom_cons_list_concTomName(( tom.engine.adt.tomsignature.types.TomName)tom_get_head_concTomName_NameList(l1),tom_append_list_concTomName(( tom.engine.adt.tomsignature.types.NameList)tom_get_tail_concTomName_NameList(l1),l2));    }   }  private static  tom.engine.adt.tomsignature.types.NameList tom_get_slice_concTomName( tom.engine.adt.tomsignature.types.NameList begin,  tom.engine.adt.tomsignature.types.NameList end) {    if(tom_terms_equal_NameList(begin,end)) {      return ( tom.engine.adt.tomsignature.types.NameList)tom_empty_list_concTomName();    } else {      return ( tom.engine.adt.tomsignature.types.NameList)tom_cons_list_concTomName(( tom.engine.adt.tomsignature.types.TomName)tom_get_head_concTomName_NameList(begin),( tom.engine.adt.tomsignature.types.NameList)tom_get_slice_concTomName(( tom.engine.adt.tomsignature.types.NameList)tom_get_tail_concTomName_NameList(begin),end));    }   }  private static  tom.engine.adt.tomsignature.types.NameList tom_make_emptyNameList() { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeNameList(); }private static boolean tom_terms_equal_SymbolList(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_TomEntryList(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_TomVisitList(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.TomVisitList tom_make_emptyTomVisitList() { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomVisitList(); }private static boolean tom_terms_equal_TomRuleList(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.TomRuleList tom_make_emptyTomRuleList() { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomRuleList(); }private static boolean tom_terms_equal_TomStructureTable(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_TomEntry(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_TomSymbolTable(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_TomSymbol(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_TomVisit(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.TomVisit tom_make_VisitTerm( tom.engine.adt.tomsignature.types.TomType t0,  tom.engine.adt.tomsignature.types.PatternInstructionList t1,  tom.engine.adt.tomsignature.types.OptionList t2) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomVisit_VisitTerm(t0, t1, t2); }private static boolean tom_terms_equal_TomRule(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.TomRule tom_make_RewriteRule( tom.engine.adt.tomsignature.types.TomTerm t0,  tom.engine.adt.tomsignature.types.TomTerm t1,  tom.engine.adt.tomsignature.types.InstructionList t2,  tom.engine.adt.tomsignature.types.OptionList t3) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomRule_RewriteRule(t0, t1, t2, t3); }private static boolean tom_terms_equal_Position(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_TargetLanguage(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.TargetLanguage tom_make_ITL( String  t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTargetLanguage_ITL(t0); }private static boolean tom_terms_equal_TomNumberList(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_TomNumber(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_TomName(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.TomName tom_make_EmptyName() { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomName_EmptyName(); }private static  tom.engine.adt.tomsignature.types.TomName tom_make_Name( String  t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomName_Name(t0); }private static boolean tom_terms_equal_SlotList(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_Slot(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.Slot tom_make_PairSlotAppl( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.TomTerm t1) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeSlot_PairSlotAppl(t0, t1); }private static boolean tom_terms_equal_PairNameDeclList(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_is_fun_sym_concPairNameDecl( tom.engine.adt.tomsignature.types.PairNameDeclList t) {  return (t!= null) && t.isSortPairNameDeclList() ;}private static  tom.engine.adt.tomsignature.types.PairNameDeclList tom_empty_list_concPairNameDecl() { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makePairNameDeclList(); }private static  tom.engine.adt.tomsignature.types.PairNameDeclList tom_cons_list_concPairNameDecl( tom.engine.adt.tomsignature.types.PairNameDecl e,  tom.engine.adt.tomsignature.types.PairNameDeclList l) { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makePairNameDeclList(e,l); }private static  tom.engine.adt.tomsignature.types.PairNameDecl tom_get_head_concPairNameDecl_PairNameDeclList( tom.engine.adt.tomsignature.types.PairNameDeclList l) {  return l.getHead() ;}private static  tom.engine.adt.tomsignature.types.PairNameDeclList tom_get_tail_concPairNameDecl_PairNameDeclList( tom.engine.adt.tomsignature.types.PairNameDeclList l) {  return l.getTail() ;}private static boolean tom_is_empty_concPairNameDecl_PairNameDeclList( tom.engine.adt.tomsignature.types.PairNameDeclList l) {  return l.isEmpty() ;}private static  tom.engine.adt.tomsignature.types.PairNameDeclList tom_append_list_concPairNameDecl( tom.engine.adt.tomsignature.types.PairNameDeclList l1,  tom.engine.adt.tomsignature.types.PairNameDeclList l2) {    if(tom_is_empty_concPairNameDecl_PairNameDeclList(l1)) {     return l2;    } else if(tom_is_empty_concPairNameDecl_PairNameDeclList(l2)) {     return l1;    } else if(tom_is_empty_concPairNameDecl_PairNameDeclList(( tom.engine.adt.tomsignature.types.PairNameDeclList)tom_get_tail_concPairNameDecl_PairNameDeclList(l1))) {     return ( tom.engine.adt.tomsignature.types.PairNameDeclList)tom_cons_list_concPairNameDecl(( tom.engine.adt.tomsignature.types.PairNameDecl)tom_get_head_concPairNameDecl_PairNameDeclList(l1),l2);    } else {      return ( tom.engine.adt.tomsignature.types.PairNameDeclList)tom_cons_list_concPairNameDecl(( tom.engine.adt.tomsignature.types.PairNameDecl)tom_get_head_concPairNameDecl_PairNameDeclList(l1),tom_append_list_concPairNameDecl(( tom.engine.adt.tomsignature.types.PairNameDeclList)tom_get_tail_concPairNameDecl_PairNameDeclList(l1),l2));    }   }  private static  tom.engine.adt.tomsignature.types.PairNameDeclList tom_get_slice_concPairNameDecl( tom.engine.adt.tomsignature.types.PairNameDeclList begin,  tom.engine.adt.tomsignature.types.PairNameDeclList end) {    if(tom_terms_equal_PairNameDeclList(begin,end)) {      return ( tom.engine.adt.tomsignature.types.PairNameDeclList)tom_empty_list_concPairNameDecl();    } else {      return ( tom.engine.adt.tomsignature.types.PairNameDeclList)tom_cons_list_concPairNameDecl(( tom.engine.adt.tomsignature.types.PairNameDecl)tom_get_head_concPairNameDecl_PairNameDeclList(begin),( tom.engine.adt.tomsignature.types.PairNameDeclList)tom_get_slice_concPairNameDecl(( tom.engine.adt.tomsignature.types.PairNameDeclList)tom_get_tail_concPairNameDecl_PairNameDeclList(begin),end));    }   }  private static boolean tom_terms_equal_PairNameDecl(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_is_fun_sym_PairNameDecl( tom.engine.adt.tomsignature.types.PairNameDecl t) {  return  (t!= null) && t.isPairNameDecl() ;}private static  tom.engine.adt.tomsignature.types.PairNameDecl tom_make_PairNameDecl( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.Declaration t1) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makePairNameDecl_PairNameDecl(t0, t1); }private static  tom.engine.adt.tomsignature.types.TomName tom_get_slot_PairNameDecl_slotName( tom.engine.adt.tomsignature.types.PairNameDecl t) {  return  t.getSlotName() ;}private static  tom.engine.adt.tomsignature.types.Declaration tom_get_slot_PairNameDecl_slotDecl( tom.engine.adt.tomsignature.types.PairNameDecl t) {  return  t.getSlotDecl() ;}private static boolean tom_terms_equal_ConstraintList(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.ConstraintList tom_empty_list_concConstraint() { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeConstraintList(); }private static  tom.engine.adt.tomsignature.types.ConstraintList tom_cons_list_concConstraint( tom.engine.adt.tomsignature.types.Constraint e,  tom.engine.adt.tomsignature.types.ConstraintList l) { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeConstraintList(e,l); }private static  tom.engine.adt.tomsignature.types.Constraint tom_get_head_concConstraint_ConstraintList( tom.engine.adt.tomsignature.types.ConstraintList l) {  return l.getHead() ;}private static  tom.engine.adt.tomsignature.types.ConstraintList tom_get_tail_concConstraint_ConstraintList( tom.engine.adt.tomsignature.types.ConstraintList l) {  return l.getTail() ;}private static boolean tom_is_empty_concConstraint_ConstraintList( tom.engine.adt.tomsignature.types.ConstraintList l) {  return l.isEmpty() ;}private static  tom.engine.adt.tomsignature.types.ConstraintList tom_append_list_concConstraint( tom.engine.adt.tomsignature.types.ConstraintList l1,  tom.engine.adt.tomsignature.types.ConstraintList l2) {    if(tom_is_empty_concConstraint_ConstraintList(l1)) {     return l2;    } else if(tom_is_empty_concConstraint_ConstraintList(l2)) {     return l1;    } else if(tom_is_empty_concConstraint_ConstraintList(( tom.engine.adt.tomsignature.types.ConstraintList)tom_get_tail_concConstraint_ConstraintList(l1))) {     return ( tom.engine.adt.tomsignature.types.ConstraintList)tom_cons_list_concConstraint(( tom.engine.adt.tomsignature.types.Constraint)tom_get_head_concConstraint_ConstraintList(l1),l2);    } else {      return ( tom.engine.adt.tomsignature.types.ConstraintList)tom_cons_list_concConstraint(( tom.engine.adt.tomsignature.types.Constraint)tom_get_head_concConstraint_ConstraintList(l1),tom_append_list_concConstraint(( tom.engine.adt.tomsignature.types.ConstraintList)tom_get_tail_concConstraint_ConstraintList(l1),l2));    }   }  private static  tom.engine.adt.tomsignature.types.ConstraintList tom_get_slice_concConstraint( tom.engine.adt.tomsignature.types.ConstraintList begin,  tom.engine.adt.tomsignature.types.ConstraintList end) {    if(tom_terms_equal_ConstraintList(begin,end)) {      return ( tom.engine.adt.tomsignature.types.ConstraintList)tom_empty_list_concConstraint();    } else {      return ( tom.engine.adt.tomsignature.types.ConstraintList)tom_cons_list_concConstraint(( tom.engine.adt.tomsignature.types.Constraint)tom_get_head_concConstraint_ConstraintList(begin),( tom.engine.adt.tomsignature.types.ConstraintList)tom_get_slice_concConstraint(( tom.engine.adt.tomsignature.types.ConstraintList)tom_get_tail_concConstraint_ConstraintList(begin),end));    }   }  private static  tom.engine.adt.tomsignature.types.ConstraintList tom_make_emptyConstraintList() { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeConstraintList(); }private static boolean tom_terms_equal_Constraint(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_OptionList(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_is_fun_sym_concOption( tom.engine.adt.tomsignature.types.OptionList t) {  return (t!= null) && t.isSortOptionList() ;}private static  tom.engine.adt.tomsignature.types.OptionList tom_empty_list_concOption() { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeOptionList(); }private static  tom.engine.adt.tomsignature.types.OptionList tom_cons_list_concOption( tom.engine.adt.tomsignature.types.Option e,  tom.engine.adt.tomsignature.types.OptionList l) { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeOptionList(e,l); }private static  tom.engine.adt.tomsignature.types.Option tom_get_head_concOption_OptionList( tom.engine.adt.tomsignature.types.OptionList l) {  return l.getHead() ;}private static  tom.engine.adt.tomsignature.types.OptionList tom_get_tail_concOption_OptionList( tom.engine.adt.tomsignature.types.OptionList l) {  return l.getTail() ;}private static boolean tom_is_empty_concOption_OptionList( tom.engine.adt.tomsignature.types.OptionList l) {  return l.isEmpty() ;}private static  tom.engine.adt.tomsignature.types.OptionList tom_append_list_concOption( tom.engine.adt.tomsignature.types.OptionList l1,  tom.engine.adt.tomsignature.types.OptionList l2) {    if(tom_is_empty_concOption_OptionList(l1)) {     return l2;    } else if(tom_is_empty_concOption_OptionList(l2)) {     return l1;    } else if(tom_is_empty_concOption_OptionList(( tom.engine.adt.tomsignature.types.OptionList)tom_get_tail_concOption_OptionList(l1))) {     return ( tom.engine.adt.tomsignature.types.OptionList)tom_cons_list_concOption(( tom.engine.adt.tomsignature.types.Option)tom_get_head_concOption_OptionList(l1),l2);    } else {      return ( tom.engine.adt.tomsignature.types.OptionList)tom_cons_list_concOption(( tom.engine.adt.tomsignature.types.Option)tom_get_head_concOption_OptionList(l1),tom_append_list_concOption(( tom.engine.adt.tomsignature.types.OptionList)tom_get_tail_concOption_OptionList(l1),l2));    }   }  private static  tom.engine.adt.tomsignature.types.OptionList tom_get_slice_concOption( tom.engine.adt.tomsignature.types.OptionList begin,  tom.engine.adt.tomsignature.types.OptionList end) {    if(tom_terms_equal_OptionList(begin,end)) {      return ( tom.engine.adt.tomsignature.types.OptionList)tom_empty_list_concOption();    } else {      return ( tom.engine.adt.tomsignature.types.OptionList)tom_cons_list_concOption(( tom.engine.adt.tomsignature.types.Option)tom_get_head_concOption_OptionList(begin),( tom.engine.adt.tomsignature.types.OptionList)tom_get_slice_concOption(( tom.engine.adt.tomsignature.types.OptionList)tom_get_tail_concOption_OptionList(begin),end));    }   }  private static  tom.engine.adt.tomsignature.types.OptionList tom_make_emptyOptionList() { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeOptionList(); }private static boolean tom_terms_equal_Option(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.Option tom_make_ImplicitXMLChild() { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeOption_ImplicitXMLChild(); }private static  tom.engine.adt.tomsignature.types.Option tom_make_ImplicitXMLAttribut() { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeOption_ImplicitXMLAttribut(); }private static  tom.engine.adt.tomsignature.types.Option tom_make_ModuleName( String  t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeOption_ModuleName(t0); }private static  tom.engine.adt.tomsignature.types.Option tom_make_Label( tom.engine.adt.tomsignature.types.TomName t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeOption_Label(t0); }private static  tom.engine.adt.tomsignature.types.Option tom_make_Constant() { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeOption_Constant(); }private static  tom.engine.adt.tomsignature.types.Option tom_make_OriginalText( tom.engine.adt.tomsignature.types.TomName t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeOption_OriginalText(t0); }private static  tom.engine.adt.tomsignature.types.Option tom_make_OriginTracking( tom.engine.adt.tomsignature.types.TomName t0,  int  t1,  String  t2) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeOption_OriginTracking(t0, t1, t2); }private static boolean tom_terms_equal_TomTypeList(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.TomTypeList tom_make_emptyTomTypeList() { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomTypeList(); }private static boolean tom_terms_equal_TomTypeDefinition(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_TomForwardType(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.TomForwardType tom_make_EmptyForward() { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomForwardType_EmptyForward(); }private static  tom.engine.adt.tomsignature.types.TomForwardType tom_make_TLForward( String  t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomForwardType_TLForward(t0); }private static boolean tom_terms_equal_TomType(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.TomType tom_make_EmptyType() { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomType_EmptyType(); }private static  tom.engine.adt.tomsignature.types.TomType tom_make_TLType( tom.engine.adt.tomsignature.types.TargetLanguage t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomType_TLType(t0); }private static  tom.engine.adt.tomsignature.types.TomType tom_make_ASTTomType( String  t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomType_ASTTomType(t0); }private static  tom.engine.adt.tomsignature.types.TomType tom_make_Codomain( tom.engine.adt.tomsignature.types.TomName t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomType_Codomain(t0); }private static  tom.engine.adt.tomsignature.types.TomType tom_make_TomTypeAlone( String  t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomType_TomTypeAlone(t0); }private static  tom.engine.adt.tomsignature.types.TomType tom_make_Type( tom.engine.adt.tomsignature.types.TomType t0,  tom.engine.adt.tomsignature.types.TomType t1) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomType_Type(t0, t1); }private static boolean tom_terms_equal_TomList(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_is_fun_sym_concTomTerm( tom.engine.adt.tomsignature.types.TomList t) {  return (t!= null) && t.isSortTomList() ;}private static  tom.engine.adt.tomsignature.types.TomList tom_empty_list_concTomTerm() { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomList(); }private static  tom.engine.adt.tomsignature.types.TomList tom_cons_list_concTomTerm( tom.engine.adt.tomsignature.types.TomTerm e,  tom.engine.adt.tomsignature.types.TomList l) { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomList(e,l); }private static  tom.engine.adt.tomsignature.types.TomTerm tom_get_head_concTomTerm_TomList( tom.engine.adt.tomsignature.types.TomList l) {  return l.getHead() ;}private static  tom.engine.adt.tomsignature.types.TomList tom_get_tail_concTomTerm_TomList( tom.engine.adt.tomsignature.types.TomList l) {  return l.getTail() ;}private static boolean tom_is_empty_concTomTerm_TomList( tom.engine.adt.tomsignature.types.TomList l) {  return l.isEmpty() ;}private static  tom.engine.adt.tomsignature.types.TomList tom_append_list_concTomTerm( tom.engine.adt.tomsignature.types.TomList l1,  tom.engine.adt.tomsignature.types.TomList l2) {    if(tom_is_empty_concTomTerm_TomList(l1)) {     return l2;    } else if(tom_is_empty_concTomTerm_TomList(l2)) {     return l1;    } else if(tom_is_empty_concTomTerm_TomList(( tom.engine.adt.tomsignature.types.TomList)tom_get_tail_concTomTerm_TomList(l1))) {     return ( tom.engine.adt.tomsignature.types.TomList)tom_cons_list_concTomTerm(( tom.engine.adt.tomsignature.types.TomTerm)tom_get_head_concTomTerm_TomList(l1),l2);    } else {      return ( tom.engine.adt.tomsignature.types.TomList)tom_cons_list_concTomTerm(( tom.engine.adt.tomsignature.types.TomTerm)tom_get_head_concTomTerm_TomList(l1),tom_append_list_concTomTerm(( tom.engine.adt.tomsignature.types.TomList)tom_get_tail_concTomTerm_TomList(l1),l2));    }   }  private static  tom.engine.adt.tomsignature.types.TomList tom_get_slice_concTomTerm( tom.engine.adt.tomsignature.types.TomList begin,  tom.engine.adt.tomsignature.types.TomList end) {    if(tom_terms_equal_TomList(begin,end)) {      return ( tom.engine.adt.tomsignature.types.TomList)tom_empty_list_concTomTerm();    } else {      return ( tom.engine.adt.tomsignature.types.TomList)tom_cons_list_concTomTerm(( tom.engine.adt.tomsignature.types.TomTerm)tom_get_head_concTomTerm_TomList(begin),( tom.engine.adt.tomsignature.types.TomList)tom_get_slice_concTomTerm(( tom.engine.adt.tomsignature.types.TomList)tom_get_tail_concTomTerm_TomList(begin),end));    }   }  private static  tom.engine.adt.tomsignature.types.TomList tom_make_emptyTomList() { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomList(); }private static boolean tom_terms_equal_PatternList(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_PatternInstructionList(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_terms_equal_Pattern(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.Pattern tom_make_Pattern( tom.engine.adt.tomsignature.types.TomList t0,  tom.engine.adt.tomsignature.types.TomList t1,  tom.engine.adt.tomsignature.types.TomList t2) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makePattern_Pattern(t0, t1, t2); }private static boolean tom_terms_equal_PatternInstruction(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.PatternInstruction tom_make_PatternInstruction( tom.engine.adt.tomsignature.types.Pattern t0,  tom.engine.adt.tomsignature.types.Instruction t1,  tom.engine.adt.tomsignature.types.OptionList t2) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makePatternInstruction_PatternInstruction(t0, t1, t2); }private static boolean tom_terms_equal_TomTerm(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.TomTerm tom_make_TLVar( String  t0,  tom.engine.adt.tomsignature.types.TomType t1) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomTerm_TLVar(t0, t1); }private static  tom.engine.adt.tomsignature.types.TomTerm tom_make_Term( tom.engine.adt.tomsignature.types.TomTerm t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomTerm_Term(t0); }private static  tom.engine.adt.tomsignature.types.TomTerm tom_make_SubjectList( tom.engine.adt.tomsignature.types.TomList t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomTerm_SubjectList(t0); }private static boolean tom_is_fun_sym_Composite( tom.engine.adt.tomsignature.types.TomTerm t) {  return  (t!= null) && t.isComposite() ;}private static  tom.engine.adt.tomsignature.types.TomList tom_get_slot_Composite_args( tom.engine.adt.tomsignature.types.TomTerm t) {  return  t.getArgs() ;}private static boolean tom_is_fun_sym_BackQuoteAppl( tom.engine.adt.tomsignature.types.TomTerm t) {  return  (t!= null) && t.isBackQuoteAppl() ;}private static  tom.engine.adt.tomsignature.types.OptionList tom_get_slot_BackQuoteAppl_option( tom.engine.adt.tomsignature.types.TomTerm t) {  return  t.getOption() ;}private static  tom.engine.adt.tomsignature.types.TomName tom_get_slot_BackQuoteAppl_astName( tom.engine.adt.tomsignature.types.TomTerm t) {  return  t.getAstName() ;}private static  tom.engine.adt.tomsignature.types.TomList tom_get_slot_BackQuoteAppl_args( tom.engine.adt.tomsignature.types.TomTerm t) {  return  t.getArgs() ;}private static  tom.engine.adt.tomsignature.types.TomTerm tom_make_TomTypeToTomTerm( tom.engine.adt.tomsignature.types.TomType t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomTerm_TomTypeToTomTerm(t0); }private static  tom.engine.adt.tomsignature.types.TomTerm tom_make_TargetLanguageToTomTerm( tom.engine.adt.tomsignature.types.TargetLanguage t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomTerm_TargetLanguageToTomTerm(t0); }private static  tom.engine.adt.tomsignature.types.TomTerm tom_make_UnamedVariableStar( tom.engine.adt.tomsignature.types.OptionList t0,  tom.engine.adt.tomsignature.types.TomType t1,  tom.engine.adt.tomsignature.types.ConstraintList t2) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomTerm_UnamedVariableStar(t0, t1, t2); }private static  tom.engine.adt.tomsignature.types.TomTerm tom_make_UnamedVariable( tom.engine.adt.tomsignature.types.OptionList t0,  tom.engine.adt.tomsignature.types.TomType t1,  tom.engine.adt.tomsignature.types.ConstraintList t2) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomTerm_UnamedVariable(t0, t1, t2); }private static  tom.engine.adt.tomsignature.types.TomTerm tom_make_Placeholder( tom.engine.adt.tomsignature.types.OptionList t0,  tom.engine.adt.tomsignature.types.ConstraintList t1) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomTerm_Placeholder(t0, t1); }private static  tom.engine.adt.tomsignature.types.TomTerm tom_make_VariableStar( tom.engine.adt.tomsignature.types.OptionList t0,  tom.engine.adt.tomsignature.types.TomName t1,  tom.engine.adt.tomsignature.types.TomType t2,  tom.engine.adt.tomsignature.types.ConstraintList t3) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomTerm_VariableStar(t0, t1, t2, t3); }private static  tom.engine.adt.tomsignature.types.TomTerm tom_make_Variable( tom.engine.adt.tomsignature.types.OptionList t0,  tom.engine.adt.tomsignature.types.TomName t1,  tom.engine.adt.tomsignature.types.TomType t2,  tom.engine.adt.tomsignature.types.ConstraintList t3) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomTerm_Variable(t0, t1, t2, t3); }private static  tom.engine.adt.tomsignature.types.TomTerm tom_make_XMLAppl( tom.engine.adt.tomsignature.types.OptionList t0,  tom.engine.adt.tomsignature.types.NameList t1,  tom.engine.adt.tomsignature.types.TomList t2,  tom.engine.adt.tomsignature.types.TomList t3,  tom.engine.adt.tomsignature.types.ConstraintList t4) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomTerm_XMLAppl(t0, t1, t2, t3, t4); }private static  tom.engine.adt.tomsignature.types.TomTerm tom_make_RecordAppl( tom.engine.adt.tomsignature.types.OptionList t0,  tom.engine.adt.tomsignature.types.NameList t1,  tom.engine.adt.tomsignature.types.SlotList t2,  tom.engine.adt.tomsignature.types.ConstraintList t3) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomTerm_RecordAppl(t0, t1, t2, t3); }private static  tom.engine.adt.tomsignature.types.TomTerm tom_make_TermAppl( tom.engine.adt.tomsignature.types.OptionList t0,  tom.engine.adt.tomsignature.types.NameList t1,  tom.engine.adt.tomsignature.types.TomList t2,  tom.engine.adt.tomsignature.types.ConstraintList t3) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeTomTerm_TermAppl(t0, t1, t2, t3); }private static boolean tom_terms_equal_DeclarationList(Object t1, Object t2) {  return t1.equals(t2) ;}private static boolean tom_is_fun_sym_concDeclaration( tom.engine.adt.tomsignature.types.DeclarationList t) {  return (t!= null) && t.isSortDeclarationList() ;}private static  tom.engine.adt.tomsignature.types.DeclarationList tom_empty_list_concDeclaration() { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclarationList(); }private static  tom.engine.adt.tomsignature.types.DeclarationList tom_cons_list_concDeclaration( tom.engine.adt.tomsignature.types.Declaration e,  tom.engine.adt.tomsignature.types.DeclarationList l) { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclarationList(e,l); }private static  tom.engine.adt.tomsignature.types.Declaration tom_get_head_concDeclaration_DeclarationList( tom.engine.adt.tomsignature.types.DeclarationList l) {  return l.getHead() ;}private static  tom.engine.adt.tomsignature.types.DeclarationList tom_get_tail_concDeclaration_DeclarationList( tom.engine.adt.tomsignature.types.DeclarationList l) {  return l.getTail() ;}private static boolean tom_is_empty_concDeclaration_DeclarationList( tom.engine.adt.tomsignature.types.DeclarationList l) {  return l.isEmpty() ;}private static  tom.engine.adt.tomsignature.types.DeclarationList tom_append_list_concDeclaration( tom.engine.adt.tomsignature.types.DeclarationList l1,  tom.engine.adt.tomsignature.types.DeclarationList l2) {    if(tom_is_empty_concDeclaration_DeclarationList(l1)) {     return l2;    } else if(tom_is_empty_concDeclaration_DeclarationList(l2)) {     return l1;    } else if(tom_is_empty_concDeclaration_DeclarationList(( tom.engine.adt.tomsignature.types.DeclarationList)tom_get_tail_concDeclaration_DeclarationList(l1))) {     return ( tom.engine.adt.tomsignature.types.DeclarationList)tom_cons_list_concDeclaration(( tom.engine.adt.tomsignature.types.Declaration)tom_get_head_concDeclaration_DeclarationList(l1),l2);    } else {      return ( tom.engine.adt.tomsignature.types.DeclarationList)tom_cons_list_concDeclaration(( tom.engine.adt.tomsignature.types.Declaration)tom_get_head_concDeclaration_DeclarationList(l1),tom_append_list_concDeclaration(( tom.engine.adt.tomsignature.types.DeclarationList)tom_get_tail_concDeclaration_DeclarationList(l1),l2));    }   }  private static  tom.engine.adt.tomsignature.types.DeclarationList tom_get_slice_concDeclaration( tom.engine.adt.tomsignature.types.DeclarationList begin,  tom.engine.adt.tomsignature.types.DeclarationList end) {    if(tom_terms_equal_DeclarationList(begin,end)) {      return ( tom.engine.adt.tomsignature.types.DeclarationList)tom_empty_list_concDeclaration();    } else {      return ( tom.engine.adt.tomsignature.types.DeclarationList)tom_cons_list_concDeclaration(( tom.engine.adt.tomsignature.types.Declaration)tom_get_head_concDeclaration_DeclarationList(begin),( tom.engine.adt.tomsignature.types.DeclarationList)tom_get_slice_concDeclaration(( tom.engine.adt.tomsignature.types.DeclarationList)tom_get_tail_concDeclaration_DeclarationList(begin),end));    }   }  private static  tom.engine.adt.tomsignature.types.DeclarationList tom_make_emptyDeclarationList() { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclarationList(); }private static  tom.engine.adt.tomsignature.types.DeclarationList tom_make_manyDeclarationList( tom.engine.adt.tomsignature.types.Declaration e,  tom.engine.adt.tomsignature.types.DeclarationList l) { return tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclarationList(e,l); }private static boolean tom_terms_equal_Declaration(Object t1, Object t2) {  return t1.equals(t2) ;}private static  tom.engine.adt.tomsignature.types.Declaration tom_make_AbstractDecl( tom.engine.adt.tomsignature.types.DeclarationList t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_AbstractDecl(t0); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_EmptyDeclaration() { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_EmptyDeclaration(); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_ArraySymbolDecl( tom.engine.adt.tomsignature.types.TomName t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_ArraySymbolDecl(t0); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_ListSymbolDecl( tom.engine.adt.tomsignature.types.TomName t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_ListSymbolDecl(t0); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_SymbolDecl( tom.engine.adt.tomsignature.types.TomName t0) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_SymbolDecl(t0); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_RuleSet( tom.engine.adt.tomsignature.types.TomRuleList t0,  tom.engine.adt.tomsignature.types.OptionList t1) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_RuleSet(t0, t1); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_Strategy( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.TomTerm t1,  tom.engine.adt.tomsignature.types.TomVisitList t2,  tom.engine.adt.tomsignature.types.Option t3) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_Strategy(t0, t1, t2, t3); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_MakeDecl( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.TomType t1,  tom.engine.adt.tomsignature.types.TomList t2,  tom.engine.adt.tomsignature.types.Instruction t3,  tom.engine.adt.tomsignature.types.Option t4) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_MakeDecl(t0, t1, t2, t3, t4); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_MakeAddArray( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.TomTerm t1,  tom.engine.adt.tomsignature.types.TomTerm t2,  tom.engine.adt.tomsignature.types.Instruction t3,  tom.engine.adt.tomsignature.types.Option t4) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_MakeAddArray(t0, t1, t2, t3, t4); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_MakeEmptyArray( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.TomTerm t1,  tom.engine.adt.tomsignature.types.Instruction t2,  tom.engine.adt.tomsignature.types.Option t3) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_MakeEmptyArray(t0, t1, t2, t3); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_GetSizeDecl( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.TomTerm t1,  tom.engine.adt.tomsignature.types.Instruction t2,  tom.engine.adt.tomsignature.types.Option t3) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_GetSizeDecl(t0, t1, t2, t3); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_GetElementDecl( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.TomTerm t1,  tom.engine.adt.tomsignature.types.TomTerm t2,  tom.engine.adt.tomsignature.types.Instruction t3,  tom.engine.adt.tomsignature.types.Option t4) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_GetElementDecl(t0, t1, t2, t3, t4); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_MakeAddList( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.TomTerm t1,  tom.engine.adt.tomsignature.types.TomTerm t2,  tom.engine.adt.tomsignature.types.Instruction t3,  tom.engine.adt.tomsignature.types.Option t4) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_MakeAddList(t0, t1, t2, t3, t4); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_MakeEmptyList( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.Instruction t1,  tom.engine.adt.tomsignature.types.Option t2) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_MakeEmptyList(t0, t1, t2); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_IsEmptyDecl( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.TomTerm t1,  tom.engine.adt.tomsignature.types.Instruction t2,  tom.engine.adt.tomsignature.types.Option t3) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_IsEmptyDecl(t0, t1, t2, t3); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_GetTailDecl( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.TomTerm t1,  tom.engine.adt.tomsignature.types.Instruction t2,  tom.engine.adt.tomsignature.types.Option t3) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_GetTailDecl(t0, t1, t2, t3); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_GetHeadDecl( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.TomType t1,  tom.engine.adt.tomsignature.types.TomTerm t2,  tom.engine.adt.tomsignature.types.Instruction t3,  tom.engine.adt.tomsignature.types.Option t4) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_GetHeadDecl(t0, t1, t2, t3, t4); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_TermsEqualDecl( tom.engine.adt.tomsignature.types.TomTerm t0,  tom.engine.adt.tomsignature.types.TomTerm t1,  tom.engine.adt.tomsignature.types.Instruction t2,  tom.engine.adt.tomsignature.types.Option t3) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_TermsEqualDecl(t0, t1, t2, t3); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_GetSlotDecl( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.TomName t1,  tom.engine.adt.tomsignature.types.TomTerm t2,  tom.engine.adt.tomsignature.types.Instruction t3,  tom.engine.adt.tomsignature.types.Option t4) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_GetSlotDecl(t0, t1, t2, t3, t4); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_IsFsymDecl( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.TomTerm t1,  tom.engine.adt.tomsignature.types.Instruction t2,  tom.engine.adt.tomsignature.types.Option t3) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_IsFsymDecl(t0, t1, t2, t3); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_GetImplementationDecl( tom.engine.adt.tomsignature.types.TomTerm t0,  tom.engine.adt.tomsignature.types.Instruction t1,  tom.engine.adt.tomsignature.types.Option t2) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_GetImplementationDecl(t0, t1, t2); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_SetStampDecl( tom.engine.adt.tomsignature.types.TomTerm t0,  tom.engine.adt.tomsignature.types.Instruction t1,  tom.engine.adt.tomsignature.types.Option t2) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_SetStampDecl(t0, t1, t2); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_CheckStampDecl( tom.engine.adt.tomsignature.types.TomTerm t0,  tom.engine.adt.tomsignature.types.Instruction t1,  tom.engine.adt.tomsignature.types.Option t2) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_CheckStampDecl(t0, t1, t2); }private static  tom.engine.adt.tomsignature.types.Declaration tom_make_TypeTermDecl( tom.engine.adt.tomsignature.types.TomName t0,  tom.engine.adt.tomsignature.types.DeclarationList t1,  tom.engine.adt.tomsignature.types.Option t2) { return  tom.engine.adt.tomsignature.TomSignatureFactory.getInstance(aterm.pure.SingletonFactory.getInstance()).makeDeclaration_TypeTermDecl(t0, t1, t2); }  
    //--------------------------
        
    public String currentFile(){
        return targetparser.getCurrentFile();
    }

    // the default-mode parser
    private HostParser targetparser;
    protected BackQuoteParser bqparser;
    private TomLexer tomlexer;

    //store information for the OriginalText contained in the OptionList
    private StringBuffer text = new StringBuffer();
    
    private int lastLine; 

    private SymbolTable symbolTable;

    public TomParser(ParserSharedInputState state, HostParser target,
                     OptionManager optionManager){
        this(state);
        this.targetparser = target;
        this.bqparser = new BackQuoteParser(state,this);
        this.tomlexer = (TomLexer) selector().getStream("tomlexer");
        this.symbolTable = target.getSymbolTable();
    }
    
    private void putTypeDefinition(String name, TomType type, TomForwardType forward) {
        symbolTable.putTypeDefinition(name,type,forward);
    }

    private void putSymbol(String name, TomSymbol symbol) {
        symbolTable.putSymbol(name,symbol);
    }
    
    private int getLine(){
        return tomlexer.getLine();
    }

    public void updatePosition(int i, int j){
        targetparser.updatePosition(i,j);
    }
    
    public void addTargetCode(Token t){
        targetparser.addTargetCode(t);
    }

    private void setLastLine(int line){
        lastLine = line;
    }

    private void clearText(){
        text.delete(0,text.length());
    }

    protected TokenStreamSelector selector(){
        return targetparser.getSelector();
    }
    
    private Logger getLogger() {
      return Logger.getLogger(getClass().getName());
    }


protected TomParser(TokenBuffer tokenBuf, int k) {
  super(tokenBuf,k);
  tokenNames = _tokenNames;
}

public TomParser(TokenBuffer tokenBuf) {
  this(tokenBuf,1);
}

protected TomParser(TokenStream lexer, int k) {
  super(lexer,k);
  tokenNames = _tokenNames;
}

public TomParser(TokenStream lexer) {
  this(lexer,1);
}

public TomParser(ParserSharedInputState state) {
  super(state,1);
  tokenNames = _tokenNames;
}

	public final Token  constant() throws RecognitionException, TokenStreamException {
		Token result;
		
		Token  t1 = null;
		Token  t2 = null;
		Token  t3 = null;
		Token  t4 = null;
		Token  t5 = null;
		Token  t6 = null;
		
		result = null;
		
		
		{
		switch ( LA(1)) {
		case NUM_INT:
		{
			t1 = LT(1);
			match(NUM_INT);
			if ( inputState.guessing==0 ) {
				result = t1;
			}
			break;
		}
		case CHARACTER:
		{
			t2 = LT(1);
			match(CHARACTER);
			if ( inputState.guessing==0 ) {
				result = t2;
			}
			break;
		}
		case STRING:
		{
			t3 = LT(1);
			match(STRING);
			if ( inputState.guessing==0 ) {
				result = t3;
			}
			break;
		}
		case NUM_FLOAT:
		{
			t4 = LT(1);
			match(NUM_FLOAT);
			if ( inputState.guessing==0 ) {
				result = t4;
			}
			break;
		}
		case NUM_LONG:
		{
			t5 = LT(1);
			match(NUM_LONG);
			if ( inputState.guessing==0 ) {
				result = t5;
			}
			break;
		}
		case NUM_DOUBLE:
		{
			t6 = LT(1);
			match(NUM_DOUBLE);
			if ( inputState.guessing==0 ) {
				result = t6;
			}
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		return result;
	}
	
	public final Instruction  matchConstruct(
		Option ot
	) throws RecognitionException, TokenStreamException, TomException {
		Instruction result;
		
		Token  t = null;
		
		result = null;
		OptionList optionList = tom_cons_list_concOption(ot,tom_cons_list_concOption(tom_make_ModuleName(TomBase.DEFAULT_MODULE_NAME),tom_empty_list_concOption()));
		LinkedList argumentList = new LinkedList();
		LinkedList patternInstructionList = new LinkedList();
		TomList subjectList = null;
		
		
		{
		match(LPAREN);
		matchArguments(argumentList);
		match(RPAREN);
		match(LBRACE);
		if ( inputState.guessing==0 ) {
			subjectList = ASTFactory.makeList(argumentList);
		}
		{
		_loop6:
		do {
			if ((_tokenSet_0.member(LA(1)))) {
				patternInstruction(subjectList,patternInstructionList);
			}
			else {
				break _loop6;
			}
			
		} while (true);
		}
		t = LT(1);
		match(RBRACE);
		if ( inputState.guessing==0 ) {
			
			result = tom_make_Match(tom_make_SubjectList(subjectList),ASTFactory.makePatternInstructionList(patternInstructionList),optionList)
			
			
			
			;
			
			// update for new target block...
			updatePosition(t.getLine(),t.getColumn());
			
			// Match is finished : pop the tomlexer and return in
			// the target parser.  
			selector().pop(); 
			
		}
		}
		return result;
	}
	
	public final void matchArguments(
		LinkedList list
	) throws RecognitionException, TokenStreamException {
		
		
		{
		matchArgument(list);
		{
		_loop10:
		do {
			if ((LA(1)==COMMA)) {
				match(COMMA);
				matchArgument(list);
			}
			else {
				break _loop10;
			}
			
		} while (true);
		}
		}
	}
	
	public final void patternInstruction(
		TomList subjectList, LinkedList list
	) throws RecognitionException, TokenStreamException, TomException {
		
		Token  label = null;
		Token  t = null;
		
		LinkedList matchPatternList = new LinkedList();
		LinkedList listOfMatchPatternList = new LinkedList();
		LinkedList listTextPattern = new LinkedList();
		LinkedList listOrgTrackPattern = new LinkedList();
		LinkedList blockList = new LinkedList();
		
		LinkedList matchGuardsList = new LinkedList();
		
		Option option = null;
		
		clearText();
		
		
		{
		{
		boolean synPredMatched18 = false;
		if (((LA(1)==ALL_ID))) {
			int _m18 = mark();
			synPredMatched18 = true;
			inputState.guessing++;
			try {
				{
				match(ALL_ID);
				match(COLON);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched18 = false;
			}
			rewind(_m18);
inputState.guessing--;
		}
		if ( synPredMatched18 ) {
			label = LT(1);
			match(ALL_ID);
			match(COLON);
		}
		else if ((_tokenSet_0.member(LA(1)))) {
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		}
		option=matchPattern(matchPatternList);
		if ( inputState.guessing==0 ) {
			
			listOfMatchPatternList.add(ASTFactory.makeList(matchPatternList));
			matchPatternList.clear();
			listTextPattern.add(text.toString());
			clearText();
			listOrgTrackPattern.add(option);
			
		}
		{
		_loop20:
		do {
			if ((LA(1)==ALTERNATIVE)) {
				match(ALTERNATIVE);
				option=matchPattern(matchPatternList);
				if ( inputState.guessing==0 ) {
					
					listOfMatchPatternList.add(ASTFactory.makeList(matchPatternList));
					matchPatternList.clear();
					listTextPattern.add(text.toString());
					clearText();
					listOrgTrackPattern.add(option);
					
					getLogger().log(new PlatformLogRecord(Level.WARNING, TomMessage.deprecatedDisjunction,
					new Object[]{currentFile(), new Integer(getLine())},
					currentFile(), getLine()));
					
					
				}
			}
			else {
				break _loop20;
			}
			
		} while (true);
		}
		if ( inputState.guessing==0 ) {
			
			matchGuardsList.clear();
			
		}
		{
		switch ( LA(1)) {
		case WHEN:
		{
			match(WHEN);
			matchGuards(matchGuardsList);
			break;
		}
		case ARROW:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(ARROW);
		t = LT(1);
		match(LBRACE);
		if ( inputState.guessing==0 ) {
			
			// update for new target block
			updatePosition(t.getLine(),t.getColumn());
			
			// actions in target language : call the target lexer and
			// call the target parser
			selector().push("targetlexer");
			TargetLanguage tlCode = targetparser.targetLanguage(blockList);
			
			// target parser finished : pop the target lexer
			selector().pop();
			
			blockList.add(tlCode);
			OptionList optionList = tom_make_emptyOptionList();
			
			if(label != null){
			optionList = tom_cons_list_concOption(tom_make_Label(tom_make_Name(label.getText())),tom_empty_list_concOption());
			}
			
			TomList patterns = null;
			String patternText = null;
			/*
			* The following loop splits disjuntions of patterns
			* into several PatternInstructions
			*/
			for(int i=0 ;  i<listOfMatchPatternList.size() ; i++) {
			patterns = (TomList) listOfMatchPatternList.get(i);
			patternText = (String) listTextPattern.get(i);
			
			//TODO solve with xmlterm
			//if (patternText == null) patternText = "";
			
			optionList = tom_append_list_concOption(optionList,tom_cons_list_concOption((Option) listOrgTrackPattern.get(i),tom_cons_list_concOption(tom_make_OriginalText(tom_make_Name(patternText))
			,tom_empty_list_concOption())))
			
			
			
			;
			
			//System.out.println("pattern = " + `Pattern(subjectList,patterns,ASTFactory.makeList(matchGuardsList)));
			
			list.add(tom_make_PatternInstruction(tom_make_Pattern(subjectList,patterns,ASTFactory.makeList(matchGuardsList)),tom_make_RawAction(tom_make_AbstractBlock(ASTFactory.makeInstructionList(blockList))),optionList)
			
			
			
			);
			}
			
		}
		}
	}
	
	public final void matchArgument(
		LinkedList list
	) throws RecognitionException, TokenStreamException {
		
		Token  type = null;
		Token  name = null;
		
		{
		type = LT(1);
		match(ALL_ID);
		{
		switch ( LA(1)) {
		case BACKQUOTE:
		{
			match(BACKQUOTE);
			break;
		}
		case ALL_ID:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		name = LT(1);
		match(ALL_ID);
		}
		if ( inputState.guessing==0 ) {
			
			list.add(tom_make_TLVar(name.getText(),tom_make_TomTypeAlone(type.getText())));
			
		}
	}
	
	public final Option  matchPattern(
		LinkedList list
	) throws RecognitionException, TokenStreamException, TomException {
		Option result;
		
		
		result = null;
		TomTerm term = null;
		
		
		{
		term=annotedTerm();
		if ( inputState.guessing==0 ) {
			
			list.add(term);
			result = tom_make_OriginTracking(tom_make_Name("Pattern"),lastLine,currentFile());
			
		}
		{
		_loop25:
		do {
			if ((LA(1)==COMMA)) {
				match(COMMA);
				if ( inputState.guessing==0 ) {
					text.append('\n');
				}
				term=annotedTerm();
				if ( inputState.guessing==0 ) {
					list.add(term);
				}
			}
			else {
				break _loop25;
			}
			
		} while (true);
		}
		}
		return result;
	}
	
	public final void matchGuards(
		LinkedList list
	) throws RecognitionException, TokenStreamException, TomException {
		
		
		TomTerm term = null;
		
		
		{
		term=annotedTerm();
		if ( inputState.guessing==0 ) {
			
			list.add(term);
			
		}
		{
		_loop29:
		do {
			if ((LA(1)==COMMA)) {
				match(COMMA);
				if ( inputState.guessing==0 ) {
					text.append('\n');
				}
				term=annotedTerm();
				if ( inputState.guessing==0 ) {
					list.add(term);
				}
			}
			else {
				break _loop29;
			}
			
		} while (true);
		}
		}
	}
	
	public final TomTerm  annotedTerm() throws RecognitionException, TokenStreamException, TomException {
		TomTerm result;
		
		Token  name = null;
		
		result = null;
		TomName annotedName = null;
		int line = 0;
		
		
		{
		{
		boolean synPredMatched55 = false;
		if (((LA(1)==ALL_ID))) {
			int _m55 = mark();
			synPredMatched55 = true;
			inputState.guessing++;
			try {
				{
				match(ALL_ID);
				match(AT);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched55 = false;
			}
			rewind(_m55);
inputState.guessing--;
		}
		if ( synPredMatched55 ) {
			name = LT(1);
			match(ALL_ID);
			match(AT);
			if ( inputState.guessing==0 ) {
				
				text.append(name.getText());
				text.append('@');
				annotedName = tom_make_Name(name.getText());
				line = name.getLine();
				
			}
		}
		else if ((_tokenSet_0.member(LA(1)))) {
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		}
		result=plainTerm(annotedName,line);
		}
		return result;
	}
	
	public final TomTerm  extendsBqTerm() throws RecognitionException, TokenStreamException, TomException {
		TomTerm bqTerm;
		
		
		bqTerm = null;
		
		
		match(EXTENDS);
		match(BACKQUOTE);
		if ( inputState.guessing==0 ) {
			
			selector().push("bqlexer");
			bqTerm = bqparser.beginBackquote();
			//selector().pop();
			
		}
		return bqTerm;
	}
	
	public final Declaration  strategyConstruct(
		Option orgTrack
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  name = null;
		Token  slotName = null;
		Token  typeArg = null;
		Token  slotName2 = null;
		Token  typeArg2 = null;
		Token  t = null;
		
		result = null;
		TomTerm extendsTerm = null;
		TomType codomainType = null;
		LinkedList visitList = new LinkedList();
		TomVisitList astVisitList = tom_make_emptyTomVisitList();
		TomName orgText = null;
		TomTypeList types = tom_make_emptyTomTypeList();
		LinkedList options = new LinkedList();
		LinkedList slotNameList = new LinkedList();
		LinkedList pairNameDeclList = new LinkedList();
		String stringSlotName = null;
		
		clearText();
		
		
		{
		name = LT(1);
		match(ALL_ID);
		if ( inputState.guessing==0 ) {
			
							Option ot = tom_make_OriginTracking(tom_make_Name(name.getText()),name.getLine(),currentFile());
			options.add(ot);
			if (symbolTable.getSymbolFromName(name.getText()) != null){
			throw new TomException(TomMessage.invalidStrategyName,
			new Object[]{name.getText()});
			}
			
		}
		{
		match(LPAREN);
		{
		switch ( LA(1)) {
		case ALL_ID:
		{
			slotName = LT(1);
			match(ALL_ID);
			match(COLON);
			typeArg = LT(1);
			match(ALL_ID);
			if ( inputState.guessing==0 ) {
				
				stringSlotName = slotName.getText(); 
				TomName astName = tom_make_Name(stringSlotName);
				slotNameList.add(astName); 
				pairNameDeclList.add(tom_make_PairNameDecl(astName,tom_make_EmptyDeclaration())); 
				types = (TomTypeList) types.append(tom_make_TomTypeAlone(typeArg.getText()));
				
			}
			{
			_loop36:
			do {
				if ((LA(1)==COMMA)) {
					match(COMMA);
					slotName2 = LT(1);
					match(ALL_ID);
					match(COLON);
					typeArg2 = LT(1);
					match(ALL_ID);
					if ( inputState.guessing==0 ) {
						
						stringSlotName = slotName2.getText(); 
						TomName astName = ASTFactory.makeName(stringSlotName);
						if(slotNameList.indexOf(astName) != -1) {
						getLogger().log(new PlatformLogRecord(Level.SEVERE, TomMessage.repeatedSlotName,
						new Object[]{stringSlotName},
						currentFile(), getLine()));
						}
						slotNameList.add(astName); 
						pairNameDeclList.add(tom_make_PairNameDecl(tom_make_Name(stringSlotName),tom_make_EmptyDeclaration())); 
						types = (TomTypeList) types.append(tom_make_TomTypeAlone(typeArg2.getText()));
						
					}
				}
				else {
					break _loop36;
				}
				
			} while (true);
			}
			break;
		}
		case RPAREN:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(RPAREN);
		}
		extendsTerm=extendsBqTerm();
		if ( inputState.guessing==0 ) {
			
			matchBlock: {
								 if(extendsTerm instanceof  tom.engine.adt.tomsignature.types.TomTerm) { { tom.engine.adt.tomsignature.types.TomTerm tom_match1_1=(( tom.engine.adt.tomsignature.types.TomTerm)extendsTerm); if (tom_is_fun_sym_Composite(tom_match1_1) ||  false ) { { tom.engine.adt.tomsignature.types.TomList tom_match1_1_args=tom_get_slot_Composite_args(tom_match1_1); if (tom_is_fun_sym_concTomTerm(tom_match1_1_args) ||  false ) { { tom.engine.adt.tomsignature.types.TomList tom_match1_1_args_list1=tom_match1_1_args; if (!(tom_is_empty_concTomTerm_TomList(tom_match1_1_args_list1))) { { tom.engine.adt.tomsignature.types.TomTerm tom_match1_1_args_1=tom_get_head_concTomTerm_TomList(tom_match1_1_args_list1);tom_match1_1_args_list1=tom_get_tail_concTomTerm_TomList(tom_match1_1_args_list1); if (tom_is_fun_sym_BackQuoteAppl(tom_match1_1_args_1) ||  false ) { { tom.engine.adt.tomsignature.types.TomName tom_match1_1_args_1_astName=tom_get_slot_BackQuoteAppl_astName(tom_match1_1_args_1); { tom.engine.adt.tomsignature.types.TomName tom_astName=tom_match1_1_args_1_astName; if ( true ) {
			
										codomainType = tom_make_Codomain(tom_astName);
										break matchBlock;
									 } } } } } } } } } } if ( true ) {
			
										throw new TomException(TomMessage.malformedStrategy,
												new Object[]{currentFile(), new Integer(getLine()),
												"strat","a composite",extendsTerm.toString()});
									 } } }
			
			}
			
		}
		match(LBRACE);
		strategyVisitList(visitList);
		if ( inputState.guessing==0 ) {
			astVisitList = ASTFactory.makeTomVisitList(visitList);
		}
		t = LT(1);
		match(RBRACE);
		if ( inputState.guessing==0 ) {
			
			//initialize arrayList with argument names
							 TomList makeArgs = tom_empty_list_concTomTerm();
			int index = 0;
			TomTypeList makeTypes = types;//keep a copy of types
							 String makeTlCode = "new " + name.getText() + "(";
			while(!makeTypes.isEmpty()) {
								 String argName = "t"+index;
			if (index>0) {//if many parameters
			makeTlCode = makeTlCode.concat(",");
			}
								 makeTlCode += argName;
			
			TomTerm arg = tom_make_Variable(tom_empty_list_concOption(),tom_make_Name(argName),makeTypes.getHead(),tom_empty_list_concConstraint());
			makeArgs = tom_append_list_concTomTerm(makeArgs,tom_cons_list_concTomTerm(arg,tom_empty_list_concTomTerm()));
			
								 makeTypes = makeTypes.getTail();
			index++;
			}
							 makeTlCode += ")";
			
							 Option makeOption = tom_make_OriginTracking(tom_make_Name(name.getText()),t.getLine(),currentFile());
							 Declaration makeDecl = tom_make_MakeDecl(tom_make_Name(name.getText()),codomainType,makeArgs,tom_make_TargetLanguageToInstruction(tom_make_ITL(makeTlCode)),makeOption);
			options.add(makeDecl); 
			
			TomSymbol astSymbol = ASTFactory.makeSymbol(name.getText(), codomainType, types, ASTFactory.makePairNameDeclList(pairNameDeclList), options);
			putSymbol(name.getText(),astSymbol);
			// update for new target block...
			updatePosition(t.getLine(),t.getColumn());
			
			result = tom_make_AbstractDecl(tom_cons_list_concDeclaration(tom_make_Strategy(tom_make_Name(name.getText()),extendsTerm,astVisitList,orgTrack),tom_cons_list_concDeclaration(tom_make_SymbolDecl(tom_make_Name(name.getText())),tom_empty_list_concDeclaration())));
			
			// %strat finished: go back in target parser.
			selector().pop();
			
		}
		}
		return result;
	}
	
	public final void strategyVisitList(
		LinkedList list
	) throws RecognitionException, TokenStreamException, TomException {
		
		
		{
		_loop39:
		do {
			if ((LA(1)==ALL_ID)) {
				strategyVisit(list);
			}
			else {
				break _loop39;
			}
			
		} while (true);
		}
	}
	
	public final void strategyVisit(
		LinkedList list
	) throws RecognitionException, TokenStreamException, TomException {
		
		Token  visit = null;
		Token  type = null;
		
		LinkedList patternInstructionList = new LinkedList();
		TomType vType = null;
		TomList subjectList = tom_make_emptyTomList();
		
		clearText();
		
		
		{
		visit = LT(1);
		match(ALL_ID);
		if ( inputState.guessing==0 ) {
			
			if (!"visit".equals(visit.getText())) {
			throw new TomException(TomMessage.malformedStrategy,
			new Object[]{currentFile(), new Integer(getLine()),
			"strat","visit",visit.getText()});
			}
			
		}
		type = LT(1);
		match(ALL_ID);
		match(LBRACE);
		if ( inputState.guessing==0 ) {
			
			vType = tom_make_TomTypeAlone(type.getText());
			subjectList = tom_cons_list_concTomTerm(tom_make_TomTypeToTomTerm(vType),tom_empty_list_concTomTerm());
			
		}
		{
		_loop43:
		do {
			if ((_tokenSet_0.member(LA(1)))) {
				patternInstruction(subjectList,patternInstructionList);
			}
			else {
				break _loop43;
			}
			
		} while (true);
		}
		match(RBRACE);
		}
		if ( inputState.guessing==0 ) {
			
			LinkedList optionList = new LinkedList();
			optionList.add(tom_make_OriginTracking(tom_make_Name(type.getText()),type.getLine(),currentFile()));
			OptionList options = ASTFactory.makeOptionList(optionList);
			list.add(tom_make_VisitTerm(vType,ASTFactory.makePatternInstructionList(patternInstructionList),options));
			
		}
	}
	
	public final Declaration  ruleConstruct(
		Option ot
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		
		result = null;
		TomRuleList ruleList = tom_make_emptyTomRuleList();
		TomTerm lhs = null, rhs = null, pattern = null, subject = null;
		TomList listOfLhs = tom_make_emptyTomList();
		InstructionList conditionList = tom_make_emptyInstructionList();
		TomName orgText = null;
		OptionList optionList = tom_cons_list_concOption(ot,tom_cons_list_concOption(tom_make_ModuleName(TomBase.DEFAULT_MODULE_NAME),tom_empty_list_concOption()));
		clearText();
		
		
		match(LBRACE);
		{
		_loop50:
		do {
			if ((_tokenSet_0.member(LA(1)))) {
				lhs=annotedTerm();
				if ( inputState.guessing==0 ) {
					listOfLhs = tom_cons_list_concTomTerm(lhs,tom_empty_list_concTomTerm());
				}
				{
				_loop47:
				do {
					if ((LA(1)==ALTERNATIVE)) {
						match(ALTERNATIVE);
						if ( inputState.guessing==0 ) {
							text.append('|');
						}
						lhs=annotedTerm();
						if ( inputState.guessing==0 ) {
							listOfLhs = (TomList) listOfLhs.append(lhs);
						}
					}
					else {
						break _loop47;
					}
					
				} while (true);
				}
				match(ARROW);
				if ( inputState.guessing==0 ) {
					orgText = tom_make_Name(text.toString());
				}
				rhs=plainTerm(null,0);
				{
				_loop49:
				do {
					switch ( LA(1)) {
					case WHERE:
					{
						match(WHERE);
						pattern=annotedTerm();
						match(AFFECT);
						subject=annotedTerm();
						if ( inputState.guessing==0 ) {
							conditionList = (InstructionList) conditionList.append(tom_make_MatchingCondition(pattern,subject));
						}
						break;
					}
					case IF:
					{
						match(IF);
						pattern=annotedTerm();
						match(DOUBLEEQ);
						subject=annotedTerm();
						if ( inputState.guessing==0 ) {
							conditionList = (InstructionList) conditionList.append(tom_make_EqualityCondition(pattern,subject));
						}
						break;
					}
					default:
					{
						break _loop49;
					}
					}
				} while (true);
				}
				if ( inputState.guessing==0 ) {
					
					// get the last token's line
					int line = lastLine;
					Option ot2 = tom_make_OriginTracking(tom_make_Name("Pattern"),line,currentFile()
					)
					;
					OptionList optionList2 = tom_cons_list_concOption(ot2,tom_cons_list_concOption(tom_make_OriginalText(orgText),tom_cons_list_concOption(tom_make_ModuleName(TomBase.DEFAULT_MODULE_NAME),tom_empty_list_concOption())));
					while(! listOfLhs.isEmpty()){
					ruleList = (TomRuleList) ruleList.append(
					tom_make_RewriteRule(tom_make_Term(listOfLhs.getHead()),tom_make_Term(rhs),conditionList,optionList2)
					
					
					
					
					
					);
					listOfLhs = listOfLhs.getTail();
					}
					
					conditionList = tom_make_emptyInstructionList();
					clearText();
					
				}
			}
			else {
				break _loop50;
			}
			
		} while (true);
		}
		t = LT(1);
		match(RBRACE);
		if ( inputState.guessing==0 ) {
			
			
			// update for new target block...
			updatePosition(t.getLine(),t.getColumn());
			
			result = tom_make_RuleSet(ruleList,optionList);
			
			// %rule finished: go back in target parser.
			selector().pop();
			
		}
		return result;
	}
	
	public final TomTerm  plainTerm(
		TomName astAnnotedName, int line
	) throws RecognitionException, TokenStreamException, TomException {
		TomTerm result;
		
		
		result = null;
		LinkedList constraintList = new LinkedList();
		LinkedList optionList = new LinkedList();
		LinkedList secondOptionList = new LinkedList();
		TomTerm term = null;
		NameList nameList = tom_make_emptyNameList();
		TomName name = null;
		LinkedList list = new LinkedList();
		boolean implicit = false;
		boolean withArgs = false;
		
		Constraint annotedName = 
		(astAnnotedName == null)?null:ASTFactory.makeAssignTo(astAnnotedName, line, currentFile());
		if(annotedName != null)
		constraintList.add(annotedName);
		
		
		{
		if ((_tokenSet_1.member(LA(1)))) {
			result=xmlTerm(optionList, constraintList);
		}
		else {
			boolean synPredMatched59 = false;
			if (((LA(1)==ALL_ID||LA(1)==UNDERSCORE))) {
				int _m59 = mark();
				synPredMatched59 = true;
				inputState.guessing++;
				try {
					{
					variableStar(null,null);
					}
				}
				catch (RecognitionException pe) {
					synPredMatched59 = false;
				}
				rewind(_m59);
inputState.guessing--;
			}
			if ( synPredMatched59 ) {
				result=variableStar(optionList,constraintList);
			}
			else if ((LA(1)==UNDERSCORE)) {
				result=placeHolder(optionList,constraintList);
			}
			else if (((LA(1)==ALL_ID))&&(LA(2) != LPAREN && LA(2) != LBRACKET)) {
				name=headSymbol(optionList);
				if ( inputState.guessing==0 ) {
					
											    result = tom_make_Variable(ASTFactory.makeOptionList(optionList),name,tom_make_TomTypeAlone("unknown type"),ASTFactory.makeConstraintList(constraintList))
					;
					
				}
			}
			else if ((((LA(1) >= NUM_INT && LA(1) <= NUM_DOUBLE)))&&(LA(2) != LPAREN && LA(2) != LBRACKET)) {
				name=headConstant(optionList);
				if ( inputState.guessing==0 ) {
					
					nameList = (NameList) nameList.append(name);
													optionList.add(tom_make_Constant());
					result = tom_make_TermAppl(ASTFactory.makeOptionList(optionList),nameList,ASTFactory.makeList(list),ASTFactory.makeConstraintList(constraintList)
					)
					
					
					
					
					;
					
				}
			}
			else if ((LA(1)==ALL_ID)) {
				name=headSymbol(optionList);
				if ( inputState.guessing==0 ) {
					nameList = (NameList) nameList.append(name);
				}
				implicit=args(list,secondOptionList);
				if ( inputState.guessing==0 ) {
					
					if(implicit) {
					result = tom_make_RecordAppl(ASTFactory.makeOptionList(optionList),nameList,ASTFactory.makeSlotList(list),ASTFactory.makeConstraintList(constraintList)
					)
					
					
					
					
					;
					} else {
					result = tom_make_TermAppl(ASTFactory.makeOptionList(optionList),nameList,ASTFactory.makeList(list),ASTFactory.makeConstraintList(constraintList)
					)
					
					
					
					
					;
					}
					
				}
			}
			else if (((LA(1)==LPAREN))&&(LA(3) == ALTERNATIVE)) {
				nameList=headSymbolList(optionList);
				implicit=args(list, secondOptionList);
				if ( inputState.guessing==0 ) {
					
												withArgs = true;
					if(implicit) {
					result = tom_make_RecordAppl(ASTFactory.makeOptionList(optionList),nameList,ASTFactory.makeSlotList(list),ASTFactory.makeConstraintList(constraintList)
					)
					
					
					
					
					;
					} else {
					result = tom_make_TermAppl(ASTFactory.makeOptionList(optionList),nameList,ASTFactory.makeList(list),ASTFactory.makeConstraintList(constraintList)
					)
					
					
					
					
					;
					}
					
				}
			}
			else if ((LA(1)==LPAREN||LA(1)==LBRACKET)) {
				implicit=args(list,secondOptionList);
				if ( inputState.guessing==0 ) {
					
					nameList = tom_cons_list_concTomName(tom_make_Name(""),tom_empty_list_concTomName());
					optionList.addAll(secondOptionList);
					result = tom_make_TermAppl(ASTFactory.makeOptionList(optionList),nameList,ASTFactory.makeList(list),ASTFactory.makeConstraintList(constraintList)
					)
					
					
					
					
					;
					
				}
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			return result;
		}
		
	public final TomTerm  xmlTerm(
		LinkedList optionList, LinkedList constraintList
	) throws RecognitionException, TokenStreamException, TomException {
		TomTerm result;
		
		Token  t = null;
		
		result = null;
		TomTerm arg1, arg2;
		LinkedList pairSlotList = new LinkedList();
		LinkedList attributeList = new LinkedList();
		LinkedList childs = new LinkedList();
		String keyword = "";
		boolean implicit;
		NameList nameList, closingNameList;
		OptionList option = null;
		ConstraintList constraint;
		
		
		{
		switch ( LA(1)) {
		case XML_START:
		{
			match(XML_START);
			if ( inputState.guessing==0 ) {
				text.append("<");
			}
			nameList=xmlNameList(optionList, true);
			implicit=xmlAttributeList(attributeList);
			if ( inputState.guessing==0 ) {
				
				if(implicit) { optionList.add(tom_make_ImplicitXMLAttribut()); }
				
			}
			{
			switch ( LA(1)) {
			case XML_CLOSE_SINGLETON:
			{
				match(XML_CLOSE_SINGLETON);
				if ( inputState.guessing==0 ) {
					
					text.append("\\>");
					option =  ASTFactory.makeOptionList(optionList);
					
				}
				break;
			}
			case XML_CLOSE:
			{
				match(XML_CLOSE);
				if ( inputState.guessing==0 ) {
					text.append(">");
				}
				implicit=xmlChilds(childs);
				match(XML_START_ENDING);
				if ( inputState.guessing==0 ) {
					text.append("</");
				}
				closingNameList=xmlNameList(optionList, false);
				t = LT(1);
				match(XML_CLOSE);
				if ( inputState.guessing==0 ) {
					text.append(">");
				}
				if ( inputState.guessing==0 ) {
					
					if(!nameList.equals(closingNameList)) {
					StringBuffer found = new StringBuffer();
					StringBuffer expected = new StringBuffer();
					while(!nameList.isEmpty()) {
					expected.append("|"+nameList.getHead().getString());
					nameList = nameList.getTail();
					}
					while(!closingNameList.isEmpty()) {
					found.append("|"+closingNameList.getHead().getString());
					closingNameList = closingNameList.getTail();
					}
					// TODO find the orgTrack of the match
					throw new TomException(TomMessage.malformedXMLTerm,
					new Object[]{currentFile(), new Integer(getLine()), 
					"match", expected.substring(1), found.substring(1)});
					}
					if(implicit) {
					// Special case when XMLChilds() is reduced to a singleton
					// when XMLChilds() is reduced to a singleton
					// Appl(...,Name(""),args)
					if(ASTFactory.isExplicitTermList(childs)) {
					childs = ASTFactory.metaEncodeExplicitTermList(symbolTable, (TomTerm)childs.getFirst());
					} else {
					optionList.add(tom_make_ImplicitXMLChild());
					}
					}
					option = ASTFactory.makeOptionList(optionList);    
					
				}
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			if ( inputState.guessing==0 ) {
				
				result = tom_make_XMLAppl(option,nameList,ASTFactory.makeList(attributeList),ASTFactory.makeList(childs),ASTFactory.makeConstraintList(constraintList))
				
				
				
				
				;
				
			}
			break;
		}
		case XML_TEXT:
		{
			match(XML_TEXT);
			match(LPAREN);
			arg1=annotedTerm();
			match(RPAREN);
			if ( inputState.guessing==0 ) {
				
				keyword = Constants.TEXT_NODE;
				pairSlotList.add(tom_make_PairSlotAppl(tom_make_Name(Constants.SLOT_DATA),arg1));
				
				optionList.add(tom_make_OriginTracking(tom_make_Name(keyword),getLine(),currentFile()));
				option = ASTFactory.makeOptionList(optionList);
				constraint = ASTFactory.makeConstraintList(constraintList);
				nameList = tom_cons_list_concTomName(tom_make_Name(keyword),tom_empty_list_concTomName());
				result = tom_make_RecordAppl(option,nameList,ASTFactory.makeSlotList(pairSlotList),constraint)
				
				
				;
				
			}
			break;
		}
		case XML_COMMENT:
		{
			match(XML_COMMENT);
			match(LPAREN);
			arg1=termStringIdentifier(null);
			match(RPAREN);
			if ( inputState.guessing==0 ) {
				
				keyword = Constants.COMMENT_NODE;
				pairSlotList.add(tom_make_PairSlotAppl(tom_make_Name(Constants.SLOT_DATA),arg1));
				
				optionList.add(tom_make_OriginTracking(tom_make_Name(keyword),getLine(),currentFile()));
				option = ASTFactory.makeOptionList(optionList);
				constraint = ASTFactory.makeConstraintList(constraintList);
				nameList = tom_cons_list_concTomName(tom_make_Name(keyword),tom_empty_list_concTomName());
				result = tom_make_RecordAppl(option,nameList,ASTFactory.makeSlotList(pairSlotList),constraint)
				
				
				;
				
			}
			break;
		}
		case XML_PROC:
		{
			match(XML_PROC);
			match(LPAREN);
			arg1=termStringIdentifier(null);
			match(COMMA);
			arg2=termStringIdentifier(null);
			match(RPAREN);
			if ( inputState.guessing==0 ) {
				
				keyword = Constants.PROCESSING_INSTRUCTION_NODE;
				pairSlotList.add(tom_make_PairSlotAppl(tom_make_Name(Constants.SLOT_TARGET),arg1));
				pairSlotList.add(tom_make_PairSlotAppl(tom_make_Name(Constants.SLOT_DATA),arg2));
				
				optionList.add(tom_make_OriginTracking(tom_make_Name(keyword),getLine(),currentFile()));
				option = ASTFactory.makeOptionList(optionList);
				constraint = ASTFactory.makeConstraintList(constraintList);
				nameList = tom_cons_list_concTomName(tom_make_Name(keyword),tom_empty_list_concTomName());
				result = tom_make_RecordAppl(option,nameList,ASTFactory.makeSlotList(pairSlotList),constraint)
				
				
				;
				
			}
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		return result;
	}
	
	public final TomTerm  variableStar(
		LinkedList optionList, LinkedList constraintList
	) throws RecognitionException, TokenStreamException {
		TomTerm result;
		
		Token  name1 = null;
		Token  name2 = null;
		Token  t = null;
		
		result = null; 
		String name = null;
		int line = 0;
		OptionList options = null;
		ConstraintList constraints = null;
		
		
		{
		{
		switch ( LA(1)) {
		case ALL_ID:
		{
			name1 = LT(1);
			match(ALL_ID);
			if ( inputState.guessing==0 ) {
				
				name = name1.getText();
				line = name1.getLine();
				
			}
			break;
		}
		case UNDERSCORE:
		{
			name2 = LT(1);
			match(UNDERSCORE);
			if ( inputState.guessing==0 ) {
				
				name = name2.getText();
				line = name2.getLine();
				
			}
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		t = LT(1);
		match(STAR);
		if ( inputState.guessing==0 ) {
			
			text.append(name);
			text.append(t.getText());
			
			// setting line number for origin tracking
			// in %rule construct
			setLastLine(t.getLine());
			
			optionList.add(tom_make_OriginTracking(tom_make_Name(name),line,currentFile()));
			options = ASTFactory.makeOptionList(optionList);
			constraints = ASTFactory.makeConstraintList(constraintList);
			if(name1 == null) {
			result = tom_make_UnamedVariableStar(options,tom_make_TomTypeAlone("unknown type"),constraints)
			
			
			
			;
			} else {
			result = tom_make_VariableStar(options,tom_make_Name(name),tom_make_TomTypeAlone("unknown type"),constraints)
			
			
			
			
			;
			}
			
		}
		}
		return result;
	}
	
	public final TomTerm  placeHolder(
		LinkedList optionList, LinkedList constraintList
	) throws RecognitionException, TokenStreamException {
		TomTerm result;
		
		Token  t = null;
		
		result = null;
		OptionList options = null;
		ConstraintList constraints = null;
		
		
		{
		t = LT(1);
		match(UNDERSCORE);
		if ( inputState.guessing==0 ) {
			
			text.append(t.getText());
			setLastLine(t.getLine());
			
			optionList.add(
			tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile())
			);
			options = ASTFactory.makeOptionList(optionList);
			constraints = ASTFactory.makeConstraintList(constraintList);
			result = tom_make_Placeholder(options,constraints);
			
		}
		}
		return result;
	}
	
	public final TomName  headSymbol(
		LinkedList optionList
	) throws RecognitionException, TokenStreamException {
		TomName result;
		
		Token  i = null;
		
		result = null; 
		
		
		{
		i = LT(1);
		match(ALL_ID);
		if ( inputState.guessing==0 ) {
			
					String name = i.getText();
					int line = i.getLine();
					text.append(name);
					setLastLine(line);
					result = tom_make_Name(name);
					optionList.add(tom_make_OriginTracking(result,line,currentFile()));
				
		}
		}
		return result;
	}
	
	public final TomName  headConstant(
		LinkedList optionList
	) throws RecognitionException, TokenStreamException {
		TomName result;
		
		
		result = null; 
				Token t;
		
		
		t=constant();
		if ( inputState.guessing==0 ) {
			
				String name = t.getText();
				int line = t.getLine();
				text.append(name);
				setLastLine(line);
				result = tom_make_Name(name);
				optionList.add(tom_make_OriginTracking(result,line,currentFile()));
			
				switch(t.getType()) {
					case NUM_INT:
						ASTFactory.makeIntegerSymbol(symbolTable,name,optionList);
						break;
					case NUM_LONG:
						ASTFactory.makeLongSymbol(symbolTable,name,optionList);
						break;
					case CHARACTER:
						ASTFactory.makeCharSymbol(symbolTable,name,optionList);
						break;
					case NUM_DOUBLE:
						ASTFactory.makeDoubleSymbol(symbolTable,name,optionList);
						break;
					case STRING:
						ASTFactory.makeStringSymbol(symbolTable,name,optionList);
						break;
					default:
				}
			
		}
		return result;
	}
	
	public final boolean  args(
		LinkedList list, LinkedList optionList
	) throws RecognitionException, TokenStreamException, TomException {
		boolean result;
		
		Token  t1 = null;
		Token  t2 = null;
		Token  t3 = null;
		Token  t4 = null;
		
		result = false;
		
		
		{
		switch ( LA(1)) {
		case LPAREN:
		{
			t1 = LT(1);
			match(LPAREN);
			if ( inputState.guessing==0 ) {
				text.append('(');
			}
			{
			switch ( LA(1)) {
			case NUM_INT:
			case CHARACTER:
			case STRING:
			case NUM_FLOAT:
			case NUM_LONG:
			case NUM_DOUBLE:
			case LPAREN:
			case ALL_ID:
			case XML_START:
			case XML_TEXT:
			case XML_COMMENT:
			case XML_PROC:
			case LBRACKET:
			case UNDERSCORE:
			{
				termList(list);
				break;
			}
			case RPAREN:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			t2 = LT(1);
			match(RPAREN);
			if ( inputState.guessing==0 ) {
				
				// setting line number for origin tracking
				// in %rule construct
				setLastLine(t2.getLine());
				
				text.append(t2.getText());
				
				result = false;
				optionList.add(tom_make_OriginTracking(tom_make_Name(""),t1.getLine(),currentFile()));
				
			}
			break;
		}
		case LBRACKET:
		{
			t3 = LT(1);
			match(LBRACKET);
			if ( inputState.guessing==0 ) {
				text.append('[');
			}
			{
			switch ( LA(1)) {
			case ALL_ID:
			{
				pairList(list);
				break;
			}
			case RBRACKET:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			t4 = LT(1);
			match(RBRACKET);
			if ( inputState.guessing==0 ) {
				
				// setting line number for origin tracking
				// in %rule construct
				setLastLine(t4.getLine());
				text.append(t4.getText());
				
				result = true;
				optionList.add(tom_make_OriginTracking(tom_make_Name(""),t3.getLine(),currentFile()));
				
			}
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		return result;
	}
	
	public final NameList  headSymbolList(
		LinkedList optionList
	) throws RecognitionException, TokenStreamException {
		NameList result;
		
		Token  t = null;
		
		result = tom_make_emptyNameList();
		TomName name = null;
		
		
		{
		match(LPAREN);
		if ( inputState.guessing==0 ) {
			text.append('(');
		}
		name=headSymbolOrConstant(optionList);
		if ( inputState.guessing==0 ) {
			result = (NameList) result.append(name);
		}
		match(ALTERNATIVE);
		if ( inputState.guessing==0 ) {
			text.append('|');
		}
		name=headSymbolOrConstant(optionList);
		if ( inputState.guessing==0 ) {
			result = (NameList) result.append(name);
		}
		{
		_loop116:
		do {
			if ((LA(1)==ALTERNATIVE)) {
				match(ALTERNATIVE);
				if ( inputState.guessing==0 ) {
					text.append('|');
				}
				name=headSymbolOrConstant(optionList);
				if ( inputState.guessing==0 ) {
					result = (NameList) result.append(name);
				}
			}
			else {
				break _loop116;
			}
			
		} while (true);
		}
		t = LT(1);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			
			text.append(t.getText());
			setLastLine(t.getLine());                
			
		}
		}
		return result;
	}
	
	public final NameList  xmlNameList(
		LinkedList optionList, boolean needOrgTrack
	) throws RecognitionException, TokenStreamException, TomException {
		NameList result;
		
		Token  name = null;
		Token  name2 = null;
		Token  name3 = null;
		Token  name4 = null;
		
		result = tom_make_emptyNameList();
		StringBuffer XMLName = new StringBuffer("");
		int decLine = 0;
		
		
		{
		switch ( LA(1)) {
		case ALL_ID:
		{
			name = LT(1);
			match(ALL_ID);
			if ( inputState.guessing==0 ) {
				
				text.append(name.getText());
				XMLName.append(name.getText());
				decLine = name.getLine();
				result = tom_cons_list_concTomName(tom_make_Name(name.getText()),tom_empty_list_concTomName());
				
			}
			break;
		}
		case UNDERSCORE:
		{
			name2 = LT(1);
			match(UNDERSCORE);
			if ( inputState.guessing==0 ) {
				
				text.append(name2.getText());
				XMLName.append(name2.getText());
				decLine = name2.getLine();
				result = tom_cons_list_concTomName(tom_make_Name(name2.getText()),tom_empty_list_concTomName());
				
			}
			break;
		}
		case LPAREN:
		{
			match(LPAREN);
			name3 = LT(1);
			match(ALL_ID);
			if ( inputState.guessing==0 ) {
				
				text.append(name3.getText());
				XMLName.append(name3.getText());
				decLine = name3.getLine();
				result = tom_cons_list_concTomName(tom_make_Name(name3.getText()),tom_empty_list_concTomName());
				
			}
			{
			_loop84:
			do {
				if ((LA(1)==ALTERNATIVE)) {
					match(ALTERNATIVE);
					name4 = LT(1);
					match(ALL_ID);
					if ( inputState.guessing==0 ) {
						
						text.append("|"+name4.getText());
						XMLName.append("|"+name4.getText());
						result = (NameList)result.append(tom_make_Name(name4.getText()));
						
					}
				}
				else {
					break _loop84;
				}
				
			} while (true);
			}
			match(RPAREN);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		if ( inputState.guessing==0 ) {
			
			if(needOrgTrack) {
			optionList.add(tom_make_OriginTracking(tom_make_Name(XMLName.toString()),decLine,currentFile()));
			}
			
		}
		return result;
	}
	
	public final boolean  xmlAttributeList(
		LinkedList list
	) throws RecognitionException, TokenStreamException, TomException {
		boolean result;
		
		
		result = false;
		TomTerm term;
		
		
		{
		switch ( LA(1)) {
		case LBRACKET:
		{
			match(LBRACKET);
			if ( inputState.guessing==0 ) {
				text.append("[");
			}
			{
			switch ( LA(1)) {
			case ALL_ID:
			case UNDERSCORE:
			{
				term=xmlAttribute();
				if ( inputState.guessing==0 ) {
					list.add(term);
				}
				{
				_loop67:
				do {
					if ((LA(1)==COMMA)) {
						match(COMMA);
						if ( inputState.guessing==0 ) {
							text.append("(");
						}
						term=xmlAttribute();
						if ( inputState.guessing==0 ) {
							list.add(term);
						}
					}
					else {
						break _loop67;
					}
					
				} while (true);
				}
				break;
			}
			case RBRACKET:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(RBRACKET);
			if ( inputState.guessing==0 ) {
				
				text.append("]");
				result = true;
				
			}
			break;
		}
		case LPAREN:
		{
			match(LPAREN);
			if ( inputState.guessing==0 ) {
				text.append("(");
			}
			{
			switch ( LA(1)) {
			case ALL_ID:
			case UNDERSCORE:
			{
				term=xmlAttribute();
				if ( inputState.guessing==0 ) {
					list.add(term);
				}
				{
				_loop70:
				do {
					if ((LA(1)==COMMA)) {
						match(COMMA);
						if ( inputState.guessing==0 ) {
							text.append(",");
						}
						term=xmlAttribute();
						if ( inputState.guessing==0 ) {
							list.add(term);
						}
					}
					else {
						break _loop70;
					}
					
				} while (true);
				}
				break;
			}
			case RPAREN:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(RPAREN);
			if ( inputState.guessing==0 ) {
				
				text.append(")");
				result = false;
				
			}
			break;
		}
		case ALL_ID:
		case XML_CLOSE_SINGLETON:
		case XML_CLOSE:
		case UNDERSCORE:
		{
			{
			_loop72:
			do {
				if (((LA(1)==ALL_ID||LA(1)==UNDERSCORE))&&(LA(1) != XML_CLOSE)) {
					term=xmlAttribute();
					if ( inputState.guessing==0 ) {
						list.add(term);
					}
				}
				else {
					break _loop72;
				}
				
			} while (true);
			}
			if ( inputState.guessing==0 ) {
				result = true;
			}
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		return result;
	}
	
	public final boolean  xmlChilds(
		LinkedList list
	) throws RecognitionException, TokenStreamException, TomException {
		boolean result;
		
		
		result = false;
		LinkedList childs = new LinkedList();
		Iterator it;
		
		
		{
		if (((LA(1)==LBRACKET))&&(LA(1) == LBRACKET)) {
			result=implicitTermList(childs);
		}
		else if ((_tokenSet_2.member(LA(1)))) {
			result=xmlTermList(childs);
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		}
		if ( inputState.guessing==0 ) {
			
			it = childs.iterator();
			while(it.hasNext()) {
			list.add(ASTFactory.metaEncodeXMLAppl(symbolTable,(TomTerm)it.next()));
			}
			
		}
		return result;
	}
	
	public final TomTerm  termStringIdentifier(
		LinkedList options
	) throws RecognitionException, TokenStreamException, TomException {
		TomTerm result;
		
		Token  nameID = null;
		Token  nameString = null;
		
		result = null;
		LinkedList optionList = (options==null)?new LinkedList():options;
		OptionList option = null;
		NameList nameList = null;
		
		
		{
		switch ( LA(1)) {
		case ALL_ID:
		{
			nameID = LT(1);
			match(ALL_ID);
			if ( inputState.guessing==0 ) {
				
				text.append(nameID.getText());
				optionList.add(tom_make_OriginTracking(tom_make_Name(nameID.getText()),nameID.getLine(),currentFile()));
				option = ASTFactory.makeOptionList(optionList);
				result = tom_make_Variable(option,tom_make_Name(nameID.getText()),tom_make_TomTypeAlone("unknown type"),tom_empty_list_concConstraint());
				
			}
			break;
		}
		case STRING:
		{
			nameString = LT(1);
			match(STRING);
			if ( inputState.guessing==0 ) {
				
				text.append(nameString.getText());
				optionList.add(tom_make_OriginTracking(tom_make_Name(nameString.getText()),nameString.getLine(),currentFile()));
				option = ASTFactory.makeOptionList(optionList);
				ASTFactory.makeStringSymbol(symbolTable,nameString.getText(),optionList);
				nameList = tom_cons_list_concTomName(tom_make_Name(nameString.getText()),tom_empty_list_concTomName());
												result = tom_make_TermAppl(option,nameList,tom_empty_list_concTomTerm(),tom_empty_list_concConstraint());
				
			}
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		return result;
	}
	
	public final TomTerm  xmlAttribute() throws RecognitionException, TokenStreamException, TomException {
		TomTerm result;
		
		Token  id = null;
		Token  anno2 = null;
		Token  anno1 = null;
		Token  e = null;
		Token  anno3 = null;
		
		result = null;
		LinkedList slotList = new LinkedList();
		TomTerm term = null;
		TomTerm termName = null;
		String name;
		OptionList option = null;
		ConstraintList constraint;
		LinkedList optionList = new LinkedList();
		LinkedList constraintList = new LinkedList();
		LinkedList optionListAnno2 = new LinkedList();
		NameList nameList;
		boolean varStar = false;
		
		
		{
		if (((LA(1)==ALL_ID||LA(1)==UNDERSCORE))&&(LA(2) == STAR)) {
			result=variableStar(optionList,constraintList);
			if ( inputState.guessing==0 ) {
				varStar = true;
			}
		}
		else if (((LA(1)==ALL_ID))&&(LA(2) == EQUAL)) {
			id = LT(1);
			match(ALL_ID);
			match(EQUAL);
			if ( inputState.guessing==0 ) {
				text.append(id.getText()+"=");
			}
			{
			if (((LA(1)==ALL_ID))&&(LA(2) == AT)) {
				anno2 = LT(1);
				match(ALL_ID);
				match(AT);
				if ( inputState.guessing==0 ) {
					
					text.append(anno2.getText()+"@");
					optionListAnno2.add(tom_make_Name(anno2.getText()));
					
				}
			}
			else if ((LA(1)==STRING||LA(1)==ALL_ID||LA(1)==UNDERSCORE)) {
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			term=unamedVariableOrTermStringIdentifier(optionListAnno2);
			if ( inputState.guessing==0 ) {
				
				name = ASTFactory.encodeXMLString(symbolTable,id.getText());
				nameList = tom_cons_list_concTomName(tom_make_Name(name),tom_empty_list_concTomName());
				termName = tom_make_TermAppl(ASTFactory.makeOption(),nameList,tom_empty_list_concTomTerm(),tom_empty_list_concConstraint());
				
			}
		}
		else if ((LA(1)==ALL_ID||LA(1)==UNDERSCORE)) {
			{
			switch ( LA(1)) {
			case ALL_ID:
			{
				anno1 = LT(1);
				match(ALL_ID);
				match(AT);
				if ( inputState.guessing==0 ) {
					
					text.append(anno1.getText()+"@");
					optionList.add(tom_make_Name(anno1.getText()));
					
				}
				break;
			}
			case UNDERSCORE:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			termName=placeHolder(optionList,constraintList);
			e = LT(1);
			match(EQUAL);
			if ( inputState.guessing==0 ) {
				text.append("=");
			}
			{
			if (((LA(1)==ALL_ID))&&(LA(2) == AT)) {
				anno3 = LT(1);
				match(ALL_ID);
				match(AT);
				if ( inputState.guessing==0 ) {
					
					text.append(anno3.getText()+"@");
					optionListAnno2.add(tom_make_Name(anno3.getText()));
					
				}
			}
			else if ((LA(1)==STRING||LA(1)==ALL_ID||LA(1)==UNDERSCORE)) {
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			term=unamedVariableOrTermStringIdentifier(optionListAnno2);
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		}
		if ( inputState.guessing==0 ) {
			
			if (!varStar) {
			slotList.add(tom_make_PairSlotAppl(tom_make_Name(Constants.SLOT_NAME),termName));
			// we add the specif value : _
			slotList.add(tom_make_PairSlotAppl(tom_make_Name(Constants.SLOT_SPECIFIED),tom_make_Placeholder(ASTFactory.makeOption(),ASTFactory.makeConstraint())));
			// no longer necessary ot metaEncode Strings in attributes
			slotList.add(tom_make_PairSlotAppl(tom_make_Name(Constants.SLOT_VALUE),term));
			optionList.add(tom_make_OriginTracking(tom_make_Name(Constants.ATTRIBUTE_NODE),getLine(),currentFile()));
			option = ASTFactory.makeOptionList(optionList);            
			constraint = ASTFactory.makeConstraintList(constraintList);
			
			nameList = tom_cons_list_concTomName(tom_make_Name(Constants.ATTRIBUTE_NODE),tom_empty_list_concTomName());
			result = tom_make_RecordAppl(option,nameList,ASTFactory.makeSlotList(slotList),constraint)
			
			
			;
			}   
			
		}
		return result;
	}
	
	public final TomTerm  unamedVariableOrTermStringIdentifier(
		LinkedList options
	) throws RecognitionException, TokenStreamException, TomException {
		TomTerm result;
		
		Token  nameUnderscore = null;
		Token  nameID = null;
		Token  nameString = null;
		
		result = null;
		LinkedList optionList = (options==null)?new LinkedList():options;
		OptionList option = null;
		NameList nameList = null;
		
		
		{
		switch ( LA(1)) {
		case UNDERSCORE:
		{
			nameUnderscore = LT(1);
			match(UNDERSCORE);
			if ( inputState.guessing==0 ) {
				
				text.append(nameUnderscore.getText());
				optionList.add(tom_make_OriginTracking(tom_make_Name(nameUnderscore.getText()),nameUnderscore.getLine(),currentFile()));
				option = ASTFactory.makeOptionList(optionList);
				result = tom_make_UnamedVariable(option,tom_make_TomTypeAlone("unknown type"),tom_empty_list_concConstraint());
				
			}
			break;
		}
		case ALL_ID:
		{
			nameID = LT(1);
			match(ALL_ID);
			if ( inputState.guessing==0 ) {
				
				text.append(nameID.getText());
				optionList.add(tom_make_OriginTracking(tom_make_Name(nameID.getText()),nameID.getLine(),currentFile()));
				option = ASTFactory.makeOptionList(optionList);
				result = tom_make_Variable(option,tom_make_Name(nameID.getText()),tom_make_TomTypeAlone("unknown type"),tom_empty_list_concConstraint());
				
			}
			break;
		}
		case STRING:
		{
			nameString = LT(1);
			match(STRING);
			if ( inputState.guessing==0 ) {
				
				text.append(nameString.getText());
				optionList.add(tom_make_OriginTracking(tom_make_Name(nameString.getText()),nameString.getLine(),currentFile()));
				option = ASTFactory.makeOptionList(optionList);
				ASTFactory.makeStringSymbol(symbolTable,nameString.getText(),optionList);
				nameList = tom_cons_list_concTomName(tom_make_Name(nameString.getText()),tom_empty_list_concTomName());
				result = tom_make_TermAppl(option,nameList,tom_empty_list_concTomTerm(),tom_empty_list_concConstraint());
				
			}
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		return result;
	}
	
	public final boolean  xmlTermList(
		LinkedList list
	) throws RecognitionException, TokenStreamException, TomException {
		boolean result;
		
		
		result = false;
		TomTerm term;
		
		
		{
		_loop80:
		do {
			if ((_tokenSet_0.member(LA(1)))) {
				term=annotedTerm();
				if ( inputState.guessing==0 ) {
					list.add(term);
				}
			}
			else {
				break _loop80;
			}
			
		} while (true);
		}
		if ( inputState.guessing==0 ) {
			result = true;
		}
		return result;
	}
	
	public final boolean  implicitTermList(
		LinkedList list
	) throws RecognitionException, TokenStreamException, TomException {
		boolean result;
		
		
		result = false;
		TomTerm term;
		
		
		{
		match(LBRACKET);
		if ( inputState.guessing==0 ) {
			text.append("[");
		}
		{
		switch ( LA(1)) {
		case NUM_INT:
		case CHARACTER:
		case STRING:
		case NUM_FLOAT:
		case NUM_LONG:
		case NUM_DOUBLE:
		case LPAREN:
		case ALL_ID:
		case XML_START:
		case XML_TEXT:
		case XML_COMMENT:
		case XML_PROC:
		case LBRACKET:
		case UNDERSCORE:
		{
			term=annotedTerm();
			if ( inputState.guessing==0 ) {
				list.add(term);
			}
			{
			_loop93:
			do {
				if ((LA(1)==COMMA)) {
					match(COMMA);
					if ( inputState.guessing==0 ) {
						text.append(",");
					}
					term=annotedTerm();
					if ( inputState.guessing==0 ) {
						list.add(term);
					}
				}
				else {
					break _loop93;
				}
				
			} while (true);
			}
			break;
		}
		case RBRACKET:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(RBRACKET);
		if ( inputState.guessing==0 ) {
			
			text.append("]");
			result=true;
			
		}
		}
		return result;
	}
	
	public final void termList(
		LinkedList list
	) throws RecognitionException, TokenStreamException, TomException {
		
		
		TomTerm term = null;
		
		
		{
		term=annotedTerm();
		if ( inputState.guessing==0 ) {
			list.add(term);
		}
		{
		_loop103:
		do {
			if ((LA(1)==COMMA)) {
				match(COMMA);
				if ( inputState.guessing==0 ) {
					text.append(',');
				}
				term=annotedTerm();
				if ( inputState.guessing==0 ) {
					list.add(term);
				}
			}
			else {
				break _loop103;
			}
			
		} while (true);
		}
		}
	}
	
	public final void pairList(
		LinkedList list
	) throws RecognitionException, TokenStreamException, TomException {
		
		Token  name = null;
		Token  name2 = null;
		
		TomTerm term = null;
		
		
		{
		name = LT(1);
		match(ALL_ID);
		match(EQUAL);
		if ( inputState.guessing==0 ) {
			
			text.append(name.getText());
			text.append('=');
			
		}
		term=annotedTerm();
		if ( inputState.guessing==0 ) {
			list.add(tom_make_PairSlotAppl(tom_make_Name(name.getText()),term));
		}
		{
		_loop107:
		do {
			if ((LA(1)==COMMA)) {
				match(COMMA);
				if ( inputState.guessing==0 ) {
					text.append(',');
				}
				name2 = LT(1);
				match(ALL_ID);
				match(EQUAL);
				if ( inputState.guessing==0 ) {
					
					text.append(name2.getText());
					text.append('=');
					
				}
				term=annotedTerm();
				if ( inputState.guessing==0 ) {
					list.add(tom_make_PairSlotAppl(tom_make_Name(name2.getText()),term));
				}
			}
			else {
				break _loop107;
			}
			
		} while (true);
		}
		}
	}
	
	public final TomName  headSymbolOrConstant(
		LinkedList optionList
	) throws RecognitionException, TokenStreamException {
		TomName result;
		
		
		result = null;
		
		
		{
		switch ( LA(1)) {
		case ALL_ID:
		{
			result=headSymbol(optionList);
			break;
		}
		case NUM_INT:
		case CHARACTER:
		case STRING:
		case NUM_FLOAT:
		case NUM_LONG:
		case NUM_DOUBLE:
		{
			result=headConstant(optionList);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		return result;
	}
	
	public final Declaration  operator() throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  type = null;
		Token  name = null;
		Token  slotName = null;
		Token  typeArg = null;
		Token  slotName2 = null;
		Token  typeArg2 = null;
		Token  t = null;
		
		result=null;
		Option ot = null;
		TomTypeList types = tom_make_emptyTomTypeList();
		LinkedList options = new LinkedList();
		LinkedList slotNameList = new LinkedList();
		LinkedList pairNameDeclList = new LinkedList();
		TomName astName = null;
		String stringSlotName = null;
		Declaration attribute;
		
		
		type = LT(1);
		match(ALL_ID);
		name = LT(1);
		match(ALL_ID);
		if ( inputState.guessing==0 ) {
			
			ot = tom_make_OriginTracking(tom_make_Name(name.getText()),name.getLine(),currentFile());
			options.add(ot);
			
		}
		{
		match(LPAREN);
		{
		switch ( LA(1)) {
		case ALL_ID:
		{
			slotName = LT(1);
			match(ALL_ID);
			match(COLON);
			typeArg = LT(1);
			match(ALL_ID);
			if ( inputState.guessing==0 ) {
				
				stringSlotName = slotName.getText(); 
				astName = tom_make_Name(stringSlotName);
				slotNameList.add(astName); 
				pairNameDeclList.add(tom_make_PairNameDecl(astName,tom_make_EmptyDeclaration())); 
				types = (TomTypeList) types.append(tom_make_TomTypeAlone(typeArg.getText()));
				
			}
			{
			_loop126:
			do {
				if ((LA(1)==COMMA)) {
					match(COMMA);
					slotName2 = LT(1);
					match(ALL_ID);
					match(COLON);
					typeArg2 = LT(1);
					match(ALL_ID);
					if ( inputState.guessing==0 ) {
						
						stringSlotName = slotName2.getText(); 
						astName = ASTFactory.makeName(stringSlotName);
						if(slotNameList.indexOf(astName) != -1) {
						getLogger().log(new PlatformLogRecord(Level.SEVERE, TomMessage.repeatedSlotName,
						new Object[]{stringSlotName},
						currentFile(), getLine()));
						}
						slotNameList.add(astName); 
						pairNameDeclList.add(tom_make_PairNameDecl(tom_make_Name(stringSlotName),tom_make_EmptyDeclaration())); 
						types = (TomTypeList) types.append(tom_make_TomTypeAlone(typeArg2.getText()));
						
					}
				}
				else {
					break _loop126;
				}
				
			} while (true);
			}
			break;
		}
		case RPAREN:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(RPAREN);
		}
		match(LBRACE);
		if ( inputState.guessing==0 ) {
			
			astName = tom_make_Name(name.getText());
			
		}
		{
		_loop128:
		do {
			switch ( LA(1)) {
			case MAKE:
			{
				attribute=keywordMake(name.getText(),tom_make_TomTypeAlone(type.getText()),types);
				if ( inputState.guessing==0 ) {
					options.add(attribute);
				}
				break;
			}
			case GET_SLOT:
			{
				attribute=keywordGetSlot(astName,type.getText());
				if ( inputState.guessing==0 ) {
					
					TomName sName = attribute.getSlotName();
					/*
					* ensure that sName appears in slotNameList, only once
					* ensure that sName has not already been generated
					*/
					//System.out.println("slotNameList = " + slotNameList);
					//System.out.println("sName      = " + sName);
					
					TomMessage msg = null;
					int index = slotNameList.indexOf(sName);
					if(index == -1) {
					msg = TomMessage.errorIncompatibleSlotDecl;
					} else {
					PairNameDecl pair = (PairNameDecl) pairNameDeclList.get(index);
					if(pair instanceof  tom.engine.adt.tomsignature.types.PairNameDecl) { { tom.engine.adt.tomsignature.types.PairNameDecl tom_match2_1=(( tom.engine.adt.tomsignature.types.PairNameDecl)pair); if (tom_is_fun_sym_PairNameDecl(tom_match2_1) ||  false ) { { tom.engine.adt.tomsignature.types.Declaration tom_match2_1_slotDecl=tom_get_slot_PairNameDecl_slotDecl(tom_match2_1); { tom.engine.adt.tomsignature.types.Declaration tom_decl=tom_match2_1_slotDecl; if ( true ) {
					
					if(tom_decl!= tom_make_EmptyDeclaration()) {
					msg = TomMessage.errorTwoSameSlotDecl;
					}
					} } } } } }
					
					}
					if(msg != null) {
					getLogger().log(new PlatformLogRecord(Level.SEVERE, msg,
					new Object[]{currentFile(), new Integer(attribute.getOrgTrack().getLine()),
					"%op "+type.getText(), new Integer(ot.getLine()), sName.getString()} ,
					currentFile(), getLine()));
					} else {
					pairNameDeclList.set(index,tom_make_PairNameDecl(sName,attribute));
					}
					
				}
				break;
			}
			case IS_FSYM:
			{
				attribute=keywordIsFsym(astName,type.getText());
				if ( inputState.guessing==0 ) {
					options.add(attribute);
				}
				break;
			}
			default:
			{
				break _loop128;
			}
			}
		} while (true);
		}
		t = LT(1);
		match(RBRACE);
		if ( inputState.guessing==0 ) {
			
			
			//System.out.println("pairNameDeclList = " + pairNameDeclList);
			
			TomSymbol astSymbol = ASTFactory.makeSymbol(name.getText(), tom_make_TomTypeAlone(type.getText()), types, ASTFactory.makePairNameDeclList(pairNameDeclList), options);
			putSymbol(name.getText(),astSymbol);
			result = tom_make_SymbolDecl(astName);
			updatePosition(t.getLine(),t.getColumn());
			selector().pop(); 
			
		}
		return result;
	}
	
	public final Declaration  keywordMake(
		String opname, TomType returnType, TomTypeList types
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		Token  typeArg = null;
		Token  nameArg = null;
		Token  l = null;
		
		result = null;
		Option ot = null;
		TomList args = tom_make_emptyTomList();
		int index = 0;
		TomType type;
		int nbTypes = types.getLength();
		
		
		{
		t = LT(1);
		match(MAKE);
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		{
		switch ( LA(1)) {
		case LPAREN:
		{
			match(LPAREN);
			{
			switch ( LA(1)) {
			case ALL_ID:
			{
				typeArg = LT(1);
				match(ALL_ID);
				if ( inputState.guessing==0 ) {
					
					if( !(nbTypes > 0) ) {
					type = tom_make_EmptyType();
					} else {
					type = (TomType)types.elementAt(index++);
					}
					Option info1 = tom_make_OriginTracking(tom_make_Name(typeArg.getText()),typeArg.getLine(),currentFile());  
					OptionList option1 = tom_cons_list_concOption(info1,tom_empty_list_concOption());
					
					args = (TomList) args.append(tom_make_Variable(option1,tom_make_Name(typeArg.getText()),type,tom_make_emptyConstraintList()
					)
					
					
					
					);
					
				}
				{
				_loop166:
				do {
					if ((LA(1)==COMMA)) {
						match(COMMA);
						nameArg = LT(1);
						match(ALL_ID);
						if ( inputState.guessing==0 ) {
							
							if( index >= nbTypes ) {
							type = tom_make_EmptyType();
							} else {
							type = (TomType)types.elementAt(index++);
							}
							Option info2 = tom_make_OriginTracking(tom_make_Name(nameArg.getText()),nameArg.getLine(),currentFile());
							OptionList option2 = tom_cons_list_concOption(info2,tom_empty_list_concOption());
							
							args = (TomList) args.append(tom_make_Variable(option2,tom_make_Name(nameArg.getText()),type,tom_make_emptyConstraintList()
							)
							
							
							
							);
							
						}
					}
					else {
						break _loop166;
					}
					
				} while (true);
				}
				break;
			}
			case RPAREN:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(RPAREN);
			break;
		}
		case LBRACE:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		l = LT(1);
		match(LBRACE);
		if ( inputState.guessing==0 ) {
			
			updatePosition(t.getLine(),t.getColumn());
			selector().push("targetlexer");
			LinkedList blockList = new LinkedList();
			TargetLanguage tlCode = targetparser.targetLanguage(blockList);
			selector().pop();
			blockList.add(tlCode);
			result = tom_make_MakeDecl(tom_make_Name(opname),returnType,args,tom_make_AbstractBlock(ASTFactory.makeInstructionList(blockList)),ot);
			
		}
		}
		return result;
	}
	
	public final Declaration  keywordGetSlot(
		TomName astName, String type
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		Token  slotName = null;
		Token  name = null;
		
		result = null;
		Option ot = null;
		
		
		{
		t = LT(1);
		match(GET_SLOT);
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		match(LPAREN);
		slotName = LT(1);
		match(ALL_ID);
		match(COMMA);
		name = LT(1);
		match(ALL_ID);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			
			Option info = tom_make_OriginTracking(tom_make_Name(name.getText()),name.getLine(),currentFile());
			OptionList option = tom_cons_list_concOption(info,tom_empty_list_concOption());
			
			selector().push("targetlexer");
			TargetLanguage tlCode = targetparser.goalLanguage(new LinkedList());
			selector().pop(); 
			
			result = tom_make_GetSlotDecl(astName,tom_make_Name(slotName.getText()),tom_make_Variable(option,tom_make_Name(name.getText()),tom_make_TomTypeAlone(type),tom_make_emptyConstraintList()),tom_make_Return(tom_make_TargetLanguageToTomTerm(tlCode)),ot)
			
			
			;
			
		}
		}
		return result;
	}
	
	public final Declaration  keywordIsFsym(
		TomName astName, String typeString
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		Token  name = null;
		
		result = null;
		Option ot = null;
		
		
		t = LT(1);
		match(IS_FSYM);
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		match(LPAREN);
		name = LT(1);
		match(ALL_ID);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			
			Option info = tom_make_OriginTracking(tom_make_Name(name.getText()),name.getLine(),currentFile());
			OptionList option = tom_cons_list_concOption(info,tom_empty_list_concOption());
			
			selector().push("targetlexer");
			TargetLanguage tlCode = targetparser.goalLanguage(new LinkedList());
			selector().pop();
			
			result = tom_make_IsFsymDecl(astName,tom_make_Variable(option,tom_make_Name(name.getText()),tom_make_TomTypeAlone(typeString),tom_make_emptyConstraintList()),tom_make_Return(tom_make_TargetLanguageToTomTerm(tlCode)),ot)
			
			;
			
		}
		return result;
	}
	
	public final Declaration  operatorList() throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  type = null;
		Token  name = null;
		Token  typeArg = null;
		Token  t = null;
		
		result = null;
		TomTypeList types = tom_make_emptyTomTypeList();
		LinkedList options = new LinkedList();
		Declaration attribute = null;
		
		
		type = LT(1);
		match(ALL_ID);
		name = LT(1);
		match(ALL_ID);
		if ( inputState.guessing==0 ) {
			
			Option ot = tom_make_OriginTracking(tom_make_Name(name.getText()),name.getLine(),currentFile());
			options.add(ot);
			
		}
		match(LPAREN);
		typeArg = LT(1);
		match(ALL_ID);
		match(STAR);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			
			types = (TomTypeList) types.append(tom_make_TomTypeAlone(typeArg.getText()));
			
		}
		match(LBRACE);
		{
		_loop131:
		do {
			switch ( LA(1)) {
			case MAKE_EMPTY:
			{
				attribute=keywordMakeEmptyList(name.getText());
				if ( inputState.guessing==0 ) {
					options.add(attribute);
				}
				break;
			}
			case MAKE_INSERT:
			{
				attribute=keywordMakeAddList(name.getText(),type.getText(),typeArg.getText());
				if ( inputState.guessing==0 ) {
					options.add(attribute);
				}
				break;
			}
			case IS_FSYM:
			{
				attribute=keywordIsFsym(tom_make_Name(name.getText()), type.getText());
				if ( inputState.guessing==0 ) {
					options.add(attribute);
				}
				break;
			}
			case GET_HEAD:
			{
				attribute=keywordGetHead(tom_make_Name(name.getText()), type.getText());
				if ( inputState.guessing==0 ) {
					options.add(attribute);
				}
				break;
			}
			case GET_TAIL:
			{
				attribute=keywordGetTail(tom_make_Name(name.getText()), type.getText());
				if ( inputState.guessing==0 ) {
					options.add(attribute);
				}
				break;
			}
			case IS_EMPTY:
			{
				attribute=keywordIsEmpty(tom_make_Name(name.getText()), type.getText());
				if ( inputState.guessing==0 ) {
					options.add(attribute);
				}
				break;
			}
			default:
			{
				break _loop131;
			}
			}
		} while (true);
		}
		t = LT(1);
		match(RBRACE);
		if ( inputState.guessing==0 ) {
			
			PairNameDeclList pairNameDeclList = tom_cons_list_concPairNameDecl(tom_make_PairNameDecl(tom_make_EmptyName(),tom_make_EmptyDeclaration()),tom_empty_list_concPairNameDecl());
			TomSymbol astSymbol = ASTFactory.makeSymbol(name.getText(), tom_make_TomTypeAlone(type.getText()), types, pairNameDeclList, options);
			putSymbol(name.getText(),astSymbol);
			result = tom_make_ListSymbolDecl(tom_make_Name(name.getText()));
			updatePosition(t.getLine(),t.getColumn());
			selector().pop(); 
			
		}
		return result;
	}
	
	public final Declaration  keywordMakeEmptyList(
		String name
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		
		result = null;
		Option ot = null;
		
		
		t = LT(1);
		match(MAKE_EMPTY);
		{
		switch ( LA(1)) {
		case LPAREN:
		{
			match(LPAREN);
			match(RPAREN);
			break;
		}
		case LBRACE:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		match(LBRACE);
		if ( inputState.guessing==0 ) {
			
			selector().push("targetlexer");
			LinkedList blockList = new LinkedList();
			TargetLanguage tlCode = targetparser.targetLanguage(blockList);
			selector().pop();
			blockList.add(tlCode);
			result = tom_make_MakeEmptyList(tom_make_Name(name),tom_make_AbstractBlock(ASTFactory.makeInstructionList(blockList)),ot);
			
		}
		return result;
	}
	
	public final Declaration  keywordMakeAddList(
		String name, String listType, String elementType
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		Token  elementName = null;
		Token  listName = null;
		
		result = null;
		Option ot = null;
		
		
		t = LT(1);
		match(MAKE_INSERT);
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		match(LPAREN);
		elementName = LT(1);
		match(ALL_ID);
		match(COMMA);
		listName = LT(1);
		match(ALL_ID);
		match(RPAREN);
		match(LBRACE);
		if ( inputState.guessing==0 ) {
			
			Option listInfo = tom_make_OriginTracking(tom_make_Name(listName.getText()),listName.getLine(),currentFile());  
			Option elementInfo = tom_make_OriginTracking(tom_make_Name(elementName.getText()),elementName.getLine(),currentFile());
			OptionList listOption = tom_cons_list_concOption(listInfo,tom_empty_list_concOption());
			OptionList elementOption = tom_cons_list_concOption(elementInfo,tom_empty_list_concOption());
			
			selector().push("targetlexer");
			LinkedList blockList = new LinkedList();
			TargetLanguage tlCode = targetparser.targetLanguage(blockList);
			selector().pop();
			blockList.add(tlCode);
			result = tom_make_MakeAddList(tom_make_Name(name),tom_make_Variable(elementOption,tom_make_Name(elementName.getText()),tom_make_TomTypeAlone(elementType),tom_make_emptyConstraintList()),tom_make_Variable(listOption,tom_make_Name(listName.getText()),tom_make_TomTypeAlone(listType),tom_make_emptyConstraintList()),tom_make_AbstractBlock(ASTFactory.makeInstructionList(blockList)),ot)
			
			
			;
			
		}
		return result;
	}
	
	public final Declaration  keywordGetHead(
		TomName opname, String type
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		Token  name = null;
		
		result = null;
		Option ot = null;
		
		
		{
		t = LT(1);
		match(GET_HEAD);
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		match(LPAREN);
		name = LT(1);
		match(ALL_ID);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			
			Option info = tom_make_OriginTracking(tom_make_Name(name.getText()),name.getLine(),currentFile());
			OptionList option = tom_cons_list_concOption(info,tom_empty_list_concOption());
			
			selector().push("targetlexer");
			TargetLanguage tlCode = targetparser.goalLanguage(new LinkedList());
			selector().pop();  
			
			result = tom_make_GetHeadDecl(opname,symbolTable.getUniversalType(),tom_make_Variable(option,tom_make_Name(name.getText()),tom_make_TomTypeAlone(type),tom_make_emptyConstraintList()),tom_make_Return(tom_make_TargetLanguageToTomTerm(tlCode)),ot)
			
			
			
			;
			
		}
		}
		return result;
	}
	
	public final Declaration  keywordGetTail(
		TomName opname, String type
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		Token  name = null;
		
		result = null;
		Option ot = null;
		
		
		{
		t = LT(1);
		match(GET_TAIL);
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		match(LPAREN);
		name = LT(1);
		match(ALL_ID);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			
			Option info = tom_make_OriginTracking(tom_make_Name(name.getText()),name.getLine(),currentFile());
			OptionList option = tom_cons_list_concOption(info,tom_empty_list_concOption());
			
			selector().push("targetlexer");
			TargetLanguage tlCode = targetparser.goalLanguage(new LinkedList());
			selector().pop();  
			
			result = tom_make_GetTailDecl(opname,tom_make_Variable(option,tom_make_Name(name.getText()),tom_make_TomTypeAlone(type),tom_make_emptyConstraintList()),tom_make_Return(tom_make_TargetLanguageToTomTerm(tlCode)),ot)
			
			
			;
			
		}
		}
		return result;
	}
	
	public final Declaration  keywordIsEmpty(
		TomName opname, String type
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		Token  name = null;
		
		result = null;
		Option ot = null;
		
		
		{
		t = LT(1);
		match(IS_EMPTY);
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		match(LPAREN);
		name = LT(1);
		match(ALL_ID);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			
			Option info = tom_make_OriginTracking(tom_make_Name(name.getText()),name.getLine(),currentFile());
			OptionList option = tom_cons_list_concOption(info,tom_empty_list_concOption());
			
			selector().push("targetlexer");
			TargetLanguage  tlCode = targetparser.goalLanguage(new LinkedList());
			selector().pop(); 
			
			result = tom_make_IsEmptyDecl(opname,tom_make_Variable(option,tom_make_Name(name.getText()),tom_make_TomTypeAlone(type),tom_make_emptyConstraintList()),tom_make_Return(tom_make_TargetLanguageToTomTerm(tlCode)),ot)
			
			
			; 
			
		}
		}
		return result;
	}
	
	public final Declaration  operatorArray() throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  type = null;
		Token  name = null;
		Token  typeArg = null;
		Token  t = null;
		
		result = null;
		TomTypeList types = tom_make_emptyTomTypeList();
		LinkedList options = new LinkedList();
		Declaration attribute = null;
		
		
		type = LT(1);
		match(ALL_ID);
		name = LT(1);
		match(ALL_ID);
		if ( inputState.guessing==0 ) {
			
			Option ot = tom_make_OriginTracking(tom_make_Name(name.getText()),name.getLine(),currentFile());
			options.add(ot);
			
		}
		match(LPAREN);
		typeArg = LT(1);
		match(ALL_ID);
		match(STAR);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			
			types = (TomTypeList) types.append(tom_make_TomTypeAlone(typeArg.getText()));
			
		}
		match(LBRACE);
		{
		_loop134:
		do {
			switch ( LA(1)) {
			case MAKE_EMPTY:
			{
				attribute=keywordMakeEmptyArray(name.getText(),type.getText());
				if ( inputState.guessing==0 ) {
					options.add(attribute);
				}
				break;
			}
			case MAKE_APPEND:
			{
				attribute=keywordMakeAddArray(name.getText(),type.getText(),typeArg.getText());
				if ( inputState.guessing==0 ) {
					options.add(attribute);
				}
				break;
			}
			case IS_FSYM:
			{
				attribute=keywordIsFsym(tom_make_Name(name.getText()),type.getText());
				if ( inputState.guessing==0 ) {
					options.add(attribute);
				}
				break;
			}
			case GET_ELEMENT:
			{
				attribute=keywordGetElement(tom_make_Name(name.getText()), type.getText());
				if ( inputState.guessing==0 ) {
					options.add(attribute);
				}
				break;
			}
			case GET_SIZE:
			{
				attribute=keywordGetSize(tom_make_Name(name.getText()), type.getText());
				if ( inputState.guessing==0 ) {
					options.add(attribute);
				}
				break;
			}
			default:
			{
				break _loop134;
			}
			}
		} while (true);
		}
		t = LT(1);
		match(RBRACE);
		if ( inputState.guessing==0 ) {
			
			PairNameDeclList pairNameDeclList = tom_cons_list_concPairNameDecl(tom_make_PairNameDecl(tom_make_EmptyName(),tom_make_EmptyDeclaration()),tom_empty_list_concPairNameDecl());
			TomSymbol astSymbol = ASTFactory.makeSymbol(name.getText(), tom_make_TomTypeAlone(type.getText()), types, pairNameDeclList, options);
			putSymbol(name.getText(),astSymbol);
			
			result = tom_make_ArraySymbolDecl(tom_make_Name(name.getText()));
			
			updatePosition(t.getLine(),t.getColumn());
			
			selector().pop(); 
			
		}
		return result;
	}
	
	public final Declaration  keywordMakeEmptyArray(
		String name, String listType
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		Token  listName = null;
		
		result = null;
		Option ot = null;
		
		
		t = LT(1);
		match(MAKE_EMPTY);
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		match(LPAREN);
		listName = LT(1);
		match(ALL_ID);
		match(RPAREN);
		match(LBRACE);
		if ( inputState.guessing==0 ) {
			
			Option listInfo = tom_make_OriginTracking(tom_make_Name(listName.getText()),listName.getLine(),currentFile());  
			OptionList listOption = tom_cons_list_concOption(listInfo,tom_empty_list_concOption());
			
			selector().push("targetlexer");
			LinkedList blockList = new LinkedList();
			TargetLanguage tlCode = targetparser.targetLanguage(blockList);
			selector().pop();
			blockList.add(tlCode);
			result = tom_make_MakeEmptyArray(tom_make_Name(name),tom_make_Variable(listOption,tom_make_Name(listName.getText()),tom_make_TomTypeAlone(listType),tom_make_emptyConstraintList()),tom_make_AbstractBlock(ASTFactory.makeInstructionList(blockList)),ot)
			
			;
			
		}
		return result;
	}
	
	public final Declaration  keywordMakeAddArray(
		String name, String listType, String elementType
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		Token  elementName = null;
		Token  listName = null;
		
		result = null;
		Option ot = null;
		
		
		t = LT(1);
		match(MAKE_APPEND);
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		match(LPAREN);
		elementName = LT(1);
		match(ALL_ID);
		match(COMMA);
		listName = LT(1);
		match(ALL_ID);
		match(RPAREN);
		match(LBRACE);
		if ( inputState.guessing==0 ) {
			
			selector().push("targetlexer");
			LinkedList blockList = new LinkedList();
			TargetLanguage tlCode = targetparser.targetLanguage(blockList);
			selector().pop();
			blockList.add(tlCode);
			
			Option listInfo = tom_make_OriginTracking(tom_make_Name(listName.getText()),listName.getLine(),currentFile());  
			Option elementInfo = tom_make_OriginTracking(tom_make_Name(elementName.getText()),elementName.getLine(),currentFile());
			OptionList listOption = tom_cons_list_concOption(listInfo,tom_empty_list_concOption());
			OptionList elementOption = tom_cons_list_concOption(elementInfo,tom_empty_list_concOption());
			
			result = tom_make_MakeAddArray(tom_make_Name(name),tom_make_Variable(elementOption,tom_make_Name(elementName.getText()),tom_make_TomTypeAlone(elementType),tom_make_emptyConstraintList()),tom_make_Variable(listOption,tom_make_Name(listName.getText()),tom_make_TomTypeAlone(listType),tom_make_emptyConstraintList()),tom_make_AbstractBlock(ASTFactory.makeInstructionList(blockList)),ot)
			
			
			;
			
		}
		return result;
	}
	
	public final Declaration  keywordGetElement(
		TomName opname, String type
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		Token  name1 = null;
		Token  name2 = null;
		
		result = null;
		Option ot = null;
		
		
		{
		t = LT(1);
		match(GET_ELEMENT);
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		match(LPAREN);
		name1 = LT(1);
		match(ALL_ID);
		match(COMMA);
		name2 = LT(1);
		match(ALL_ID);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			
			Option info1 = tom_make_OriginTracking(tom_make_Name(name1.getText()),name1.getLine(),currentFile());
			Option info2 = tom_make_OriginTracking(tom_make_Name(name2.getText()),name2.getLine(),currentFile());
			OptionList option1 = tom_cons_list_concOption(info1,tom_empty_list_concOption());
			OptionList option2 = tom_cons_list_concOption(info2,tom_empty_list_concOption());
			
			selector().push("targetlexer");
			TargetLanguage tlCode = targetparser.goalLanguage(new LinkedList());
			selector().pop();  
			
			result = tom_make_GetElementDecl(opname,tom_make_Variable(option1,tom_make_Name(name1.getText()),tom_make_TomTypeAlone(type),tom_make_emptyConstraintList()),tom_make_Variable(option2,tom_make_Name(name2.getText()),tom_make_TomTypeAlone("int"),tom_make_emptyConstraintList()),tom_make_Return(tom_make_TargetLanguageToTomTerm(tlCode)),ot)
			
			
			;
			
		}
		}
		return result;
	}
	
	public final Declaration  keywordGetSize(
		TomName opname, String type
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		Token  name = null;
		
		result = null;
		Option ot = null;
		
		
		{
		t = LT(1);
		match(GET_SIZE);
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		match(LPAREN);
		name = LT(1);
		match(ALL_ID);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			
			Option info = tom_make_OriginTracking(tom_make_Name(name.getText()),name.getLine(),currentFile());
			OptionList option = tom_cons_list_concOption(info,tom_empty_list_concOption());
			
			selector().push("targetlexer");
			TargetLanguage tlCode = targetparser.goalLanguage(new LinkedList());
			selector().pop();  
			
			result = tom_make_GetSizeDecl(opname,tom_make_Variable(option,tom_make_Name(name.getText()),tom_make_TomTypeAlone(type),tom_make_emptyConstraintList()),tom_make_Return(tom_make_TargetLanguageToTomTerm(tlCode)),ot)
			
			;
			
		}
		}
		return result;
	}
	
	public final Declaration  typeTerm() throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  type = null;
		Token  t = null;
		
		result = null;
		Option ot = null;
		Declaration attribute = null;
		TargetLanguage implement = null;
		TomForwardType tomFwdType = tom_make_EmptyForward();
		DeclarationList declarationList = tom_make_emptyDeclarationList();
				String s;
		
		
		{
		type = LT(1);
		match(ALL_ID);
		if ( inputState.guessing==0 ) {
			
			ot = tom_make_OriginTracking(tom_make_Name(type.getText()),type.getLine(),currentFile());
			
		}
		match(LBRACE);
		implement=keywordImplement();
		{
		_loop138:
		do {
			switch ( LA(1)) {
			case VISITOR_FWD:
			{
				s=keywordVisitorFwd();
				if ( inputState.guessing==0 ) {
					tomFwdType = tom_make_TLForward(s);
				}
				break;
			}
			case EQUALS:
			{
				attribute=keywordEquals(type.getText());
				if ( inputState.guessing==0 ) {
					declarationList = tom_make_manyDeclarationList(attribute,declarationList);
				}
				break;
			}
			case CHECK_STAMP:
			{
				attribute=keywordCheckStamp(type.getText());
				if ( inputState.guessing==0 ) {
					declarationList = tom_make_manyDeclarationList(attribute,declarationList);
				}
				break;
			}
			case SET_STAMP:
			{
				attribute=keywordSetStamp(type.getText());
				if ( inputState.guessing==0 ) {
					declarationList = tom_make_manyDeclarationList(attribute,declarationList);
				}
				break;
			}
			case GET_IMPLEMENTATION:
			{
				attribute=keywordGetImplementation(type.getText());
				if ( inputState.guessing==0 ) {
					declarationList = tom_make_manyDeclarationList(attribute,declarationList);
				}
				break;
			}
			default:
			{
				break _loop138;
			}
			}
		} while (true);
		}
		t = LT(1);
		match(RBRACE);
		}
		if ( inputState.guessing==0 ) {
			
			TomType astType = tom_make_Type(tom_make_ASTTomType(type.getText()),tom_make_TLType(implement));
			putTypeDefinition(type.getText(), astType, tomFwdType); 
			result = tom_make_TypeTermDecl(tom_make_Name(type.getText()),declarationList,ot);
			updatePosition(t.getLine(),t.getColumn());
			selector().pop();
			
		}
		return result;
	}
	
	public final TargetLanguage  keywordImplement() throws RecognitionException, TokenStreamException, TomException {
		TargetLanguage tlCode;
		
		
		tlCode = null;
		
		
		{
		match(IMPLEMENT);
		if ( inputState.guessing==0 ) {
			
			selector().push("targetlexer");
			tlCode = targetparser.goalLanguage(new LinkedList());
			selector().pop();
			
		}
		}
		return tlCode;
	}
	
	public final String  keywordVisitorFwd() throws RecognitionException, TokenStreamException, TomException {
		String code;
		
		
		code = "";
		
		
		{
		match(VISITOR_FWD);
		if ( inputState.guessing==0 ) {
			
			selector().push("targetlexer");
			code = targetparser.goalLanguage(new LinkedList()).getCode();
			selector().pop();
			
		}
		}
		return code;
	}
	
	public final Declaration  keywordEquals(
		String type
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		Token  name1 = null;
		Token  name2 = null;
		
		result = null;
		Option ot = null;
		
		
		{
		t = LT(1);
		match(EQUALS);
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		match(LPAREN);
		name1 = LT(1);
		match(ALL_ID);
		match(COMMA);
		name2 = LT(1);
		match(ALL_ID);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			
			Option info1 = tom_make_OriginTracking(tom_make_Name(name1.getText()),name1.getLine(),currentFile());
			Option info2 = tom_make_OriginTracking(tom_make_Name(name2.getText()),name2.getLine(),currentFile());
			OptionList option1 = tom_cons_list_concOption(info1,tom_empty_list_concOption());
			OptionList option2 = tom_cons_list_concOption(info2,tom_empty_list_concOption());
			
			selector().push("targetlexer");
			TargetLanguage tlCode = targetparser.goalLanguage(new LinkedList());
			selector().pop();  
			
			result = tom_make_TermsEqualDecl(tom_make_Variable(option1,tom_make_Name(name1.getText()),tom_make_TomTypeAlone(type),tom_make_emptyConstraintList()),tom_make_Variable(option2,tom_make_Name(name2.getText()),tom_make_TomTypeAlone(type),tom_make_emptyConstraintList()),tom_make_Return(tom_make_TargetLanguageToTomTerm(tlCode)),ot)
			
			
			;
			
		}
		}
		return result;
	}
	
	public final Declaration  keywordCheckStamp(
		String typeString
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		Token  name = null;
		
		result = null;
		Option ot = null;
		
		
		t = LT(1);
		match(CHECK_STAMP);
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		match(LPAREN);
		name = LT(1);
		match(ALL_ID);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			
			Option info = tom_make_OriginTracking(tom_make_Name(name.getText()),name.getLine(),currentFile());
			OptionList option = tom_cons_list_concOption(info,tom_empty_list_concOption());
			
			selector().push("targetlexer");
			TargetLanguage tlCode = targetparser.goalLanguage(new LinkedList());
			selector().pop();
			
			result = tom_make_CheckStampDecl(tom_make_Variable(option,tom_make_Name(name.getText()),tom_make_TomTypeAlone(typeString),tom_make_emptyConstraintList()),tom_make_TargetLanguageToInstruction(tlCode),ot)
			;
			
		}
		return result;
	}
	
	public final Declaration  keywordSetStamp(
		String typeString
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		Token  name = null;
		
		result = null;
		Option ot = null;
		
		
		t = LT(1);
		match(SET_STAMP);
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		match(LPAREN);
		name = LT(1);
		match(ALL_ID);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			
			Option info = tom_make_OriginTracking(tom_make_Name(name.getText()),name.getLine(),currentFile());
			OptionList option = tom_cons_list_concOption(info,tom_empty_list_concOption());
			
			selector().push("targetlexer");
			TargetLanguage tlCode = targetparser.goalLanguage(new LinkedList());
			selector().pop();
			
			result = tom_make_SetStampDecl(tom_make_Variable(option,tom_make_Name(name.getText()),tom_make_TomTypeAlone(typeString),tom_make_emptyConstraintList()),tom_make_Return(tom_make_TargetLanguageToTomTerm(tlCode)),ot)
			;
			
		}
		return result;
	}
	
	public final Declaration  keywordGetImplementation(
		String typeString
	) throws RecognitionException, TokenStreamException, TomException {
		Declaration result;
		
		Token  t = null;
		Token  name = null;
		
		result = null;
		Option ot = null;
		
		
		t = LT(1);
		match(GET_IMPLEMENTATION);
		if ( inputState.guessing==0 ) {
			ot = tom_make_OriginTracking(tom_make_Name(t.getText()),t.getLine(),currentFile());
		}
		match(LPAREN);
		name = LT(1);
		match(ALL_ID);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			
			Option info = tom_make_OriginTracking(tom_make_Name(name.getText()),name.getLine(),currentFile());
			OptionList option = tom_cons_list_concOption(info,tom_empty_list_concOption());
			
			selector().push("targetlexer");
			TargetLanguage tlCode = targetparser.goalLanguage(new LinkedList());
			selector().pop();
			
			result = tom_make_GetImplementationDecl(tom_make_Variable(option,tom_make_Name(name.getText()),tom_make_TomTypeAlone(typeString),tom_make_emptyConstraintList()),tom_make_Return(tom_make_TargetLanguageToTomTerm(tlCode)),ot)
			;
			
		}
		return result;
	}
	
	
	public static final String[] _tokenNames = {
		"<0>",
		"EOF",
		"<2>",
		"NULL_TREE_LOOKAHEAD",
		"NUM_INT",
		"CHARACTER",
		"STRING",
		"NUM_FLOAT",
		"NUM_LONG",
		"NUM_DOUBLE",
		"LPAREN",
		"RPAREN",
		"LBRACE",
		"RBRACE",
		"COMMA",
		"ALL_ID",
		"BACKQUOTE",
		"COLON",
		"ALTERNATIVE",
		"\"when\"",
		"ARROW",
		"\"extends\"",
		"\"where\"",
		"AFFECT",
		"\"if\"",
		"DOUBLEEQ",
		"AT",
		"XML_START",
		"XML_CLOSE_SINGLETON",
		"XML_CLOSE",
		"XML_START_ENDING",
		"XML_TEXT",
		"XML_COMMENT",
		"XML_PROC",
		"LBRACKET",
		"RBRACKET",
		"EQUAL",
		"UNDERSCORE",
		"STAR",
		"\"implement\"",
		"\"visitor_fwd\"",
		"\"equals\"",
		"\"get_head\"",
		"\"get_tail\"",
		"\"is_empty\"",
		"\"get_element\"",
		"\"get_size\"",
		"\"is_fsym\"",
		"\"check_stamp\"",
		"\"set_stamp\"",
		"\"get_implementation\"",
		"\"get_slot\"",
		"\"make\"",
		"\"make_empty\"",
		"\"make_insert\"",
		"\"make_append\"",
		"\"stamp\"",
		"DOULEARROW",
		"DOUBLE_QUOTE",
		"WS",
		"SLCOMMENT",
		"ML_COMMENT",
		"ESC",
		"HEX_DIGIT",
		"LETTER",
		"DIGIT",
		"ID",
		"ID_MINUS",
		"MINUS",
		"PLUS",
		"QUOTE",
		"EXPONENT",
		"DOT",
		"FLOAT_SUFFIX"
	};
	
	private static final long[] mk_tokenSet_0() {
		long[] data = { 169785460720L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_0 = new BitSet(mk_tokenSet_0());
	private static final long[] mk_tokenSet_1() {
		long[] data = { 15166603264L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_1 = new BitSet(mk_tokenSet_1());
	private static final long[] mk_tokenSet_2() {
		long[] data = { 170859202544L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_2 = new BitSet(mk_tokenSet_2());
	
	}
