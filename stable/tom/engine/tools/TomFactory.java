/*  Generated by TOM: Do not edit this file */  /*
  
    TOM - To One Matching Compiler

    Copyright (C) 2000-2003  LORIA (CNRS, INPL, INRIA, UHP, U-Nancy 2)
			     Nancy, France.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    Pierre-Etienne Moreau	e-mail: Pierre-Etienne.Moreau@loria.fr

*/

package jtom.tools;

import jtom.*;
import java.util.*;
import jtom.adt.*;
import jtom.xml.*;
import aterm.*;

public class TomFactory extends TomBase {

// ------------------------------------------------------------
  /*  Generated by TOM: Do not edit this file */    
// ------------------------------------------------------------

  public TomFactory(jtom.TomEnvironment environment) {
    super(environment);
  }
  
  public String encodeXMLString(SymbolTable symbolTable, String name) {
    name = "\"" + name + "\"";
    ast().makeStringSymbol(symbolTable,name, new LinkedList());
    return name;
  }

  public TomList metaEncodeTermList(SymbolTable symbolTable,TomList list) {
     {  TomList tom_match1_1 = null; tom_match1_1 = ( TomList) list;_match1_pattern1: { if(tom_is_fun_sym_emptyTomList(tom_match1_1)) {
  return tom_make_emptyTomList() ; }}_match1_pattern2: {  TomTerm head = null;  TomList tail = null; if(tom_is_fun_sym_manyTomList(tom_match1_1)) {  TomTerm tom_match1_1_1 = null;  TomList tom_match1_1_2 = null; tom_match1_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match1_1); tom_match1_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match1_1); head = ( TomTerm) tom_match1_1_1; tail = ( TomList) tom_match1_1_2;
 
        return tom_make_manyTomList(metaEncodeXMLAppl(symbolTable, head),metaEncodeTermList(symbolTable, tail))
 ;
       }} }
 
    return list;
  }

  public TomTerm encodeXMLAppl(SymbolTable symbolTable, TomTerm term) {
      /*
       * encode a String into a quoted-string
       * Appl(...,Name("string"),...) becomes
       * Appl(...,Name("\"string\""),...)
       */
     {  TomTerm tom_match2_1 = null; tom_match2_1 = ( TomTerm) term;_match2_pattern1: {  String name = null; if(tom_is_fun_sym_Appl(tom_match2_1)) {  TomName tom_match2_1_2 = null; tom_match2_1_2 = ( TomName) tom_get_slot_Appl_astName(tom_match2_1); if(tom_is_fun_sym_Name(tom_match2_1_2)) {  String tom_match2_1_2_1 = null; tom_match2_1_2_1 = ( String) tom_get_slot_Name_string(tom_match2_1_2); name = ( String) tom_match2_1_2_1;
 
        String tomName = encodeXMLString(symbolTable,name);
        term = term.setAstName(tom_make_Name(tomName) );
          //System.out.println("encodeXMLAppl = " + term);
       } }} }
 
    return term;
  }

  public TomTerm metaEncodeXMLAppl(SymbolTable symbolTable, TomTerm term) {
      /*
       * meta-encode a String into a TextNode
       * Appl(...,Name("\"string\""),...) becomes
       * Appl(...,Name("TextNode"),[Appl(...,Name("\"string\""),...)],...)
       */
    System.out.println("metaEncode: " + term);
     {  TomTerm tom_match3_1 = null; tom_match3_1 = ( TomTerm) term;_match3_pattern1: {  String tomName = null; if(tom_is_fun_sym_Appl(tom_match3_1)) {  TomName tom_match3_1_2 = null; tom_match3_1_2 = ( TomName) tom_get_slot_Appl_astName(tom_match3_1); if(tom_is_fun_sym_Name(tom_match3_1_2)) {  String tom_match3_1_2_1 = null; tom_match3_1_2_1 = ( String) tom_get_slot_Name_string(tom_match3_1_2); tomName = ( String) tom_match3_1_2_1;
 
        System.out.println("tomName = " + tomName);
        TomSymbol tomSymbol = symbolTable.getSymbol(tomName);
        if(tomSymbol != null) {
          if(isStringOperator(tomSymbol)) {
            Option info = ast().makeOriginTracking(Constants.TEXT_NODE,"-1","??");
            term = tom_make_Appl(ast() .makeOption(info),tom_make_Name(Constants .TEXT_NODE),tom_make_insert_concTomTerm(term,( TomList) tom_make_empty_concTomTerm()))
 ;
            System.out.println("metaEncodeXmlAppl = " + term);
          }
        }
       } }} }
 
    return term;
  }

  public boolean isExplicitTermList(LinkedList childs) {
    if(childs.size() == 1) {
      TomTerm term = (TomTerm) childs.getFirst();
       {  TomTerm tom_match4_1 = null; tom_match4_1 = ( TomTerm) term;_match4_pattern1: {  TomList args = null; if(tom_is_fun_sym_Appl(tom_match4_1)) {  TomName tom_match4_1_2 = null;  TomList tom_match4_1_3 = null; tom_match4_1_2 = ( TomName) tom_get_slot_Appl_astName(tom_match4_1); tom_match4_1_3 = ( TomList) tom_get_slot_Appl_args(tom_match4_1); if(tom_is_fun_sym_Name(tom_match4_1_2)) {  String tom_match4_1_2_1 = null; tom_match4_1_2_1 = ( String) tom_get_slot_Name_string(tom_match4_1_2); if(tom_cmp_fun_sym_String(tom_get_fun_sym_String(tom_match4_1_2_1) , "")) { args = ( TomList) tom_match4_1_3;
 
          return true;
         } } }} }
 
    }
    return false;
  }
  
  public LinkedList metaEncodeExplicitTermList(SymbolTable symbolTable, TomTerm term) {
    LinkedList list = new LinkedList();
     {  TomTerm tom_match5_1 = null; tom_match5_1 = ( TomTerm) term;_match5_pattern1: {  TomList args = null; if(tom_is_fun_sym_Appl(tom_match5_1)) {  TomName tom_match5_1_2 = null;  TomList tom_match5_1_3 = null; tom_match5_1_2 = ( TomName) tom_get_slot_Appl_astName(tom_match5_1); tom_match5_1_3 = ( TomList) tom_get_slot_Appl_args(tom_match5_1); if(tom_is_fun_sym_Name(tom_match5_1_2)) {  String tom_match5_1_2_1 = null; tom_match5_1_2_1 = ( String) tom_get_slot_Name_string(tom_match5_1_2); if(tom_cmp_fun_sym_String(tom_get_fun_sym_String(tom_match5_1_2_1) , "")) { args = ( TomList) tom_match5_1_3;
 
        while(!args.isEmpty()) {
          list.add(metaEncodeXMLAppl(symbolTable,args.getHead()));
          args = args.getTail();
        }
        return list;
       } } }}_match5_pattern2: {

 
          //System.out.println("metaEncodeExplicitTermList: strange case: " + term);
        list.add(term);
        return list;
      } }
 
  }
  
}
