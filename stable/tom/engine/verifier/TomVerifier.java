/* Generated by TOM (version 2.1alpha): Do not edit this file *//**
 *
 * The TomVerifier plugin.
 *
 */

package jtom.verifier;

import jtom.*;

import aterm.*;
import java.util.*;
import jtom.tools.*;
import jtom.runtime.*;
import jtom.adt.tomsignature.types.*;
import jtom.adt.options.types.*;
import jtom.TomMessage;

public class TomVerifier extends TomBase implements TomPlugin
{
    /* Generated by TOM (version 2.1alpha): Do not edit this file *//* Generated by TOM (version 2.1alpha): Do not edit this file *//*   *   * Copyright (c) 2004, Pierre-Etienne Moreau   * All rights reserved.   *    * Redistribution and use in source and binary forms, with or without   * modification, are permitted provided that the following conditions are   * met:    *  - Redistributions of source code must retain the above copyright   *  notice, this list of conditions and the following disclaimer.     *  - Redistributions in binary form must reproduce the above copyright   *  notice, this list of conditions and the following disclaimer in the   *  documentation and/or other materials provided with the distribution.   *  - Neither the name of the INRIA nor the names of its   *  contributors may be used to endorse or promote products derived from   *  this software without specific prior written permission.   *    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   *    **/    /* Generated by TOM (version 2.1alpha): Do not edit this file *//*   *   * Copyright (c) 2004, Pierre-Etienne Moreau   * All rights reserved.   *    * Redistribution and use in source and binary forms, with or without   * modification, are permitted provided that the following conditions are   * met:    *  - Redistributions of source code must retain the above copyright   *  notice, this list of conditions and the following disclaimer.     *  - Redistributions in binary form must reproduce the above copyright   *  notice, this list of conditions and the following disclaimer in the   *  documentation and/or other materials provided with the distribution.   *  - Neither the name of the INRIA nor the names of its   *  contributors may be used to endorse or promote products derived from   *  this software without specific prior written permission.   *    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   *    **/          /*   * old definition of String  %typeterm String {    implement           { String }    get_fun_sym(t)      { t }    cmp_fun_sym(s1,s2)  { s1.equals(s2) }    get_subterm(t, n)   { null }    equals(t1,t2)       { t1.equals(t2) }  }  */  /* Generated by TOM (version 2.1alpha): Do not edit this file *//*  * Copyright (c) 2004, Pierre-Etienne Moreau  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:   *  - Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.    *  - Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in the  *  documentation and/or other materials provided with the distribution.  *  - Neither the name of the INRIA nor the names of its  *  contributors may be used to endorse or promote products derived from  *  this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */   /* Generated by TOM (version 2.1alpha): Do not edit this file *//*   *   * Copyright (c) 2004, Pierre-Etienne Moreau   * All rights reserved.   *    * Redistribution and use in source and binary forms, with or without   * modification, are permitted provided that the following conditions are   * met:    *  - Redistributions of source code must retain the above copyright   *  notice, this list of conditions and the following disclaimer.     *  - Redistributions in binary form must reproduce the above copyright   *  notice, this list of conditions and the following disclaimer in the   *  documentation and/or other materials provided with the distribution.   *  - Neither the name of the INRIA nor the names of its   *  contributors may be used to endorse or promote products derived from   *  this software without specific prior written permission.   *    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   *    **/      /* Generated by TOM (version 2.1alpha): Do not edit this file *//*   *   * Copyright (c) 2004, Pierre-Etienne Moreau   * All rights reserved.   *    * Redistribution and use in source and binary forms, with or without   * modification, are permitted provided that the following conditions are   * met:    *  - Redistributions of source code must retain the above copyright   *  notice, this list of conditions and the following disclaimer.     *  - Redistributions in binary form must reproduce the above copyright   *  notice, this list of conditions and the following disclaimer in the   *  documentation and/or other materials provided with the distribution.   *  - Neither the name of the INRIA nor the names of its   *  contributors may be used to endorse or promote products derived from   *  this software without specific prior written permission.   *    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   *    **/      /* Generated by TOM (version 2.1alpha): Do not edit this file *//*  *  * Copyright (c) 2004, Pierre-Etienne Moreau  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:   *  - Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.    *  - Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in the  *  documentation and/or other materials provided with the distribution.  *  - Neither the name of the INRIA nor the names of its  *  contributors may be used to endorse or promote products derived from  *  this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *   **/     /* Generated by TOM (version 2.1alpha): Do not edit this file */  


    private TomTerm term;
    private TomOptionList myOptions;

    protected Verifier verif;

    public TomVerifier()
    {
	myOptions = tom_cons_list_concTomOption(tom_make_OptionBoolean("verify", "", "Verify correctness of match compilation", tom_make_False()) // activation flag
				,tom_empty_list_concTomOption())
;
	verif = new Verifier();
    }

    public void setInput(ATerm term)
    {
	if (term instanceof TomTerm)
	    this.term = (TomTerm)term;
	else
	    environment().messageError(TomMessage.getString("TomTermExpected"),
				       "TomParserPlugin", TomMessage.DEFAULT_ERROR_LINE_NUMBER);
    }

    public ATerm getOutput()
    {
	return term;
    }

    public void run()
    {
	try{
	    long startChrono = System.currentTimeMillis();
	    TomOptionList list = tom_append_list_concTomOption(myOptions,tom_empty_list_concTomOption());
	    boolean willRun = true;
	
	    boolean verbose = ((Boolean)getServer().getOptionValue("verbose")).booleanValue();

	    while(!(list.isEmpty()))
		{
		    TomOption h = list.getHead();
		     { jtom.adt.options.types.TomOption tom_match1_1=(( jtom.adt.options.types.TomOption)h);{ if(tom_is_fun_sym_OptionBoolean(tom_match1_1) ||  false ) { { String  tom_match1_1_1=tom_get_slot_OptionBoolean_name(tom_match1_1); { jtom.adt.options.types.TomBoolean tom_match1_1_4=tom_get_slot_OptionBoolean_valueB(tom_match1_1); if(tom_cmp_fun_sym_String(tom_get_fun_sym_String(tom_match1_1_1) , "verify") ||  false ) { { jtom.adt.options.types.TomBoolean val=tom_match1_1_4; { jtom.adt.options.types.TomBoolean tom_match2_1=(( jtom.adt.options.types.TomBoolean)val);{ if(tom_is_fun_sym_True(tom_match2_1) ||  false ) {





 willRun = true;  } if(tom_is_fun_sym_False(tom_match2_1) ||  false ) {
 willRun = false;  }}}

				} }}} }}}


		    list = list.getTail();
		}
	    if(willRun)
		{
		    TomTerm extractTerm = tom_make_emptyTerm();
		    // here the extraction stuff
		
		    Collection matchSet = collectMatch(term);
		    // System.out.println("Extracted : " + matchSet);
		
		    Collection purified = purify(matchSet);
		    // System.out.println("Purified : " + purified);
		
		    Collection derivations = getDerivations(purified);

		    if(verbose)
			System.out.println("TOM verification phase (" +(System.currentTimeMillis()-startChrono)+ " ms)");
		}
	    else
		{
		    if(verbose)
			System.out.println("The verifier is not activated and thus WILL NOT RUN.");
		}
	    
	    environment().printAlertMessage("TomVerifier");
		if(!environment().isEclipseMode()) {
		    // remove all warning (in command line only)
		    environment().clearWarnings();
		}
	}catch (Exception e) {
	    environment().messageError("Exception occured in TomVerifierExtract: " + e.getMessage(),
				       environment().getInputFile().getName(), 
				       TomMessage.DEFAULT_ERROR_LINE_NUMBER);
	    e.printStackTrace();
	}
    }

    public TomOptionList declareOptions()
    {
// 	int i = 0;
// 	OptionList list = `concOption(myOptions*);
// 	while(!(list.isEmpty()))
// 	    {
// 		i++;
// 		list = list.getTail();
// 	    }

	//System.out.println("1.8. The verifier declares " +i+ " options.");
	return myOptions;
    }

    public TomOptionList requiredOptions()
    {
	return tom_make_emptyTomOptionList();
    }

    public void setOption(String optionName, String optionValue)
    {
 	 { jtom.adt.options.types.TomOptionList tom_match3_1=(( jtom.adt.options.types.TomOptionList)myOptions);{ if(tom_is_fun_sym_concTomOption(tom_match3_1) ||  false ) { { jtom.adt.options.types.TomOptionList tom_match3_1_list1=tom_match3_1; { jtom.adt.options.types.TomOptionList tom_match3_1_begin1=tom_match3_1_list1; { jtom.adt.options.types.TomOptionList tom_match3_1_end1=tom_match3_1_list1; while (!(tom_is_empty_TomOptionList(tom_match3_1_end1))) {tom_match3_1_list1=tom_match3_1_end1;{ { jtom.adt.options.types.TomOptionList av=tom_get_slice_concTomOption(tom_match3_1_begin1,tom_match3_1_end1); { jtom.adt.options.types.TomOption tom_match3_1_2=tom_get_head_TomOptionList(tom_match3_1_list1);tom_match3_1_list1=tom_get_tail_TomOptionList(tom_match3_1_list1); if(tom_is_fun_sym_OptionBoolean(tom_match3_1_2) ||  false ) { { String  tom_match3_1_2_1=tom_get_slot_OptionBoolean_name(tom_match3_1_2); { String  tom_match3_1_2_2=tom_get_slot_OptionBoolean_altName(tom_match3_1_2); { String  tom_match3_1_2_3=tom_get_slot_OptionBoolean_description(tom_match3_1_2); { jtom.adt.options.types.TomBoolean tom_match3_1_2_4=tom_get_slot_OptionBoolean_valueB(tom_match3_1_2); { String  n=tom_match3_1_2_1; { String  alt=tom_match3_1_2_2; { String  desc=tom_match3_1_2_3; { jtom.adt.options.types.TomBoolean val=tom_match3_1_2_4; { jtom.adt.options.types.TomOptionList ap=tom_match3_1_list1;


 if(n.equals(optionName)||alt.equals(optionName))
			{
			     { String  tom_match4_1=(( String )optionValue);{ if(tom_is_fun_sym_concString(tom_match4_1) ||  false ) { { String  tom_match4_1_list1=tom_match4_1; if(!(tom_is_empty_String(tom_match4_1_list1))) { { char  tom_match4_1_1=tom_get_head_String(tom_match4_1_list1);tom_match4_1_list1=tom_get_tail_String(tom_match4_1_list1); if(tom_cmp_fun_sym_char(tom_get_fun_sym_char(tom_match4_1_1) , 't') ||  false ) { if(!(tom_is_empty_String(tom_match4_1_list1))) { { char  tom_match4_1_2=tom_get_head_String(tom_match4_1_list1);tom_match4_1_list1=tom_get_tail_String(tom_match4_1_list1); if(tom_cmp_fun_sym_char(tom_get_fun_sym_char(tom_match4_1_2) , 'r') ||  false ) { if(!(tom_is_empty_String(tom_match4_1_list1))) { { char  tom_match4_1_3=tom_get_head_String(tom_match4_1_list1);tom_match4_1_list1=tom_get_tail_String(tom_match4_1_list1); if(tom_cmp_fun_sym_char(tom_get_fun_sym_char(tom_match4_1_3) , 'u') ||  false ) { if(!(tom_is_empty_String(tom_match4_1_list1))) { { char  tom_match4_1_4=tom_get_head_String(tom_match4_1_list1);tom_match4_1_list1=tom_get_tail_String(tom_match4_1_list1); if(tom_cmp_fun_sym_char(tom_get_fun_sym_char(tom_match4_1_4) , 'e') ||  false ) { if(tom_is_empty_String(tom_match4_1_list1)) {


 myOptions = tom_append_list_concTomOption(av,tom_append_list_concTomOption(ap,tom_cons_list_concTomOption( tom_make_OptionBoolean(n, alt, desc, tom_make_True()),tom_empty_list_concTomOption())));  } }} } }} } }} } }} }} } if(tom_is_fun_sym_concString(tom_match4_1) ||  false ) { { String  tom_match4_1_list1=tom_match4_1; if(!(tom_is_empty_String(tom_match4_1_list1))) { { char  tom_match4_1_1=tom_get_head_String(tom_match4_1_list1);tom_match4_1_list1=tom_get_tail_String(tom_match4_1_list1); if(tom_cmp_fun_sym_char(tom_get_fun_sym_char(tom_match4_1_1) , 'f') ||  false ) { if(!(tom_is_empty_String(tom_match4_1_list1))) { { char  tom_match4_1_2=tom_get_head_String(tom_match4_1_list1);tom_match4_1_list1=tom_get_tail_String(tom_match4_1_list1); if(tom_cmp_fun_sym_char(tom_get_fun_sym_char(tom_match4_1_2) , 'a') ||  false ) { if(!(tom_is_empty_String(tom_match4_1_list1))) { { char  tom_match4_1_3=tom_get_head_String(tom_match4_1_list1);tom_match4_1_list1=tom_get_tail_String(tom_match4_1_list1); if(tom_cmp_fun_sym_char(tom_get_fun_sym_char(tom_match4_1_3) , 'l') ||  false ) { if(!(tom_is_empty_String(tom_match4_1_list1))) { { char  tom_match4_1_4=tom_get_head_String(tom_match4_1_list1);tom_match4_1_list1=tom_get_tail_String(tom_match4_1_list1); if(tom_cmp_fun_sym_char(tom_get_fun_sym_char(tom_match4_1_4) , 's') ||  false ) { if(!(tom_is_empty_String(tom_match4_1_list1))) { { char  tom_match4_1_5=tom_get_head_String(tom_match4_1_list1);tom_match4_1_list1=tom_get_tail_String(tom_match4_1_list1); if(tom_cmp_fun_sym_char(tom_get_fun_sym_char(tom_match4_1_5) , 'e') ||  false ) { if(tom_is_empty_String(tom_match4_1_list1)) {

 myOptions = tom_append_list_concTomOption(av,tom_append_list_concTomOption(ap,tom_cons_list_concTomOption( tom_make_OptionBoolean(n, alt, desc, tom_make_False()),tom_empty_list_concTomOption())));  } }} } }} } }} } }} } }} }} }}}

			}
		}}}}}}}}} }}}tom_match3_1_end1=tom_get_tail_TomOptionList(tom_match3_1_end1);} }}}} } if(tom_is_fun_sym_concTomOption(tom_match3_1) ||  false ) { { jtom.adt.options.types.TomOptionList tom_match3_1_list1=tom_match3_1; { jtom.adt.options.types.TomOptionList tom_match3_1_begin1=tom_match3_1_list1; { jtom.adt.options.types.TomOptionList tom_match3_1_end1=tom_match3_1_list1; while (!(tom_is_empty_TomOptionList(tom_match3_1_end1))) {tom_match3_1_list1=tom_match3_1_end1;{ { jtom.adt.options.types.TomOptionList av=tom_get_slice_concTomOption(tom_match3_1_begin1,tom_match3_1_end1); { jtom.adt.options.types.TomOption tom_match3_1_2=tom_get_head_TomOptionList(tom_match3_1_list1);tom_match3_1_list1=tom_get_tail_TomOptionList(tom_match3_1_list1); if(tom_is_fun_sym_OptionInteger(tom_match3_1_2) ||  false ) { { String  tom_match3_1_2_1=tom_get_slot_OptionInteger_name(tom_match3_1_2); { String  tom_match3_1_2_2=tom_get_slot_OptionInteger_altName(tom_match3_1_2); { String  tom_match3_1_2_3=tom_get_slot_OptionInteger_description(tom_match3_1_2); { int  tom_match3_1_2_4=tom_get_slot_OptionInteger_valueI(tom_match3_1_2); { String  tom_match3_1_2_5=tom_get_slot_OptionInteger_attrName(tom_match3_1_2); { String  n=tom_match3_1_2_1; { String  alt=tom_match3_1_2_2; { String  desc=tom_match3_1_2_3; { int  val=tom_match3_1_2_4; { String  attr=tom_match3_1_2_5; { jtom.adt.options.types.TomOptionList ap=tom_match3_1_list1;

 if(n.equals(optionName)||alt.equals(optionName))
			myOptions = tom_append_list_concTomOption(av,tom_append_list_concTomOption(ap,tom_cons_list_concTomOption( tom_make_OptionInteger(n, alt, desc, Integer.parseInt(optionValue), attr),tom_empty_list_concTomOption())));
		}}}}}}}}}}} }}}tom_match3_1_end1=tom_get_tail_TomOptionList(tom_match3_1_end1);} }}}} } if(tom_is_fun_sym_concTomOption(tom_match3_1) ||  false ) { { jtom.adt.options.types.TomOptionList tom_match3_1_list1=tom_match3_1; { jtom.adt.options.types.TomOptionList tom_match3_1_begin1=tom_match3_1_list1; { jtom.adt.options.types.TomOptionList tom_match3_1_end1=tom_match3_1_list1; while (!(tom_is_empty_TomOptionList(tom_match3_1_end1))) {tom_match3_1_list1=tom_match3_1_end1;{ { jtom.adt.options.types.TomOptionList av=tom_get_slice_concTomOption(tom_match3_1_begin1,tom_match3_1_end1); { jtom.adt.options.types.TomOption tom_match3_1_2=tom_get_head_TomOptionList(tom_match3_1_list1);tom_match3_1_list1=tom_get_tail_TomOptionList(tom_match3_1_list1); if(tom_is_fun_sym_OptionString(tom_match3_1_2) ||  false ) { { String  tom_match3_1_2_1=tom_get_slot_OptionString_name(tom_match3_1_2); { String  tom_match3_1_2_2=tom_get_slot_OptionString_altName(tom_match3_1_2); { String  tom_match3_1_2_3=tom_get_slot_OptionString_description(tom_match3_1_2); { String  tom_match3_1_2_4=tom_get_slot_OptionString_valueS(tom_match3_1_2); { String  tom_match3_1_2_5=tom_get_slot_OptionString_attrName(tom_match3_1_2); { String  n=tom_match3_1_2_1; { String  alt=tom_match3_1_2_2; { String  desc=tom_match3_1_2_3; { String  val=tom_match3_1_2_4; { String  attr=tom_match3_1_2_5; { jtom.adt.options.types.TomOptionList ap=tom_match3_1_list1;

 if(n.equals(optionName)||alt.equals(optionName))
			myOptions = tom_append_list_concTomOption(av,tom_append_list_concTomOption(ap,tom_cons_list_concTomOption( tom_make_OptionString(n, alt, desc, optionValue, attr),tom_empty_list_concTomOption())));
		}}}}}}}}}}} }}}tom_match3_1_end1=tom_get_tail_TomOptionList(tom_match3_1_end1);} }}}} }}}

    }

    private Collect2 collect_match = new Collect2() {
	    public boolean apply(ATerm subject, Object astore) {
		Collection store = (Collection)astore;
		if (subject instanceof Instruction) {
		     { jtom.adt.tomsignature.types.Instruction tom_match5_1=(( jtom.adt.tomsignature.types.Instruction)subject);{ if(tom_is_fun_sym_CompiledMatch(tom_match5_1) ||  false ) { { jtom.adt.tomsignature.types.Instruction tom_match5_1_1=tom_get_slot_CompiledMatch_automataInst(tom_match5_1); { jtom.adt.tomsignature.types.OptionList tom_match5_1_2=tom_get_slot_CompiledMatch_option(tom_match5_1); { jtom.adt.tomsignature.types.Instruction automata=tom_match5_1_1; if(tom_is_fun_sym_concOption(tom_match5_1_2) ||  false ) { { jtom.adt.tomsignature.types.OptionList tom_match5_1_2_list1=tom_match5_1_2; { jtom.adt.tomsignature.types.OptionList tom_match5_1_2_begin1=tom_match5_1_2_list1; { jtom.adt.tomsignature.types.OptionList tom_match5_1_2_end1=tom_match5_1_2_list1; while (!(tom_is_empty_OptionList(tom_match5_1_2_end1))) {tom_match5_1_2_list1=tom_match5_1_2_end1;{ { jtom.adt.tomsignature.types.Option tom_match5_1_2_2=tom_get_head_OptionList(tom_match5_1_2_list1);tom_match5_1_2_list1=tom_get_tail_OptionList(tom_match5_1_2_list1); if(tom_is_fun_sym_TomTermToOption(tom_match5_1_2_2) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match5_1_2_2_1=tom_get_slot_TomTermToOption_astTerm(tom_match5_1_2_2); if(tom_is_fun_sym_PatternList(tom_match5_1_2_2_1) ||  false ) {

			    store.add(subject);
			 }} }}tom_match5_1_2_end1=tom_get_tail_OptionList(tom_match5_1_2_end1);} }}}} }}}} }



			    return true;
			}}
//end match
		} else { 
		    return true;
		}
	    }//end apply
	}; //end new

    public Collection collectMatch(TomTerm subject) {
	Collection result = new HashSet();
	traversal().genericCollect(subject,collect_match,result);
	//collect_matching.apply(subject, result);
	return result;
    }

    public Collection purify(Collection subject) {
	Collection purified = new HashSet();
	Iterator it = subject.iterator();
	while (it.hasNext()) {
	    Instruction cm = (Instruction)it.next();
	     { jtom.adt.tomsignature.types.Instruction tom_match6_1=(( jtom.adt.tomsignature.types.Instruction)cm);{ if(tom_is_fun_sym_CompiledMatch(tom_match6_1) ||  false ) { { jtom.adt.tomsignature.types.Instruction tom_match6_1_1=tom_get_slot_CompiledMatch_automataInst(tom_match6_1); { jtom.adt.tomsignature.types.OptionList tom_match6_1_2=tom_get_slot_CompiledMatch_option(tom_match6_1); { jtom.adt.tomsignature.types.Instruction automata=tom_match6_1_1; { jtom.adt.tomsignature.types.OptionList options=tom_match6_1_2;

		    // simplify the IL automata
		    purified.add(tom_make_CompiledMatch(simplify_il(automata),options));
		}}}} }}}

	}
	return purified;
    }

    Replace1 replace_simplify_il = new Replace1() {
	    public ATerm apply(ATerm subject) {
		if (subject instanceof Expression) {
		     { jtom.adt.tomsignature.types.Expression tom_match7_1=(( jtom.adt.tomsignature.types.Expression)subject);{ if(tom_is_fun_sym_Or(tom_match7_1) ||  false ) { { jtom.adt.tomsignature.types.Expression tom_match7_1_1=tom_get_slot_Or_arg1(tom_match7_1); { jtom.adt.tomsignature.types.Expression tom_match7_1_2=tom_get_slot_Or_arg2(tom_match7_1); { jtom.adt.tomsignature.types.Expression cond=tom_match7_1_1; if(tom_is_fun_sym_FalseTL(tom_match7_1_2) ||  false ) {

			    return traversal().genericTraversal(cond,this);
			 }}}} }}}

		} // end instanceof Expression
		else if (subject instanceof Instruction) {
		     { jtom.adt.tomsignature.types.Instruction tom_match8_1=(( jtom.adt.tomsignature.types.Instruction)subject);{ if(tom_is_fun_sym_IfThenElse(tom_match8_1) ||  false ) { { jtom.adt.tomsignature.types.Expression tom_match8_1_1=tom_get_slot_IfThenElse_condition(tom_match8_1); { jtom.adt.tomsignature.types.Instruction tom_match8_1_2=tom_get_slot_IfThenElse_succesInst(tom_match8_1); { jtom.adt.tomsignature.types.Instruction tom_match8_1_3=tom_get_slot_IfThenElse_failureInst(tom_match8_1); if(tom_is_fun_sym_TrueTL(tom_match8_1_1) ||  false ) { { jtom.adt.tomsignature.types.Instruction success=tom_match8_1_2; if(tom_is_fun_sym_Nop(tom_match8_1_3) ||  false ) {

			    return traversal().genericTraversal(success,this);
			 }} }}}} }}}

		} // end instanceof Instruction
		/*
		 * Default case : Traversal
		 */
		return traversal().genericTraversal(subject,this);
	    }//end apply
	};//end new Replace1 simplify_il
	
    private Instruction simplify_il(Instruction subject) {
	return (Instruction) replace_simplify_il.apply(subject);
    }

    public Collection getDerivations(Collection subject) {
	Collection derivations = new HashSet();
	Iterator it = subject.iterator();
	while (it.hasNext()) {
	    Instruction cm = (Instruction)it.next();
	     { jtom.adt.tomsignature.types.Instruction tom_match9_1=(( jtom.adt.tomsignature.types.Instruction)cm);{ if(tom_is_fun_sym_CompiledMatch(tom_match9_1) ||  false ) { { jtom.adt.tomsignature.types.Instruction tom_match9_1_1=tom_get_slot_CompiledMatch_automataInst(tom_match9_1); { jtom.adt.tomsignature.types.OptionList tom_match9_1_2=tom_get_slot_CompiledMatch_option(tom_match9_1); { jtom.adt.tomsignature.types.Instruction automata=tom_match9_1_1; { jtom.adt.tomsignature.types.OptionList options=tom_match9_1_2;

		    derivations.add(tom_make_CompiledMatch(apply_replace_getDerivations(automata),options));
		}}}} }}}

	}
	return derivations;
    }

    private Instruction apply_replace_getDerivations(Instruction subject) {
	return (Instruction) replace_getDerivations.apply(subject);
    }

    Replace1 replace_getDerivations = new Replace1() {
	    public ATerm apply(ATerm subject) {
		if (subject instanceof Instruction) {
		     { jtom.adt.tomsignature.types.Instruction tom_match10_1=(( jtom.adt.tomsignature.types.Instruction)subject);{ if(tom_is_fun_sym_CompiledPattern(tom_match10_1) ||  false ) { { jtom.adt.tomsignature.types.TomList tom_match10_1_1=tom_get_slot_CompiledPattern_patternList(tom_match10_1); { jtom.adt.tomsignature.types.Instruction tom_match10_1_2=tom_get_slot_CompiledPattern_automataInst(tom_match10_1); { jtom.adt.tomsignature.types.TomList patterns=tom_match10_1_1; { jtom.adt.tomsignature.types.Instruction automata=tom_match10_1_2;

			    verif.build_tree(automata);
			    // do not modify the term (for now at least)
			    return traversal().genericTraversal(subject,this);
			}}}} }}}

		}// end instanceof Instruction
		/*
		 * Default case : Traversal
		 */
		return traversal().genericTraversal(subject,this);
	    }//end apply
	};//end new Replace1 

}
