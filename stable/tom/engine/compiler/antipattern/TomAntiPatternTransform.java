/* Generated by TOM (version 2.4alpha): Do not edit this file *//*
 * Copyright (c) 2005-2006, INRIA
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: 
 *  - Redistributions of source code must retain the above copyright
 *  notice, this list of conditions and the following disclaimer.  
 *  - Redistributions in binary form must reproduce the above copyright
 *  notice, this list of conditions and the following disclaimer in the
 *  documentation and/or other materials provided with the distribution.
 *  - Neither the name of the INRIA nor the names of its
 *  contributors may be used to endorse or promote products derived from
 *  this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package tom.engine.compiler.antipattern;

import java.io.*;
import java.util.*;

import tom.engine.adt.tomsignature.*;
import tom.engine.adt.tomconstraint.types.*;
import tom.engine.adt.tomdeclaration.types.*;
import tom.engine.adt.tomexpression.types.*;
import tom.engine.adt.tominstruction.types.*;
import tom.engine.adt.tomname.types.*;
import tom.engine.adt.tomoption.types.*;
import tom.engine.adt.tomsignature.types.*;
import tom.engine.adt.tomterm.types.*;
import tom.engine.adt.tomslot.types.*;
import tom.engine.adt.tomtype.types.*;

import tom.engine.exception.*;

import tom.library.strategy.mutraveler.MuTraveler;

import jjtraveler.reflective.VisitableVisitor;
import tom.library.strategy.mutraveler.MuStrategy;
import jjtraveler.VisitFailure;

/**
 * Contains methods for transforming an anti-pattern problem into a disunification one
 */
public class TomAntiPatternTransform {	

//	------------------------------------------------------------
	/* Generated by TOM (version 2.4alpha): Do not edit this file *//* Generated by TOM (version 2.4alpha): Do not edit this file *//* Generated by TOM (version 2.4alpha): Do not edit this file */ private static boolean tom_terms_equal_String( String  t1,  String  t2) {  return  (t1.equals(t2))  ;}  /* Generated by TOM (version 2.4alpha): Do not edit this file */ /* Generated by TOM (version 2.4alpha): Do not edit this file */ /* Generated by TOM (version 2.4alpha): Do not edit this file */ /* Generated by TOM (version 2.4alpha): Do not edit this file */ private static boolean tom_terms_equal_TomType(Object t1, Object t2) {  return  t1.equals(t2)  ;}private static boolean tom_terms_equal_TomName(Object t1, Object t2) {  return  t1.equals(t2)  ;}private static boolean tom_terms_equal_OptionList(Object t1, Object t2) {  return  t1.equals(t2)  ;}private static boolean tom_terms_equal_TomTerm(Object t1, Object t2) {  return  t1.equals(t2)  ;}private static boolean tom_terms_equal_OConstraintList(Object t1, Object t2) {  return  t1.equals(t2)  ;}private static boolean tom_terms_equal_AConstraintList(Object t1, Object t2) {  return  t1.equals(t2)  ;}private static boolean tom_terms_equal_Constraint(Object t1, Object t2) {  return  t1.equals(t2)  ;}private static boolean tom_terms_equal_ConstraintList(Object t1, Object t2) {  return  t1.equals(t2)  ;}private static  tom.engine.adt.tomname.types.TomName  tom_make_Name( String  t0) { return  tom.engine.adt.tomname.types.tomname.Name.make(t0); }private static boolean tom_is_fun_sym_AntiTerm( tom.engine.adt.tomterm.types.TomTerm  t) {  return  (t!=null) && t.isAntiTerm()  ;}private static  tom.engine.adt.tomterm.types.TomTerm  tom_get_slot_AntiTerm_TomTerm( tom.engine.adt.tomterm.types.TomTerm  t) {  return  t.getTomTerm()  ;}private static boolean tom_is_fun_sym_Variable( tom.engine.adt.tomterm.types.TomTerm  t) {  return  (t!=null) && t.isVariable()  ;}private static  tom.engine.adt.tomterm.types.TomTerm  tom_make_Variable( tom.engine.adt.tomoption.types.OptionList  t0,  tom.engine.adt.tomname.types.TomName  t1,  tom.engine.adt.tomtype.types.TomType  t2,  tom.engine.adt.tomconstraint.types.ConstraintList  t3) { return  tom.engine.adt.tomterm.types.tomterm.Variable.make(t0, t1, t2, t3); }private static  tom.engine.adt.tomoption.types.OptionList  tom_get_slot_Variable_Option( tom.engine.adt.tomterm.types.TomTerm  t) {  return  t.getOption()  ;}private static  tom.engine.adt.tomname.types.TomName  tom_get_slot_Variable_AstName( tom.engine.adt.tomterm.types.TomTerm  t) {  return  t.getAstName()  ;}private static  tom.engine.adt.tomtype.types.TomType  tom_get_slot_Variable_AstType( tom.engine.adt.tomterm.types.TomTerm  t) {  return  t.getAstType()  ;}private static  tom.engine.adt.tomconstraint.types.ConstraintList  tom_get_slot_Variable_Constraints( tom.engine.adt.tomterm.types.TomTerm  t) {  return  t.getConstraints()  ;}private static boolean tom_is_fun_sym_ForAll( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  (t!=null) && t.isForAll()  ;}private static  tom.engine.adt.tomconstraint.types.Constraint  tom_make_ForAll( tom.engine.adt.tomterm.types.TomTerm  t0,  tom.engine.adt.tomconstraint.types.Constraint  t1) { return  tom.engine.adt.tomconstraint.types.constraint.ForAll.make(t0, t1); }private static  tom.engine.adt.tomterm.types.TomTerm  tom_get_slot_ForAll_var( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  t.getvar()  ;}private static  tom.engine.adt.tomconstraint.types.Constraint  tom_get_slot_ForAll_cons( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  t.getcons()  ;}private static boolean tom_is_fun_sym_Exists( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  (t!=null) && t.isExists()  ;}private static  tom.engine.adt.tomconstraint.types.Constraint  tom_make_Exists( tom.engine.adt.tomterm.types.TomTerm  t0,  tom.engine.adt.tomconstraint.types.Constraint  t1) { return  tom.engine.adt.tomconstraint.types.constraint.Exists.make(t0, t1); }private static  tom.engine.adt.tomterm.types.TomTerm  tom_get_slot_Exists_var( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  t.getvar()  ;}private static  tom.engine.adt.tomconstraint.types.Constraint  tom_get_slot_Exists_cons( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  t.getcons()  ;}private static boolean tom_is_fun_sym_NEqualConstraint( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  (t!=null) && t.isNEqualConstraint()  ;}private static  tom.engine.adt.tomconstraint.types.Constraint  tom_make_NEqualConstraint( tom.engine.adt.tomterm.types.TomTerm  t0,  tom.engine.adt.tomterm.types.TomTerm  t1) { return  tom.engine.adt.tomconstraint.types.constraint.NEqualConstraint.make(t0, t1); }private static  tom.engine.adt.tomterm.types.TomTerm  tom_get_slot_NEqualConstraint_pattern( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  t.getpattern()  ;}private static  tom.engine.adt.tomterm.types.TomTerm  tom_get_slot_NEqualConstraint_genTerm( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  t.getgenTerm()  ;}private static boolean tom_is_fun_sym_EqualConstraint( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  (t!=null) && t.isEqualConstraint()  ;}private static  tom.engine.adt.tomconstraint.types.Constraint  tom_make_EqualConstraint( tom.engine.adt.tomterm.types.TomTerm  t0,  tom.engine.adt.tomterm.types.TomTerm  t1) { return  tom.engine.adt.tomconstraint.types.constraint.EqualConstraint.make(t0, t1); }private static  tom.engine.adt.tomterm.types.TomTerm  tom_get_slot_EqualConstraint_pattern( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  t.getpattern()  ;}private static  tom.engine.adt.tomterm.types.TomTerm  tom_get_slot_EqualConstraint_genTerm( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  t.getgenTerm()  ;}private static boolean tom_is_fun_sym_OrConstraint( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  (t!=null) && t.isOrConstraint()  ;}private static  tom.engine.adt.tomconstraint.types.Constraint  tom_make_OrConstraint( tom.engine.adt.tomconstraint.types.OConstraintList  t0) { return  tom.engine.adt.tomconstraint.types.constraint.OrConstraint.make(t0); }private static  tom.engine.adt.tomconstraint.types.OConstraintList  tom_get_slot_OrConstraint_clo( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  t.getclo()  ;}private static boolean tom_is_fun_sym_AndConstraint( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  (t!=null) && t.isAndConstraint()  ;}private static  tom.engine.adt.tomconstraint.types.Constraint  tom_make_AndConstraint( tom.engine.adt.tomconstraint.types.AConstraintList  t0) { return  tom.engine.adt.tomconstraint.types.constraint.AndConstraint.make(t0); }private static  tom.engine.adt.tomconstraint.types.AConstraintList  tom_get_slot_AndConstraint_cla( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  t.getcla()  ;}private static boolean tom_is_fun_sym_Neg( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  (t!=null) && t.isNeg()  ;}private static  tom.engine.adt.tomconstraint.types.Constraint  tom_make_Neg( tom.engine.adt.tomconstraint.types.Constraint  t0) { return  tom.engine.adt.tomconstraint.types.constraint.Neg.make(t0); }private static  tom.engine.adt.tomconstraint.types.Constraint  tom_get_slot_Neg_c( tom.engine.adt.tomconstraint.types.Constraint  t) {  return  t.getc()  ;}private static boolean tom_is_fun_sym_concOr( tom.engine.adt.tomconstraint.types.OConstraintList  t) {  return  t instanceof tom.engine.adt.tomconstraint.types.oconstraintlist.ConsconcOr || t instanceof tom.engine.adt.tomconstraint.types.oconstraintlist.EmptyconcOr  ;}private static  tom.engine.adt.tomconstraint.types.OConstraintList  tom_empty_list_concOr() { return  tom.engine.adt.tomconstraint.types.oconstraintlist.EmptyconcOr.make() ; }private static  tom.engine.adt.tomconstraint.types.OConstraintList  tom_cons_list_concOr( tom.engine.adt.tomconstraint.types.Constraint  e,  tom.engine.adt.tomconstraint.types.OConstraintList  l) { return  tom.engine.adt.tomconstraint.types.oconstraintlist.ConsconcOr.make(e,l) ; }private static  tom.engine.adt.tomconstraint.types.Constraint  tom_get_head_concOr_OConstraintList( tom.engine.adt.tomconstraint.types.OConstraintList  l) {  return  l.getHeadconcOr()  ;}private static  tom.engine.adt.tomconstraint.types.OConstraintList  tom_get_tail_concOr_OConstraintList( tom.engine.adt.tomconstraint.types.OConstraintList  l) {  return  l.getTailconcOr()  ;}private static boolean tom_is_empty_concOr_OConstraintList( tom.engine.adt.tomconstraint.types.OConstraintList  l) {  return  l.isEmptyconcOr()  ;}private static  tom.engine.adt.tomconstraint.types.OConstraintList  tom_append_list_concOr( tom.engine.adt.tomconstraint.types.OConstraintList  l1,  tom.engine.adt.tomconstraint.types.OConstraintList  l2) {    if(tom_is_empty_concOr_OConstraintList(l1)) {     return l2;    } else if(tom_is_empty_concOr_OConstraintList(l2)) {     return l1;    } else if(tom_is_empty_concOr_OConstraintList(( tom.engine.adt.tomconstraint.types.OConstraintList )tom_get_tail_concOr_OConstraintList(l1))) {     return ( tom.engine.adt.tomconstraint.types.OConstraintList )tom_cons_list_concOr(( tom.engine.adt.tomconstraint.types.Constraint )tom_get_head_concOr_OConstraintList(l1),l2);    } else {      return ( tom.engine.adt.tomconstraint.types.OConstraintList )tom_cons_list_concOr(( tom.engine.adt.tomconstraint.types.Constraint )tom_get_head_concOr_OConstraintList(l1),tom_append_list_concOr(( tom.engine.adt.tomconstraint.types.OConstraintList )tom_get_tail_concOr_OConstraintList(l1),l2));    }   }  private static  tom.engine.adt.tomconstraint.types.OConstraintList  tom_get_slice_concOr( tom.engine.adt.tomconstraint.types.OConstraintList  begin,  tom.engine.adt.tomconstraint.types.OConstraintList  end) {    if(tom_terms_equal_OConstraintList(begin,end)) {      return ( tom.engine.adt.tomconstraint.types.OConstraintList )tom_empty_list_concOr();    } else {      return ( tom.engine.adt.tomconstraint.types.OConstraintList )tom_cons_list_concOr(( tom.engine.adt.tomconstraint.types.Constraint )tom_get_head_concOr_OConstraintList(begin),( tom.engine.adt.tomconstraint.types.OConstraintList )tom_get_slice_concOr(( tom.engine.adt.tomconstraint.types.OConstraintList )tom_get_tail_concOr_OConstraintList(begin),end));    }   }  private static boolean tom_is_fun_sym_concAnd( tom.engine.adt.tomconstraint.types.AConstraintList  t) {  return  t instanceof tom.engine.adt.tomconstraint.types.aconstraintlist.ConsconcAnd || t instanceof tom.engine.adt.tomconstraint.types.aconstraintlist.EmptyconcAnd  ;}private static  tom.engine.adt.tomconstraint.types.AConstraintList  tom_empty_list_concAnd() { return  tom.engine.adt.tomconstraint.types.aconstraintlist.EmptyconcAnd.make() ; }private static  tom.engine.adt.tomconstraint.types.AConstraintList  tom_cons_list_concAnd( tom.engine.adt.tomconstraint.types.Constraint  e,  tom.engine.adt.tomconstraint.types.AConstraintList  l) { return  tom.engine.adt.tomconstraint.types.aconstraintlist.ConsconcAnd.make(e,l) ; }private static  tom.engine.adt.tomconstraint.types.Constraint  tom_get_head_concAnd_AConstraintList( tom.engine.adt.tomconstraint.types.AConstraintList  l) {  return  l.getHeadconcAnd()  ;}private static  tom.engine.adt.tomconstraint.types.AConstraintList  tom_get_tail_concAnd_AConstraintList( tom.engine.adt.tomconstraint.types.AConstraintList  l) {  return  l.getTailconcAnd()  ;}private static boolean tom_is_empty_concAnd_AConstraintList( tom.engine.adt.tomconstraint.types.AConstraintList  l) {  return  l.isEmptyconcAnd()  ;}private static  tom.engine.adt.tomconstraint.types.AConstraintList  tom_append_list_concAnd( tom.engine.adt.tomconstraint.types.AConstraintList  l1,  tom.engine.adt.tomconstraint.types.AConstraintList  l2) {    if(tom_is_empty_concAnd_AConstraintList(l1)) {     return l2;    } else if(tom_is_empty_concAnd_AConstraintList(l2)) {     return l1;    } else if(tom_is_empty_concAnd_AConstraintList(( tom.engine.adt.tomconstraint.types.AConstraintList )tom_get_tail_concAnd_AConstraintList(l1))) {     return ( tom.engine.adt.tomconstraint.types.AConstraintList )tom_cons_list_concAnd(( tom.engine.adt.tomconstraint.types.Constraint )tom_get_head_concAnd_AConstraintList(l1),l2);    } else {      return ( tom.engine.adt.tomconstraint.types.AConstraintList )tom_cons_list_concAnd(( tom.engine.adt.tomconstraint.types.Constraint )tom_get_head_concAnd_AConstraintList(l1),tom_append_list_concAnd(( tom.engine.adt.tomconstraint.types.AConstraintList )tom_get_tail_concAnd_AConstraintList(l1),l2));    }   }  private static  tom.engine.adt.tomconstraint.types.AConstraintList  tom_get_slice_concAnd( tom.engine.adt.tomconstraint.types.AConstraintList  begin,  tom.engine.adt.tomconstraint.types.AConstraintList  end) {    if(tom_terms_equal_AConstraintList(begin,end)) {      return ( tom.engine.adt.tomconstraint.types.AConstraintList )tom_empty_list_concAnd();    } else {      return ( tom.engine.adt.tomconstraint.types.AConstraintList )tom_cons_list_concAnd(( tom.engine.adt.tomconstraint.types.Constraint )tom_get_head_concAnd_AConstraintList(begin),( tom.engine.adt.tomconstraint.types.AConstraintList )tom_get_slice_concAnd(( tom.engine.adt.tomconstraint.types.AConstraintList )tom_get_tail_concAnd_AConstraintList(begin),end));    }   }   
//	%include { adt/tomterm/tomterm.tom }
	/* Generated by TOM (version 2.4alpha): Do not edit this file */private static boolean tom_terms_equal_Strategy(Object t1, Object t2) {  return t1.equals(t2) ;}private static  jjtraveler.reflective.VisitableVisitor  tom_make_mu( jjtraveler.reflective.VisitableVisitor  var,  jjtraveler.reflective.VisitableVisitor  v) { return  tom.library.strategy.mutraveler.MuTraveler.mu(var,v) ; }/* Generated by TOM (version 2.4alpha): Do not edit this file */private static  jjtraveler.reflective.VisitableVisitor  tom_make_Identity() { return  new tom.library.strategy.mutraveler.Identity() ; }private static  jjtraveler.reflective.VisitableVisitor  tom_make_Sequence( jjtraveler.reflective.VisitableVisitor  first,  jjtraveler.reflective.VisitableVisitor  then) { return  new tom.library.strategy.mutraveler.Sequence(first,then) ; }private static  jjtraveler.reflective.VisitableVisitor  tom_make_All( jjtraveler.reflective.VisitableVisitor  v) { return  new tom.library.strategy.mutraveler.All(v) ; }private static  jjtraveler.reflective.VisitableVisitor  tom_make_MuVar( String  name) { return  new tom.library.strategy.mutraveler.MuVar(name) ; }private static  jjtraveler.reflective.VisitableVisitor  tom_make_OneId( jjtraveler.reflective.VisitableVisitor  v) { return  new tom.library.strategy.mutraveler.OneId(v) ; }private static  jjtraveler.reflective.VisitableVisitor  tom_make_SequenceId( jjtraveler.reflective.VisitableVisitor  first,  jjtraveler.reflective.VisitableVisitor  then) { return  new tom.library.strategy.mutraveler.SequenceId(first,then) ; }private static  jjtraveler.reflective.VisitableVisitor  tom_make_ChoiceId( jjtraveler.reflective.VisitableVisitor  first,  jjtraveler.reflective.VisitableVisitor  then) { return  new tom.library.strategy.mutraveler.ChoiceId(first,then) ; }private static  jjtraveler.reflective.VisitableVisitor  tom_make_OnceTopDownId( jjtraveler.reflective.VisitableVisitor  v) { return tom_make_mu(tom_make_MuVar("x"),tom_make_ChoiceId(v,tom_make_OneId(tom_make_MuVar("x")))) ; }private static  jjtraveler.reflective.VisitableVisitor  tom_make_InnermostId( jjtraveler.reflective.VisitableVisitor  v) { return tom_make_mu(tom_make_MuVar("x"),tom_make_Sequence(tom_make_All(tom_make_MuVar("x")),tom_make_SequenceId(v,tom_make_MuVar("x")))) ; }   	
//	------------------------------------------------------------
	
	public static int varCounter = 0;	
	
	private static int antiCounter = 0;
	
	// temporary list that holds variables that need to
	// be quantified 
	private static ArrayList quantifiedVarList = new ArrayList();
	
	/**
	 * transforms the anti-pattern problem received into a disunification one
	 * @param c the anti-pattern problem to transform 
	 * @return corresponding disunification problem 
	 */
	public static Constraint transform(Constraint c) {
		
		Constraint transformedMatch = null;
		varCounter = 0;		
				
		// eliminate anti
		Constraint noAnti = null;;
		try{
			noAnti = applyMainRule(transformedMatch);
		}catch(VisitFailure e){
			throw new TomRuntimeException("Reduction failed on: " + transformedMatch + 
					"\nException:" + e.getMessage());			
		}
		
//		System.out.println("Result after main rule: " + tools.formatConstraint(noAnti));
		
		// transform the problem into a disunification one
		VisitableVisitor transInDisunif = tom_make_TransformIntoDisunification();
		Constraint disunifProblem = null;
		try {		
			disunifProblem = (Constraint) MuTraveler.init(tom_make_InnermostId(transInDisunif)).visit(noAnti);			
		} catch (VisitFailure e) {
			throw new TomRuntimeException("Reduction failed on: " + transformedMatch + 
					"\nException:" + e.getMessage());
		}
		
//		 System.out.println("Disunification problem: " +
//		 formatConstraint(disunifProblem));
		return disunifProblem;
	}	
	
	// applies the main rule that transforms ap problems
	// into dis-unification ones
	private static Constraint applyMainRule(Constraint c) throws VisitFailure{
		
		TomTerm pattern = null;
		TomTerm subject = null;
		
		 if(c instanceof  tom.engine.adt.tomconstraint.types.Constraint ) { { tom.engine.adt.tomconstraint.types.Constraint  tom_match1_1=(( tom.engine.adt.tomconstraint.types.Constraint )c); if (tom_is_fun_sym_EqualConstraint(tom_match1_1) ||  false ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match1_1_pattern=tom_get_slot_EqualConstraint_pattern(tom_match1_1); { tom.engine.adt.tomterm.types.TomTerm  tom_match1_1_genTerm=tom_get_slot_EqualConstraint_genTerm(tom_match1_1); { tom.engine.adt.tomterm.types.TomTerm  tom_p=tom_match1_1_pattern; { tom.engine.adt.tomterm.types.TomTerm  tom_s=tom_match1_1_genTerm; if ( true ) {

				pattern = tom_p;
				subject = tom_s;
			 } } } } } } } }
				
		
		// first get the constraint without the anti
		Constraint cNoAnti =  tom_make_EqualConstraint((TomTerm) MuTraveler.init(tom_make_OnceTopDownId(tom_make_ElimAnti())).visit(pattern),subject);
		// if nothing changed, time to exit
		if (cNoAnti == c){
			return c;
		}
		// get the constraint with a variable instead of anti
		Constraint cAntiReplaced =  tom_make_EqualConstraint((TomTerm) MuTraveler.init(tom_make_OnceTopDownId(tom_make_ReplaceAnti())).visit(pattern),subject);
		
		cAntiReplaced = tom_make_Exists(tom_make_Variable(null,tom_make_Name("v" + varCounter),null,null),applyMainRule(cAntiReplaced))
;
		
		cNoAnti = applyMainRule(cNoAnti);
		
//		System.out.println("Asta e 'c':" + tools.formatConstraint(c));
		
		cNoAnti = tom_make_Neg(cNoAnti);
		
		quantifiedVarList.clear();
		
		MuTraveler.init(tom_make_OnceTopDownId(tom_make_ApplyStrategy())).visit(c);
		
		Iterator it = quantifiedVarList.iterator();
		while(it.hasNext()){
			TomTerm t = (TomTerm)it.next();
			cNoAnti = tom_make_ForAll(t,cNoAnti);
		}
		
	//	System.out.println("antiCounter=" + antiCounter + " cNoAnti=" + tools.formatConstraint(cNoAnti));	

		return tom_make_AndConstraint(tom_cons_list_concAnd(cAntiReplaced,tom_cons_list_concAnd(cNoAnti,tom_empty_list_concAnd())));
	}
	
	
	// quantifies the variables in positive positions
	 private static class AnalyzeTerm  extends  tom.engine.adt.tomconstraint.TomConstraintBasicStrategy   { private  tom.engine.adt.tomterm.types.TomTerm  subject;  public AnalyzeTerm(  tom.engine.adt.tomterm.types.TomTerm  subject ) { super(tom_make_Identity() ); this.subject=subject; } public  tom.engine.adt.tomterm.types.TomTerm  getsubject() { return subject;} public  tom.engine.adt.tomterm.types.TomTerm  visit_TomTerm(  tom.engine.adt.tomterm.types.TomTerm  tom__arg )  throws jjtraveler.VisitFailure { if(tom__arg instanceof  tom.engine.adt.tomterm.types.TomTerm ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match2_1=(( tom.engine.adt.tomterm.types.TomTerm )tom__arg); if (tom_is_fun_sym_Variable(tom_match2_1) ||  false ) { { tom.engine.adt.tomterm.types.TomTerm  tom_v=tom_match2_1; { tom.engine.adt.tomoption.types.OptionList  tom_match2_1_Option=tom_get_slot_Variable_Option(tom_match2_1); { tom.engine.adt.tomname.types.TomName  tom_match2_1_AstName=tom_get_slot_Variable_AstName(tom_match2_1); { tom.engine.adt.tomtype.types.TomType  tom_match2_1_AstType=tom_get_slot_Variable_AstType(tom_match2_1); { tom.engine.adt.tomconstraint.types.ConstraintList  tom_match2_1_Constraints=tom_get_slot_Variable_Constraints(tom_match2_1); if ( true ) {



				
				antiCounter = 0;
				
//				System.out.println("Analyzing " + `v + " position=" + getPosition() );
				
				MuStrategy useOmegaPath = (MuStrategy)getPosition().getOmegaPath(tom_make_CountAnti());				
				
				MuTraveler.init(useOmegaPath).visit(subject);
				
//				System.out.println("After analyzing counter=" + antiCounter);
				// if no anti-symbol found, than the variable can be quantified
				if (antiCounter == 0) {
					quantifiedVarList.add(tom_v);
				}
			 } } } } } } } } } return super.visit_TomTerm(tom__arg) ;  } }private static  jjtraveler.reflective.VisitableVisitor  tom_make_AnalyzeTerm( tom.engine.adt.tomterm.types.TomTerm  t0) { return new AnalyzeTerm(t0); }


	
	// counts the anti symbols 
	 private static class CountAnti  extends  tom.engine.adt.tomconstraint.TomConstraintBasicStrategy   { public CountAnti( ) { super(tom_make_Identity() ); } public  tom.engine.adt.tomterm.types.TomTerm  visit_TomTerm(  tom.engine.adt.tomterm.types.TomTerm  tom__arg )  throws jjtraveler.VisitFailure { if(tom__arg instanceof  tom.engine.adt.tomterm.types.TomTerm ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match3_1=(( tom.engine.adt.tomterm.types.TomTerm )tom__arg); if (tom_is_fun_sym_AntiTerm(tom_match3_1) ||  false ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match3_1_TomTerm=tom_get_slot_AntiTerm_TomTerm(tom_match3_1); if ( true ) {


				antiCounter++;				
			 } } } } } return super.visit_TomTerm(tom__arg) ;  } }private static  jjtraveler.reflective.VisitableVisitor  tom_make_CountAnti() { return new CountAnti(); }


	
	// returns a term without the first negation that it finds
	 private static class ElimAnti  extends  tom.engine.adt.tomconstraint.TomConstraintBasicStrategy   { public ElimAnti( ) { super(tom_make_Identity() ); } public  tom.engine.adt.tomterm.types.TomTerm  visit_TomTerm(  tom.engine.adt.tomterm.types.TomTerm  tom__arg )  throws jjtraveler.VisitFailure { if(tom__arg instanceof  tom.engine.adt.tomterm.types.TomTerm ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match4_1=(( tom.engine.adt.tomterm.types.TomTerm )tom__arg); if (tom_is_fun_sym_AntiTerm(tom_match4_1) ||  false ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match4_1_TomTerm=tom_get_slot_AntiTerm_TomTerm(tom_match4_1); { tom.engine.adt.tomterm.types.TomTerm  tom_p=tom_match4_1_TomTerm; if ( true ) {


				return tom_p;
			 } } } } } } return super.visit_TomTerm(tom__arg) ;  } }private static  jjtraveler.reflective.VisitableVisitor  tom_make_ElimAnti() { return new ElimAnti(); }


	
	// returns a term with the first negation that it finds
	// replaced by a fresh variable
	 private static class ReplaceAnti  extends  tom.engine.adt.tomconstraint.TomConstraintBasicStrategy   { public ReplaceAnti( ) { super(tom_make_Identity() ); } public  tom.engine.adt.tomterm.types.TomTerm  visit_TomTerm(  tom.engine.adt.tomterm.types.TomTerm  tom__arg )  throws jjtraveler.VisitFailure { if(tom__arg instanceof  tom.engine.adt.tomterm.types.TomTerm ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match5_1=(( tom.engine.adt.tomterm.types.TomTerm )tom__arg); if (tom_is_fun_sym_AntiTerm(tom_match5_1) ||  false ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match5_1_TomTerm=tom_get_slot_AntiTerm_TomTerm(tom_match5_1); if ( true ) {




				return tom_make_Variable(null,tom_make_Name("v" + (++varCounter)),null,null);
			 } } } } } return super.visit_TomTerm(tom__arg) ;  } }private static  jjtraveler.reflective.VisitableVisitor  tom_make_ReplaceAnti() { return new ReplaceAnti(); }


	
	// the strategy that handles the variables inside an anti
	// symbol for beeing qunatified 
	 private static class ApplyStrategy  extends  tom.engine.adt.tomconstraint.TomConstraintBasicStrategy   { public ApplyStrategy( ) { super(tom_make_Identity() ); } public  tom.engine.adt.tomterm.types.TomTerm  visit_TomTerm(  tom.engine.adt.tomterm.types.TomTerm  tom__arg )  throws jjtraveler.VisitFailure { if(tom__arg instanceof  tom.engine.adt.tomterm.types.TomTerm ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match6_1=(( tom.engine.adt.tomterm.types.TomTerm )tom__arg); if (tom_is_fun_sym_AntiTerm(tom_match6_1) ||  false ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match6_1_TomTerm=tom_get_slot_AntiTerm_TomTerm(tom_match6_1); { tom.engine.adt.tomterm.types.TomTerm  tom_p=tom_match6_1_TomTerm; if ( true ) {




				TomTerm t = (TomTerm)MuTraveler.init(tom_make_InnermostId(tom_make_AnalyzeTerm(tom_p))).visit(tom_p);				
				// now it has to stop
				return tom_p;
			 } } } } } } return super.visit_TomTerm(tom__arg) ;  } }private static  jjtraveler.reflective.VisitableVisitor  tom_make_ApplyStrategy() { return new ApplyStrategy(); }


	
	// applies symple logic rules for eliminating 
	// the not and thus creating a real disunification problem
	 private static class TransformIntoDisunification  extends  tom.engine.adt.tomconstraint.TomConstraintBasicStrategy   { public TransformIntoDisunification( ) { super(tom_make_Identity() ); } public  tom.engine.adt.tomconstraint.types.Constraint  visit_Constraint(  tom.engine.adt.tomconstraint.types.Constraint  tom__arg )  throws jjtraveler.VisitFailure { if(tom__arg instanceof  tom.engine.adt.tomconstraint.types.Constraint ) { { tom.engine.adt.tomconstraint.types.Constraint  tom_match7_1=(( tom.engine.adt.tomconstraint.types.Constraint )tom__arg); if (tom_is_fun_sym_Exists(tom_match7_1) ||  false ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match7_1_var=tom_get_slot_Exists_var(tom_match7_1); { tom.engine.adt.tomconstraint.types.Constraint  tom_match7_1_cons=tom_get_slot_Exists_cons(tom_match7_1); { tom.engine.adt.tomterm.types.TomTerm  tom_a=tom_match7_1_var; if (tom_is_fun_sym_Exists(tom_match7_1_cons) ||  false ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match7_1_cons_var=tom_get_slot_Exists_var(tom_match7_1_cons); { tom.engine.adt.tomconstraint.types.Constraint  tom_match7_1_cons_cons=tom_get_slot_Exists_cons(tom_match7_1_cons); { tom.engine.adt.tomterm.types.TomTerm  tom_renamedvar_a_1=tom_match7_1_cons_var; if (tom_terms_equal_TomTerm(tom_a, tom_renamedvar_a_1)) { { tom.engine.adt.tomconstraint.types.Constraint  tom_b=tom_match7_1_cons_cons; if ( true ) {





				return tom_make_Exists(tom_a,tom_b);
			 } } } } } } } } } } } if (tom_is_fun_sym_Neg(tom_match7_1) ||  false ) { { tom.engine.adt.tomconstraint.types.Constraint  tom_match7_1_c=tom_get_slot_Neg_c(tom_match7_1); if (tom_is_fun_sym_AndConstraint(tom_match7_1_c) ||  false ) { { tom.engine.adt.tomconstraint.types.AConstraintList  tom_match7_1_c_cla=tom_get_slot_AndConstraint_cla(tom_match7_1_c); { tom.engine.adt.tomconstraint.types.AConstraintList  tom_a=tom_match7_1_c_cla; if ( true ) {



				
				AConstraintList l = tom_a;
				OConstraintList result = tom_empty_list_concOr();			
				
				while(!l.isEmptyconcAnd()){
					result = tom_cons_list_concOr(tom_make_Neg(l.getHeadconcAnd()),tom_append_list_concOr(result,tom_empty_list_concOr()));
					l = l.getTailconcAnd();
				}				
				
				return tom_make_OrConstraint(result);
			 } } } } } } if (tom_is_fun_sym_Neg(tom_match7_1) ||  false ) { { tom.engine.adt.tomconstraint.types.Constraint  tom_match7_1_c=tom_get_slot_Neg_c(tom_match7_1); if (tom_is_fun_sym_OrConstraint(tom_match7_1_c) ||  false ) { { tom.engine.adt.tomconstraint.types.OConstraintList  tom_match7_1_c_clo=tom_get_slot_OrConstraint_clo(tom_match7_1_c); { tom.engine.adt.tomconstraint.types.OConstraintList  tom_a=tom_match7_1_c_clo; if ( true ) {



				
				OConstraintList l = tom_a;
				AConstraintList result = tom_empty_list_concAnd();
				
				while(!l.isEmptyconcOr()){
					result = tom_cons_list_concAnd(tom_make_Neg(l.getHeadconcOr()),tom_append_list_concAnd(result,tom_empty_list_concAnd()));
					l = l.getTailconcOr();
				}
				
				return tom_make_AndConstraint(result);
			 } } } } } } if (tom_is_fun_sym_Neg(tom_match7_1) ||  false ) { { tom.engine.adt.tomconstraint.types.Constraint  tom_match7_1_c=tom_get_slot_Neg_c(tom_match7_1); if (tom_is_fun_sym_Neg(tom_match7_1_c) ||  false ) { { tom.engine.adt.tomconstraint.types.Constraint  tom_match7_1_c_c=tom_get_slot_Neg_c(tom_match7_1_c); { tom.engine.adt.tomconstraint.types.Constraint  tom_x=tom_match7_1_c_c; if ( true ) {


 return tom_x;  } } } } } } if (tom_is_fun_sym_Neg(tom_match7_1) ||  false ) { { tom.engine.adt.tomconstraint.types.Constraint  tom_match7_1_c=tom_get_slot_Neg_c(tom_match7_1); if (tom_is_fun_sym_EqualConstraint(tom_match7_1_c) ||  false ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match7_1_c_pattern=tom_get_slot_EqualConstraint_pattern(tom_match7_1_c); { tom.engine.adt.tomterm.types.TomTerm  tom_match7_1_c_genTerm=tom_get_slot_EqualConstraint_genTerm(tom_match7_1_c); { tom.engine.adt.tomterm.types.TomTerm  tom_a=tom_match7_1_c_pattern; { tom.engine.adt.tomterm.types.TomTerm  tom_b=tom_match7_1_c_genTerm; if ( true ) {


 return tom_make_NEqualConstraint(tom_a,tom_b); } } } } } } } } if (tom_is_fun_sym_Neg(tom_match7_1) ||  false ) { { tom.engine.adt.tomconstraint.types.Constraint  tom_match7_1_c=tom_get_slot_Neg_c(tom_match7_1); if (tom_is_fun_sym_NEqualConstraint(tom_match7_1_c) ||  false ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match7_1_c_pattern=tom_get_slot_NEqualConstraint_pattern(tom_match7_1_c); { tom.engine.adt.tomterm.types.TomTerm  tom_match7_1_c_genTerm=tom_get_slot_NEqualConstraint_genTerm(tom_match7_1_c); { tom.engine.adt.tomterm.types.TomTerm  tom_a=tom_match7_1_c_pattern; { tom.engine.adt.tomterm.types.TomTerm  tom_b=tom_match7_1_c_genTerm; if ( true ) {


 return tom_make_EqualConstraint(tom_a,tom_b); } } } } } } } } if (tom_is_fun_sym_Neg(tom_match7_1) ||  false ) { { tom.engine.adt.tomconstraint.types.Constraint  tom_match7_1_c=tom_get_slot_Neg_c(tom_match7_1); if (tom_is_fun_sym_Exists(tom_match7_1_c) ||  false ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match7_1_c_var=tom_get_slot_Exists_var(tom_match7_1_c); { tom.engine.adt.tomconstraint.types.Constraint  tom_match7_1_c_cons=tom_get_slot_Exists_cons(tom_match7_1_c); { tom.engine.adt.tomterm.types.TomTerm  tom_v=tom_match7_1_c_var; { tom.engine.adt.tomconstraint.types.Constraint  tom_c=tom_match7_1_c_cons; if ( true ) {


			
				return tom_make_ForAll(tom_v,tom_make_Neg(tom_c));			
			 } } } } } } } } if (tom_is_fun_sym_Neg(tom_match7_1) ||  false ) { { tom.engine.adt.tomconstraint.types.Constraint  tom_match7_1_c=tom_get_slot_Neg_c(tom_match7_1); if (tom_is_fun_sym_ForAll(tom_match7_1_c) ||  false ) { { tom.engine.adt.tomterm.types.TomTerm  tom_match7_1_c_var=tom_get_slot_ForAll_var(tom_match7_1_c); { tom.engine.adt.tomconstraint.types.Constraint  tom_match7_1_c_cons=tom_get_slot_ForAll_cons(tom_match7_1_c); { tom.engine.adt.tomterm.types.TomTerm  tom_v=tom_match7_1_c_var; { tom.engine.adt.tomconstraint.types.Constraint  tom_c=tom_match7_1_c_cons; if ( true ) {


			
				return tom_make_Exists(tom_v,tom_make_Neg(tom_c));			
			 } } } } } } } } } } return super.visit_Constraint(tom__arg) ;  } }private static  jjtraveler.reflective.VisitableVisitor  tom_make_TransformIntoDisunification() { return new TransformIntoDisunification(); }

		
} // end class
