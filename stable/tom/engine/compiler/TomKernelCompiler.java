/* Generated by TOM: Do not edit this file *//*
 *   
 * TOM - To One Matching Compiler
 * 
 * Copyright (C) 2000-2004 INRIA
 * Nancy, France.
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 * 
 * Pierre-Etienne Moreau  e-mail: Pierre-Etienne.Moreau@loria.fr
 *
 **/

package jtom.compiler;
  
import jtom.TomBase;
import jtom.adt.tomsignature.types.*;
import jtom.runtime.Replace1;
import aterm.*;
import jtom.exception.TomRuntimeException;

public class TomKernelCompiler extends TomBase {
  public TomKernelCompiler() {
    super();
  }

// ------------------------------------------------------------
  /* Generated by TOM: Do not edit this file *//* Generated by TOM: Do not edit this file *//*  *  * Copyright (c) 2004, Pierre-Etienne Moreau  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:   *  - Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.    *  - Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in the  *  documentation and/or other materials provided with the distribution.  *  - Neither the name of the INRIA nor the names of its  *  contributors may be used to endorse or promote products derived from  *  this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *   **/  /* Generated by TOM: Do not edit this file *//*  *  * Copyright (c) 2004, Pierre-Etienne Moreau  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:   *  - Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.    *  - Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in the  *  documentation and/or other materials provided with the distribution.  *  - Neither the name of the INRIA nor the names of its  *  contributors may be used to endorse or promote products derived from  *  this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *   **/     /*  * old definition of String %typeterm String {   implement           { String }   get_fun_sym(t)      { t }   cmp_fun_sym(s1,s2)  { s1.equals(s2) }   get_subterm(t, n)   { null }   equals(t1,t2)       { t1.equals(t2) } } */ /* Generated by TOM: Do not edit this file *//*  * Copyright (c) 2004, Pierre-Etienne Moreau  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:   *  - Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.    *  - Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in the  *  documentation and/or other materials provided with the distribution.  *  - Neither the name of the INRIA nor the names of its  *  contributors may be used to endorse or promote products derived from  *  this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */   /* Generated by TOM: Do not edit this file *//*  *  * Copyright (c) 2004, Pierre-Etienne Moreau  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:   *  - Redistributions of source code must retain the above copyright  *  notice, this list of conditions and the following disclaimer.    *  - Redistributions in binary form must reproduce the above copyright  *  notice, this list of conditions and the following disclaimer in the  *  documentation and/or other materials provided with the distribution.  *  - Neither the name of the INRIA nor the names of its  *  contributors may be used to endorse or promote products derived from  *  this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *   **/    
// ------------------------------------------------------------
 
  private int matchNumber = 0;

  private OptionList option() {
    return ast().makeOption();
  }

  private TomName getLabel(OptionList list) {
     { jtom.adt.tomsignature.types.OptionList tom_match1_1=(( jtom.adt.tomsignature.types.OptionList)list);{ if(tom_is_fun_sym_concOption(tom_match1_1) ||  false ) { { jtom.adt.tomsignature.types.OptionList tom_match1_1_list1=tom_match1_1; { jtom.adt.tomsignature.types.OptionList tom_match1_1_begin1=tom_match1_1_list1; { jtom.adt.tomsignature.types.OptionList tom_match1_1_end1=tom_match1_1_list1; while (!(tom_is_empty_OptionList(tom_match1_1_end1))) {tom_match1_1_list1=tom_match1_1_end1;{ { jtom.adt.tomsignature.types.Option tom_match1_1_2=tom_get_head_OptionList(tom_match1_1_list1);tom_match1_1_list1=tom_get_tail_OptionList(tom_match1_1_list1); if(tom_is_fun_sym_Label(tom_match1_1_2) ||  false ) { { jtom.adt.tomsignature.types.TomName tom_match1_1_2_1=tom_get_slot_Label_astName(tom_match1_1_2); if(tom_is_fun_sym_Name(tom_match1_1_2_1) ||  false ) { { jtom.adt.tomsignature.types.TomName name=tom_match1_1_2_1;
 return name; } }} }}tom_match1_1_end1=tom_get_tail_OptionList(tom_match1_1_end1);} }}}} }}}

    return null;
  }
  
    /* 
     * compileMatching:
     * compiles the Match construct into a matching automaton: CompiledMatch
     */

  private Replace1 replace_compileMatching = new Replace1() {
      public ATerm apply(ATerm subject) {
        if(subject instanceof Instruction) {
           { jtom.adt.tomsignature.types.Instruction tom_match2_1=(( jtom.adt.tomsignature.types.Instruction)subject);{ if(tom_is_fun_sym_Match(tom_match2_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match2_1_1=tom_get_slot_Match_subjectList(tom_match2_1); { jtom.adt.tomsignature.types.TomTerm tom_match2_1_2=tom_get_slot_Match_astPatternList(tom_match2_1); { jtom.adt.tomsignature.types.OptionList tom_match2_1_3=tom_get_slot_Match_option(tom_match2_1); if(tom_is_fun_sym_SubjectList(tom_match2_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomList tom_match2_1_1_1=tom_get_slot_SubjectList_tomList(tom_match2_1_1); { jtom.adt.tomsignature.types.TomList l1=tom_match2_1_1_1; if(tom_is_fun_sym_PatternList(tom_match2_1_2) ||  false ) { { jtom.adt.tomsignature.types.TomList tom_match2_1_2_1=tom_get_slot_PatternList_tomList(tom_match2_1_2); { jtom.adt.tomsignature.types.TomList l2=tom_match2_1_2_1; { jtom.adt.tomsignature.types.OptionList optionList=tom_match2_1_3;

              boolean generatedMatch = false;
              String currentDebugKey = "noDebug";
              if(getInput().isDebugMode()) {
                generatedMatch = hasGeneratedMatch(optionList);
                Option orgTrack = findOriginTracking(optionList);
                currentDebugKey = orgTrack.getFileName().getString() + orgTrack.getLine();
              }
                
              TomList patternList = null;
              Instruction actionInst = null;
              TomList automataList = empty();
              TomNumberList rootpath = tsf().makeTomNumberList();
              matchNumber++;
              rootpath = (TomNumberList) rootpath.append(tom_make_MatchNumber(makeNumber(matchNumber)));
                
                /*
                 * for each pattern action (<term>,...,<term> -> <action>)
                 * build a matching automata
                 */
              int actionNumber = 0;
              boolean defaultPA =false;
              while(!l2.isEmpty()) {
                actionNumber++;
                TomTerm pa = l2.getHead();
                defaultPA = hasDefaultCase(pa.getOption());
                patternList = pa.getTermList().getTomList();
                if (getInput().isDebugMode() && defaultPA) {
                    // replace success by leaving structure
                  TargetLanguage tl = tsf().makeTargetLanguage_ITL("jtom.debug.TomDebugger.debugger.patternSuccess(\""+currentDebugKey+"\");\njtom.debug.TomDebugger.debugger.leavingStructure(\""+currentDebugKey+"\");\n");
                  actionInst = tom_make_UnamedBlock(tom_cons_list_concInstruction(pa.getAction(),tom_cons_list_concInstruction(tom_make_TargetLanguageToInstruction(tl),tom_empty_list_concInstruction())));
                } else {
                  actionInst = pa.getAction();
                }
                if(patternList==null || actionInst==null) {
                  System.out.println("TomKernelCompiler: null value");
                  throw new TomRuntimeException("TomKernelCompiler: null value");
                }
                  
                  /*
                   * compile nested match constructs
                   * given a list of pattern: we build a matching automaton
                   */
                actionInst = (Instruction) this.apply(actionInst);
                Instruction matchingAutomata = genSyntacticMatchingAutomata(actionInst,
                                                                            patternList,rootpath,1);
                OptionList automataOptionList = tom_cons_list_concOption(tom_make_Debug(tom_make_Name(currentDebugKey)),tom_empty_list_concOption());
                TomName label = getLabel(pa.getOption());
                if(label != null) {
                  automataOptionList = tom_make_manyOptionList(tom_make_Label(label),automataOptionList);
                }
                if(defaultPA) {
                  automataOptionList = tom_make_manyOptionList(tom_make_DefaultCase(),automataOptionList);
                }
                TomNumberList numberList = (TomNumberList) rootpath.append(tom_make_PatternNumber(makeNumber(actionNumber)));
                TomTerm automata = tom_make_Automata(automataOptionList,patternList,numberList,matchingAutomata);
                  //System.out.println("automata = " + automata);
                  
                automataList = append(automata,automataList);
                l2 = l2.getTail();
              }
                
                /*
                 * return the compiled Match construction
                 */
              InstructionList astAutomataList = automataListCompileMatchingList(automataList, generatedMatch);
              Instruction astAutomata = collectVariableFromSubjectList(l1,1,rootpath,tom_make_AbstractBlock(astAutomataList));
              return tom_make_CompiledMatch(astAutomata, optionList);
            }}} }}} }}}} }



              return traversal().genericTraversal(subject,this);
            }}
 // end match
        } else { // not instance of TomTerm
          return traversal().genericTraversal(subject,this);
        }
      } // end apply
    }; // end new

  public TomTerm compileMatching(TomTerm subject) {
    return (TomTerm) replace_compileMatching.apply(subject);
  }

    /*
     * collect match variables (from match(t1,...,tn))
     * create a list of declaration/assignement: v1=t1 ... vn=tn in body
     */
  private Instruction collectVariableFromSubjectList(TomList subjectList, int index, TomNumberList path, Instruction body) {
     { jtom.adt.tomsignature.types.TomList tom_match3_1=(( jtom.adt.tomsignature.types.TomList)subjectList);{ if(tom_is_fun_sym_emptyTomList(tom_match3_1) ||  false ) {
 return body;  } if(tom_is_fun_sym_manyTomList(tom_match3_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match3_1_1=tom_get_slot_manyTomList_head(tom_match3_1); { jtom.adt.tomsignature.types.TomList tom_match3_1_2=tom_get_slot_manyTomList_tail(tom_match3_1); if(tom_is_fun_sym_Variable(tom_match3_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm subjectVar=tom_match3_1_1; { jtom.adt.tomsignature.types.OptionList tom_match3_1_1_1=tom_get_slot_Variable_option(tom_match3_1_1); { jtom.adt.tomsignature.types.TomType tom_match3_1_1_3=tom_get_slot_Variable_astType(tom_match3_1_1); { jtom.adt.tomsignature.types.OptionList option=tom_match3_1_1_1; { jtom.adt.tomsignature.types.TomType variableType=tom_match3_1_1_3; { jtom.adt.tomsignature.types.TomList tail=tom_match3_1_2;

        body = collectVariableFromSubjectList(tail,index+1,path,body);
        TomTerm variable = tom_make_Variable(option,tom_make_PositionName(appendNumber(index,path)),variableType,tom_empty_list_concConstraint());
          // the UnamedBlock encapsulation is needed for Caml
        return tom_make_Let(variable,tom_make_Cast(variableType,tom_make_TomTermToExpression(subjectVar)),tom_make_UnamedBlock(tom_cons_list_concInstruction(body,tom_empty_list_concInstruction())));
      }}}}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match3_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match3_1_1=tom_get_slot_manyTomList_head(tom_match3_1); { jtom.adt.tomsignature.types.TomList tom_match3_1_2=tom_get_slot_manyTomList_tail(tom_match3_1); if(tom_is_fun_sym_FunctionCall(tom_match3_1_1) || tom_is_fun_sym_BuildTerm(tom_match3_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm subjectVar=tom_match3_1_1; { jtom.adt.tomsignature.types.TomName tom_match3_1_1_1=tom_get_slot_BuildTerm_astName(tom_match3_1_1); if(tom_is_fun_sym_Name(tom_match3_1_1_1) ||  false ) { { String  tom_match3_1_1_1_1=tom_get_slot_Name_string(tom_match3_1_1_1); { String  tomName=tom_match3_1_1_1_1; { jtom.adt.tomsignature.types.TomList tail=tom_match3_1_2;


        body = collectVariableFromSubjectList(tail,index+1,path,body);
        TomSymbol tomSymbol = symbolTable().getSymbol(tomName);
        TomType tomType = getSymbolCodomain(tomSymbol);
        TomTerm variable = tom_make_Variable(option(),tom_make_PositionName(appendNumber(index,path)),tomType, tom_empty_list_concConstraint());
        return tom_make_Let(variable,tom_make_TomTermToExpression(subjectVar),body);
      }}} }}} }}} } if(tom_is_fun_sym_manyTomList(tom_match3_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match3_1_1=tom_get_slot_manyTomList_head(tom_match3_1); { jtom.adt.tomsignature.types.TomTerm subjectVar=tom_match3_1_1;


        throw new TomRuntimeException("collectVariableFromSubjectList: strange term: " + subjectVar);
      }} }}}


    return tom_make_Nop();
  }

    /*
     * build a list of instructions from a list of automata
     */
  private InstructionList automataListCompileMatchingList(TomList automataList, boolean generatedMatch) {
     { jtom.adt.tomsignature.types.TomList tom_match4_1=(( jtom.adt.tomsignature.types.TomList)automataList);{ if(tom_is_fun_sym_emptyTomList(tom_match4_1) ||  false ) {
 return tom_make_emptyInstructionList();  } if(tom_is_fun_sym_manyTomList(tom_match4_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match4_1_1=tom_get_slot_manyTomList_head(tom_match4_1); { jtom.adt.tomsignature.types.TomList tom_match4_1_2=tom_get_slot_manyTomList_tail(tom_match4_1); if(tom_is_fun_sym_Automata(tom_match4_1_1) ||  false ) { { jtom.adt.tomsignature.types.OptionList tom_match4_1_1_1=tom_get_slot_Automata_option(tom_match4_1_1); { jtom.adt.tomsignature.types.TomList tom_match4_1_1_2=tom_get_slot_Automata_patternList(tom_match4_1_1); { jtom.adt.tomsignature.types.TomNumberList tom_match4_1_1_3=tom_get_slot_Automata_numberList(tom_match4_1_1); { jtom.adt.tomsignature.types.Instruction tom_match4_1_1_4=tom_get_slot_Automata_inst(tom_match4_1_1); { jtom.adt.tomsignature.types.OptionList optionList=tom_match4_1_1_1; { jtom.adt.tomsignature.types.TomList patternList=tom_match4_1_1_2; { jtom.adt.tomsignature.types.TomNumberList numberList=tom_match4_1_1_3; { jtom.adt.tomsignature.types.Instruction instruction=tom_match4_1_1_4; { jtom.adt.tomsignature.types.TomList l=tom_match4_1_2;

        InstructionList newList = automataListCompileMatchingList(l, generatedMatch);

        if(!generatedMatch && getInput().isDebugMode()) {
          String debugKey = getDebug(optionList);
          Instruction tl1 = tom_make_TargetLanguageToInstruction(tom_make_ITL("jtom.debug.TomDebugger.debugger.enteringPattern(\""+debugKey+"\");\n"));
          Instruction tl2 = tom_make_TargetLanguageToInstruction(tom_make_ITL("jtom.debug.TomDebugger.debugger.leavingPattern(\""+debugKey+"\");\n"));
          if(!hasDefaultCase(optionList)) {
            instruction = tom_make_UnamedBlock(tom_cons_list_concInstruction(tl1,tom_cons_list_concInstruction(instruction,tom_cons_list_concInstruction(tl2,tom_empty_list_concInstruction()))));
          } else {
            instruction = tom_make_UnamedBlock(tom_cons_list_concInstruction(tl1,tom_cons_list_concInstruction(instruction,tom_empty_list_concInstruction())));
          }
        }
         
        if(getLabel(optionList) != null) {
            /*
             * if a label is assigned to a pattern (label:pattern -> action)
             * we generate corresponding labeled-block
             */
          instruction = tom_make_NamedBlock(getLabel(optionList).getString(),
                                    tom_cons_list_concInstruction(instruction,tom_empty_list_concInstruction()))
;
                     
        }
        return tom_cons_list_concInstruction(tom_make_CompiledPattern(patternList,instruction),tom_append_list_concInstruction(newList,tom_empty_list_concInstruction()));
      }}}}}}}}} }}} }}}

    return null;
  }
  
    /*
     * ------------------------------------------------------------
     * Generate a matching automaton
     * ------------------------------------------------------------
     */
  
    /*
     * given a pattern, this function generatesthe discrimitation test on the root symbol
     * and recursively calls the algorithm on subterms
     */
  Instruction genSyntacticMatchingAutomata(Instruction action,
                                           TomList termList,
                                           TomNumberList rootpath,
                                           int indexTerm) {
    TomNumberList path = appendNumber(indexTerm,rootpath);
        
     { jtom.adt.tomsignature.types.TomList tom_match5_1=(( jtom.adt.tomsignature.types.TomList)termList);{ if(tom_is_fun_sym_emptyTomList(tom_match5_1) ||  false ) {
 
        return action;
       } if(tom_is_fun_sym_manyTomList(tom_match5_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match5_1_1=tom_get_slot_manyTomList_head(tom_match5_1); { jtom.adt.tomsignature.types.TomList tom_match5_1_2=tom_get_slot_manyTomList_tail(tom_match5_1); if(tom_is_fun_sym_Variable(tom_match5_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm var=tom_match5_1_1; { jtom.adt.tomsignature.types.OptionList tom_match5_1_1_1=tom_get_slot_Variable_option(tom_match5_1_1); { jtom.adt.tomsignature.types.TomType tom_match5_1_1_3=tom_get_slot_Variable_astType(tom_match5_1_1); { jtom.adt.tomsignature.types.ConstraintList tom_match5_1_1_4=tom_get_slot_Variable_constraints(tom_match5_1_1); { jtom.adt.tomsignature.types.OptionList optionList=tom_match5_1_1_1; { jtom.adt.tomsignature.types.TomType termType=tom_match5_1_1_3; { jtom.adt.tomsignature.types.ConstraintList constraints=tom_match5_1_1_4; { jtom.adt.tomsignature.types.TomList termTail=tom_match5_1_2;



        Instruction subAction = genSyntacticMatchingAutomata(action,termTail,rootpath,indexTerm+1);
        Expression source = tom_make_TomTermToExpression(tom_make_Variable(option(),tom_make_PositionName(path),termType, tom_empty_list_concConstraint()));
        return buildLet(var, source, subAction);
      }}}}}}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match5_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match5_1_1=tom_get_slot_manyTomList_head(tom_match5_1); { jtom.adt.tomsignature.types.TomList tom_match5_1_2=tom_get_slot_manyTomList_tail(tom_match5_1); if(tom_is_fun_sym_UnamedVariable(tom_match5_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm var=tom_match5_1_1; { jtom.adt.tomsignature.types.OptionList tom_match5_1_1_1=tom_get_slot_UnamedVariable_option(tom_match5_1_1); { jtom.adt.tomsignature.types.TomType tom_match5_1_1_2=tom_get_slot_UnamedVariable_astType(tom_match5_1_1); { jtom.adt.tomsignature.types.ConstraintList tom_match5_1_1_3=tom_get_slot_UnamedVariable_constraints(tom_match5_1_1); { jtom.adt.tomsignature.types.OptionList optionList=tom_match5_1_1_1; { jtom.adt.tomsignature.types.TomType termType=tom_match5_1_1_2; { jtom.adt.tomsignature.types.ConstraintList constraints=tom_match5_1_1_3; { jtom.adt.tomsignature.types.TomList termTail=tom_match5_1_2;          Instruction subAction = genSyntacticMatchingAutomata(action,termTail,rootpath,indexTerm+1);          Expression source = tom_make_TomTermToExpression(tom_make_Variable(option(),tom_make_PositionName(path),termType, tom_empty_list_concConstraint()));          return buildLet(var, source, subAction);        }}}}}}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match5_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match5_1_1=tom_get_slot_manyTomList_head(tom_match5_1); { jtom.adt.tomsignature.types.TomList tom_match5_1_2=tom_get_slot_manyTomList_tail(tom_match5_1); if(tom_is_fun_sym_Appl(tom_match5_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm currentTerm=tom_match5_1_1; { jtom.adt.tomsignature.types.OptionList tom_match5_1_1_1=tom_get_slot_Appl_option(tom_match5_1_1); { jtom.adt.tomsignature.types.NameList tom_match5_1_1_2=tom_get_slot_Appl_nameList(tom_match5_1_1); { jtom.adt.tomsignature.types.TomList tom_match5_1_1_3=tom_get_slot_Appl_args(tom_match5_1_1); { jtom.adt.tomsignature.types.ConstraintList tom_match5_1_1_4=tom_get_slot_Appl_constraints(tom_match5_1_1); { jtom.adt.tomsignature.types.OptionList optionList=tom_match5_1_1_1; if(tom_is_fun_sym_concTomName(tom_match5_1_1_2) ||  false ) { { jtom.adt.tomsignature.types.NameList nameList=tom_match5_1_1_2; { jtom.adt.tomsignature.types.NameList tom_match5_1_1_2_list1=tom_match5_1_1_2; if(!(tom_is_empty_NameList(tom_match5_1_1_2_list1))) { { jtom.adt.tomsignature.types.TomName tom_match5_1_1_2_1=tom_get_head_NameList(tom_match5_1_1_2_list1);tom_match5_1_1_2_list1=tom_get_tail_NameList(tom_match5_1_1_2_list1); if(tom_is_fun_sym_Name(tom_match5_1_1_2_1) ||  false ) { { String  tom_match5_1_1_2_1_1=tom_get_slot_Name_string(tom_match5_1_1_2_1); { String  tomName=tom_match5_1_1_2_1_1; { jtom.adt.tomsignature.types.TomList termArgs=tom_match5_1_1_3; { jtom.adt.tomsignature.types.ConstraintList constraints=tom_match5_1_1_4; { jtom.adt.tomsignature.types.TomList termTail=tom_match5_1_2;


        Instruction subAction = genSyntacticMatchingAutomata(action,termTail,rootpath,indexTerm+1);
        TomSymbol tomSymbol = symbolTable().getSymbol(tomName);
        TomTypeList termTypeList = tomSymbol.getTypesToType().getDomain();
        TomType termType = tomSymbol.getTypesToType().getCodomain();
        
          // SUCCES
        TomTerm subjectVariableAST =  tom_make_Variable(option(),tom_make_PositionName(path),termType,tom_empty_list_concConstraint());
        Instruction automataInstruction;
        if(isListOperator(tomSymbol)) {
            /*
             * store the subject into an internal variable
             * call genListMatchingAutomata with the new internal variable
             */
          int indexSubterm = 1;
          TomNumberList newPath = (TomNumberList) path.append(tom_make_ListNumber(makeNumber(indexSubterm)));
          TomTerm newSubjectVariableAST =  tom_make_VariableStar(option(),tom_make_PositionName(newPath),termType,tom_empty_list_concConstraint());
          boolean ensureNotEmptyList = true;
          Instruction automata = genListMatchingAutomata(new MatchingParameter(
                                                           tomSymbol,path,subAction,
                                                           newSubjectVariableAST,
                                                           newSubjectVariableAST),
                                                         termArgs,
                                                         indexSubterm,
                                                         ensureNotEmptyList);
          automataInstruction = tom_make_LetRef(newSubjectVariableAST,
                                        tom_make_TomTermToExpression(subjectVariableAST),
                                        automata)

;
        } else if(isArrayOperator(tomSymbol)) {
          int indexSubterm = 1;
          TomNumberList newPathList = (TomNumberList) path.append(tom_make_ListNumber(makeNumber(indexSubterm)));
          TomNumberList newPathIndex = (TomNumberList) path.append(tom_make_IndexNumber(makeNumber(indexSubterm)));
          TomTerm newVariableListAST = tom_make_VariableStar(option(),tom_make_PositionName(newPathList),termType,tom_empty_list_concConstraint());
          TomTerm newVariableIndexAST = tom_make_Variable(option(),tom_make_PositionName(newPathIndex),symbolTable().getIntType(),tom_empty_list_concConstraint());
          boolean ensureNotEmptyList = true;
          Instruction automata = genArrayMatchingAutomata(new MatchingParameter(
                                                            tomSymbol,path,subAction,
                                                            newVariableListAST, newVariableIndexAST),
                                                          termArgs,
                                                          indexSubterm,
                                                          ensureNotEmptyList);
          Expression glZero = tom_make_TomTermToExpression(tom_make_TargetLanguageToTomTerm(tom_make_ITL("0")));
          automataInstruction = tom_make_Let(newVariableIndexAST,glZero,
                                     tom_make_Let(newVariableListAST,
                                         tom_make_TomTermToExpression(subjectVariableAST),
                                         automata))


;
        } else {
          int indexSubterm = 0;
          Instruction automata = genSyntacticMatchingAutomata(subAction,termArgs,path,indexSubterm+1);
          automataInstruction = collectSubtermFromSubjectList(termArgs,termTypeList,tomSymbol,subjectVariableAST,indexSubterm,path,automata); 
        }
        
          /* TODO:remove old things
             TomTerm annotedVariable = getAnnotedVariable(optionList);
             if(annotedVariable != null) {
             automataInstruction = buildLet(annotedVariable,`TomTermToExpression(subjectVariableAST),automataInstruction);
             }
          */

        automataInstruction = compileConstraint(currentTerm,tom_make_TomTermToExpression(subjectVariableAST),automataInstruction);

        Expression cond = expandDisjunction(tom_make_EqualFunctionSymbol(termType,subjectVariableAST,currentTerm));
        Instruction test = tom_make_IfThenElse(cond,automataInstruction,tom_make_Nop());
        return test;
      }}}}} }} }}} }}}}}}} }}} }


        System.out.println("GenSyntacticMatchingAutomata strange term: " + termList);
        throw new TomRuntimeException("GenSyntacticMatchingAutomata strange term: " + termList);
      }}

  }

    /*
     * function which compiles list-matching
     * 
     * p:         parameters (which are not modified during the matching process)
     * termList:  list of subterms
     * indexTerm: index of the considered subterm (indexTerm=1 for the first call)
     */
  Instruction genListMatchingAutomata(MatchingParameter p,
                                      TomList termList,
                                      int indexTerm,
                                      boolean ensureNotEmptyList) {
     { jtom.adt.tomsignature.types.TomList tom_match6_1=(( jtom.adt.tomsignature.types.TomList)termList);{ if(tom_is_fun_sym_emptyTomList(tom_match6_1) ||  false ) {

          /*
           * nothing to compile
           * just check that the subject is empty
           */
        return genIsEmptyList(p.subjectListName, p.action, tom_make_Nop());
       } if(tom_is_fun_sym_manyTomList(tom_match6_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match6_1_1=tom_get_slot_manyTomList_head(tom_match6_1); { jtom.adt.tomsignature.types.TomList tom_match6_1_2=tom_get_slot_manyTomList_tail(tom_match6_1); if(tom_is_fun_sym_Variable(tom_match6_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm var=tom_match6_1_1; { jtom.adt.tomsignature.types.TomType tom_match6_1_1_3=tom_get_slot_Variable_astType(tom_match6_1_1); { jtom.adt.tomsignature.types.TomType termType=tom_match6_1_1_3; { jtom.adt.tomsignature.types.TomList termTail=tom_match6_1_2;



          /*
           * get an element and store it
           */
        Instruction subAction = genListMatchingAutomata(p,termTail,indexTerm+1,true);
        return genGetElementList(p.subjectListName, var, termType, subAction, ensureNotEmptyList);
      }}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match6_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match6_1_1=tom_get_slot_manyTomList_head(tom_match6_1); { jtom.adt.tomsignature.types.TomList tom_match6_1_2=tom_get_slot_manyTomList_tail(tom_match6_1); if(tom_is_fun_sym_UnamedVariable(tom_match6_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm var=tom_match6_1_1; { jtom.adt.tomsignature.types.TomType tom_match6_1_1_2=tom_get_slot_UnamedVariable_astType(tom_match6_1_1); { jtom.adt.tomsignature.types.TomType termType=tom_match6_1_1_2; { jtom.adt.tomsignature.types.TomList termTail=tom_match6_1_2;            /*             * get an element and store it             */          Instruction subAction = genListMatchingAutomata(p,termTail,indexTerm+1,true);          return genGetElementList(p.subjectListName, var, termType, subAction, ensureNotEmptyList);        }}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match6_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match6_1_1=tom_get_slot_manyTomList_head(tom_match6_1); { jtom.adt.tomsignature.types.TomList tom_match6_1_2=tom_get_slot_manyTomList_tail(tom_match6_1); if(tom_is_fun_sym_Appl(tom_match6_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm term=tom_match6_1_1; { jtom.adt.tomsignature.types.NameList tom_match6_1_1_2=tom_get_slot_Appl_nameList(tom_match6_1_1); if(tom_is_fun_sym_concTomName(tom_match6_1_1_2) ||  false ) { { jtom.adt.tomsignature.types.NameList nameList=tom_match6_1_1_2; { jtom.adt.tomsignature.types.NameList tom_match6_1_1_2_list1=tom_match6_1_1_2; if(!(tom_is_empty_NameList(tom_match6_1_1_2_list1))) { { jtom.adt.tomsignature.types.TomName tom_match6_1_1_2_1=tom_get_head_NameList(tom_match6_1_1_2_list1);tom_match6_1_1_2_list1=tom_get_tail_NameList(tom_match6_1_1_2_list1); if(tom_is_fun_sym_Name(tom_match6_1_1_2_1) ||  false ) { { String  tom_match6_1_1_2_1_1=tom_get_slot_Name_string(tom_match6_1_1_2_1); { String  tomName=tom_match6_1_1_2_1_1; { jtom.adt.tomsignature.types.TomList termTail=tom_match6_1_2;


          /*
           * get an element
           * perform syntactic matching
           */
        Instruction subAction = genListMatchingAutomata(p,termTail,indexTerm+1,true);

        subAction = genSyntacticMatchingAutomata(subAction,tom_cons_list_concTomTerm(term,tom_empty_list_concTomTerm()),p.path,indexTerm);
        TomSymbol tomSymbol = symbolTable().getSymbol(tomName);
        TomType termType = tomSymbol.getTypesToType().getCodomain();
        TomNumberList newPath  = appendNumber(indexTerm,p.path);
        TomTerm var =  tom_make_Variable(option(),tom_make_PositionName(newPath),termType,tom_empty_list_concConstraint());
        return genGetElementList(p.subjectListName, var, termType, subAction, ensureNotEmptyList);
      }}} }} }}} }}} }}} } if(tom_is_fun_sym_manyTomList(tom_match6_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match6_1_1=tom_get_slot_manyTomList_head(tom_match6_1); { jtom.adt.tomsignature.types.TomList tom_match6_1_2=tom_get_slot_manyTomList_tail(tom_match6_1); if(tom_is_fun_sym_VariableStar(tom_match6_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm var=tom_match6_1_1; { jtom.adt.tomsignature.types.TomType tom_match6_1_1_3=tom_get_slot_VariableStar_astType(tom_match6_1_1); { jtom.adt.tomsignature.types.TomType termType=tom_match6_1_1_3; { jtom.adt.tomsignature.types.TomList termTail=tom_match6_1_2;



          /*
           * 3 cases:
           * - tail = emptyList
           * - tail = only VariableStar or UnamedVariableStar
           * - tail = other
           */
        if(termTail.isEmpty()) {
            /*
             * generate:
             * ---------
             * Let E_n = subjectList;
             * ...
             */
          Expression source = tom_make_TomTermToExpression(tom_make_Ref(p.subjectListName));
          return buildLet(var, source, p.action);
        } else {
            /*
             * generate:
             * ---------
             * Let begin_i = subjectList;
             * LetRef end_i   = subjectList;
             * ...
             */
          Instruction subAction = genListMatchingAutomata(p,termTail,indexTerm+1,false);
          TomNumberList pathBegin = (TomNumberList) p.path.append(tom_make_Begin(makeNumber(indexTerm)));
          TomNumberList pathEnd = (TomNumberList) p.path.append(tom_make_End(makeNumber(indexTerm)));
          TomTerm variableBeginAST = tom_make_Variable(option(),tom_make_PositionName(pathBegin),termType,tom_empty_list_concConstraint());
          TomTerm variableEndAST   = tom_make_Variable(option(),tom_make_PositionName(pathEnd),termType,tom_empty_list_concConstraint());

          Expression source = tom_make_GetSliceList(p.symbol.getAstName(),variableBeginAST,tom_make_Ref(variableEndAST));
          Instruction let = buildLet(var, source, subAction);
          Instruction tailExp = tom_make_Assign(variableEndAST,tom_make_GetTail(tom_make_Ref(variableEndAST)));
          Instruction loop;
          if(containOnlyVariableStar(termTail)) {
              /*
               * do {
               *   * SUBSTITUTION: E_i
               *   TomList E_i = GET_SLICE_TomList(begin_i,end_i);
               *   ...
               *   if(!IS_EMPTY_TomList(end_i) )
               *     end_i = (TomList) GET_TAIL_TomList(end_i);
               *   subjectList = end_i;
               * } while( !IS_EMPTY_TomList(end_i) )
               */
            Instruction assign1 = genIsEmptyList(tom_make_Ref(variableEndAST),tom_make_Nop(),tailExp);
            Instruction assign2 = tom_make_Assign(p.subjectListName,tom_make_TomTermToExpression(tom_make_Ref(variableEndAST)));
            loop = tom_make_DoWhile(tom_make_UnamedBlock(tom_cons_list_concInstruction(let,tom_cons_list_concInstruction(assign1,tom_cons_list_concInstruction(assign2,tom_empty_list_concInstruction())))),tom_make_Not(tom_make_IsEmptyList(tom_make_Ref(variableEndAST))));
          } else {
              /*
               * case (X*,y,...)
               * no longer necessary to check if the list is not empty
               * to extract the 'y'
               */
            
              /*
               * while( !IS_EMPTY_TomList(end_i) ) {
               *   subjectList = end_i;
               *   * SUBSTITUTION: E_i
               *   TomList E_i = GET_SLICE_TomList(begin_i,end_i);
               *   ...
               *   end_i = (TomList) GET_TAIL_TomList(end_i);
               * } 
               */

            Instruction assign1 = tailExp;
            Instruction letAssign = tom_make_LetAssign(p.subjectListName,tom_make_TomTermToExpression(tom_make_Ref(variableEndAST)),tom_make_UnamedBlock(tom_cons_list_concInstruction(let,tom_cons_list_concInstruction(assign1,tom_empty_list_concInstruction()))));
            loop = tom_make_WhileDo(tom_make_Not(tom_make_IsEmptyList(tom_make_Ref(variableEndAST))),letAssign);
          }
          Instruction letEnd = tom_make_LetRef(variableEndAST,
                                       tom_make_TomTermToExpression(tom_make_Ref(p.subjectListName)),
                                       loop)

;
          Instruction letBegin = tom_make_Let(variableBeginAST,
                                      tom_make_TomTermToExpression(tom_make_Ref(p.subjectListName)),
                                      letEnd)

;
          return letBegin;
        }
      }}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match6_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match6_1_1=tom_get_slot_manyTomList_head(tom_match6_1); { jtom.adt.tomsignature.types.TomList tom_match6_1_2=tom_get_slot_manyTomList_tail(tom_match6_1); if(tom_is_fun_sym_UnamedVariableStar(tom_match6_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm var=tom_match6_1_1; { jtom.adt.tomsignature.types.TomType tom_match6_1_1_2=tom_get_slot_UnamedVariableStar_astType(tom_match6_1_1); { jtom.adt.tomsignature.types.TomType termType=tom_match6_1_1_2; { jtom.adt.tomsignature.types.TomList termTail=tom_match6_1_2;            /*             * 3 cases:             * - tail = emptyList             * - tail = only VariableStar or UnamedVariableStar             * - tail = other             */          if(termTail.isEmpty()) {              /*               * generate:               * ---------               * Let E_n = subjectList;               * ...               */            Expression source = tom_make_TomTermToExpression(tom_make_Ref(p.subjectListName));            return buildLet(var, source, p.action);          } else {              /*               * generate:               * ---------               * Let begin_i = subjectList;               * LetRef end_i   = subjectList;               * ...               */            Instruction subAction = genListMatchingAutomata(p,termTail,indexTerm+1,false);            TomNumberList pathBegin = (TomNumberList) p.path.append(tom_make_Begin(makeNumber(indexTerm)));            TomNumberList pathEnd = (TomNumberList) p.path.append(tom_make_End(makeNumber(indexTerm)));            TomTerm variableBeginAST = tom_make_Variable(option(),tom_make_PositionName(pathBegin),termType,tom_empty_list_concConstraint());            TomTerm variableEndAST   = tom_make_Variable(option(),tom_make_PositionName(pathEnd),termType,tom_empty_list_concConstraint());              Expression source = tom_make_GetSliceList(p.symbol.getAstName(),variableBeginAST,tom_make_Ref(variableEndAST));            Instruction let = buildLet(var, source, subAction);            Instruction tailExp = tom_make_Assign(variableEndAST,tom_make_GetTail(tom_make_Ref(variableEndAST)));            Instruction loop;            if(containOnlyVariableStar(termTail)) {                /*                 * do {                 *   * SUBSTITUTION: E_i                 *   TomList E_i = GET_SLICE_TomList(begin_i,end_i);                 *   ...                 *   if(!IS_EMPTY_TomList(end_i) )                 *     end_i = (TomList) GET_TAIL_TomList(end_i);                 *   subjectList = end_i;                 * } while( !IS_EMPTY_TomList(end_i) )                 */              Instruction assign1 = genIsEmptyList(tom_make_Ref(variableEndAST),tom_make_Nop(),tailExp);              Instruction assign2 = tom_make_Assign(p.subjectListName,tom_make_TomTermToExpression(tom_make_Ref(variableEndAST)));              loop = tom_make_DoWhile(tom_make_UnamedBlock(tom_cons_list_concInstruction(let,tom_cons_list_concInstruction(assign1,tom_cons_list_concInstruction(assign2,tom_empty_list_concInstruction())))),tom_make_Not(tom_make_IsEmptyList(tom_make_Ref(variableEndAST))));            } else {                /*                 * case (X*,y,...)                 * no longer necessary to check if the list is not empty                 * to extract the 'y'                 */                              /*                 * while( !IS_EMPTY_TomList(end_i) ) {                 *   subjectList = end_i;                 *   * SUBSTITUTION: E_i                 *   TomList E_i = GET_SLICE_TomList(begin_i,end_i);                 *   ...                 *   end_i = (TomList) GET_TAIL_TomList(end_i);                 * }                  */                Instruction assign1 = tailExp;              Instruction letAssign = tom_make_LetAssign(p.subjectListName,tom_make_TomTermToExpression(tom_make_Ref(variableEndAST)),tom_make_UnamedBlock(tom_cons_list_concInstruction(let,tom_cons_list_concInstruction(assign1,tom_empty_list_concInstruction()))));              loop = tom_make_WhileDo(tom_make_Not(tom_make_IsEmptyList(tom_make_Ref(variableEndAST))),letAssign);            }            Instruction letEnd = tom_make_LetRef(variableEndAST,
                                       tom_make_TomTermToExpression(tom_make_Ref(p.subjectListName)),
                                       loop);            Instruction letBegin = tom_make_Let(variableBeginAST,
                                      tom_make_TomTermToExpression(tom_make_Ref(p.subjectListName)),
                                      letEnd);            return letBegin;          }        }}}} }}} }


        System.out.println("GenListMatchingAutomata strange termList: " + termList);
        throw new TomRuntimeException("GenListMatchingAutomata strange termList: " + termList);
      }}

  }

  private boolean containOnlyVariableStar(TomList termList) {
     { jtom.adt.tomsignature.types.TomList tom_match7_1=(( jtom.adt.tomsignature.types.TomList)termList);{ if(tom_is_fun_sym_emptyTomList(tom_match7_1) ||  false ) {

        return true;
       } if(tom_is_fun_sym_manyTomList(tom_match7_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match7_1_1=tom_get_slot_manyTomList_head(tom_match7_1); { jtom.adt.tomsignature.types.TomList tom_match7_1_2=tom_get_slot_manyTomList_tail(tom_match7_1); if(tom_is_fun_sym_VariableStar(tom_match7_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomList termTail=tom_match7_1_2;



        return containOnlyVariableStar(termTail);
      } }}} } if(tom_is_fun_sym_manyTomList(tom_match7_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match7_1_1=tom_get_slot_manyTomList_head(tom_match7_1); { jtom.adt.tomsignature.types.TomList tom_match7_1_2=tom_get_slot_manyTomList_tail(tom_match7_1); if(tom_is_fun_sym_UnamedVariableStar(tom_match7_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomList termTail=tom_match7_1_2;          return containOnlyVariableStar(termTail);        } }}} }}}

    return false;
  }

  
  private Instruction genIsEmptyList(TomTerm subjectListName,
                                     Instruction succes, Instruction failure) {
      /*
       * generate:
       * ---------
       * if(IS_EMPTY_TomList(subjectList)) {
       *   ...
       * }
       */
    return tom_make_IfThenElse(tom_make_IsEmptyList(tom_make_Ref(subjectListName)),succes,failure);
  }


  private Instruction genGetElementList(TomTerm subjectListName, TomTerm var,
                                    TomType termType,
                                    Instruction subAction, boolean notEmptyList) {
      /*
       * generate:
       * ---------
       * if(!IS_EMPTY_TomList(subjectList)) {
       *   Let TomTerm var = (TomTerm) GET_HEAD_TomList(subjectList);
       *   subjectList = (TomList) GET_TAIL_TomList(subjectList);
       *   ...
       * }
       */
    Instruction body = tom_make_LetAssign(subjectListName,tom_make_GetTail(tom_make_Ref(subjectListName)),subAction);
    Expression source = tom_make_GetHead(termType,tom_make_Ref(subjectListName));
    Instruction let = buildLet(var, source, body);
    if(notEmptyList) {
      return genIsEmptyList(subjectListName,tom_make_Nop(),let);
    } else {
      return let;
    }
  }
  
    /*
     * function which compiles array-matching
     * 
     * p:         parameters (which are not modified during the matching process)
     * termList:  list of subterms
     * indexTerm: index of the considered subterm (indexTerm=1 for the first call)
     */
  Instruction genArrayMatchingAutomata(MatchingParameter p,
                                       TomList termList,
                                       int indexTerm,
                                       boolean ensureNotEmptyList) {
     { jtom.adt.tomsignature.types.TomList tom_match8_1=(( jtom.adt.tomsignature.types.TomList)termList);{ if(tom_is_fun_sym_emptyTomList(tom_match8_1) ||  false ) {

          /*
           * nothing to compile
           * just check that the subject is empty
           */
        return genIsEmptyArray(p.subjectListName, p.subjectListIndex, p.action, tom_make_Nop());
       } if(tom_is_fun_sym_manyTomList(tom_match8_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match8_1_1=tom_get_slot_manyTomList_head(tom_match8_1); { jtom.adt.tomsignature.types.TomList tom_match8_1_2=tom_get_slot_manyTomList_tail(tom_match8_1); if(tom_is_fun_sym_Variable(tom_match8_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm var=tom_match8_1_1; { jtom.adt.tomsignature.types.OptionList tom_match8_1_1_1=tom_get_slot_Variable_option(tom_match8_1_1); { jtom.adt.tomsignature.types.TomType tom_match8_1_1_3=tom_get_slot_Variable_astType(tom_match8_1_1); { jtom.adt.tomsignature.types.OptionList optionList=tom_match8_1_1_1; { jtom.adt.tomsignature.types.TomType termType=tom_match8_1_1_3; { jtom.adt.tomsignature.types.TomList termTail=tom_match8_1_2;



          /*
           * get an element and store it
           */
        Instruction subAction = genArrayMatchingAutomata(p,termTail,indexTerm+1,true);
        return genGetElementArray(p.subjectListName, p.subjectListIndex, var, termType, subAction, ensureNotEmptyList);
      }}}}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match8_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match8_1_1=tom_get_slot_manyTomList_head(tom_match8_1); { jtom.adt.tomsignature.types.TomList tom_match8_1_2=tom_get_slot_manyTomList_tail(tom_match8_1); if(tom_is_fun_sym_UnamedVariable(tom_match8_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm var=tom_match8_1_1; { jtom.adt.tomsignature.types.OptionList tom_match8_1_1_1=tom_get_slot_UnamedVariable_option(tom_match8_1_1); { jtom.adt.tomsignature.types.TomType tom_match8_1_1_2=tom_get_slot_UnamedVariable_astType(tom_match8_1_1); { jtom.adt.tomsignature.types.OptionList optionList=tom_match8_1_1_1; { jtom.adt.tomsignature.types.TomType termType=tom_match8_1_1_2; { jtom.adt.tomsignature.types.TomList termTail=tom_match8_1_2;            /*             * get an element and store it             */          Instruction subAction = genArrayMatchingAutomata(p,termTail,indexTerm+1,true);          return genGetElementArray(p.subjectListName, p.subjectListIndex, var, termType, subAction, ensureNotEmptyList);        }}}}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match8_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match8_1_1=tom_get_slot_manyTomList_head(tom_match8_1); { jtom.adt.tomsignature.types.TomList tom_match8_1_2=tom_get_slot_manyTomList_tail(tom_match8_1); if(tom_is_fun_sym_Appl(tom_match8_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm term=tom_match8_1_1; { jtom.adt.tomsignature.types.NameList tom_match8_1_1_2=tom_get_slot_Appl_nameList(tom_match8_1_1); if(tom_is_fun_sym_concTomName(tom_match8_1_1_2) ||  false ) { { jtom.adt.tomsignature.types.NameList nameList=tom_match8_1_1_2; { jtom.adt.tomsignature.types.NameList tom_match8_1_1_2_list1=tom_match8_1_1_2; if(!(tom_is_empty_NameList(tom_match8_1_1_2_list1))) { { jtom.adt.tomsignature.types.TomName tom_match8_1_1_2_1=tom_get_head_NameList(tom_match8_1_1_2_list1);tom_match8_1_1_2_list1=tom_get_tail_NameList(tom_match8_1_1_2_list1); if(tom_is_fun_sym_Name(tom_match8_1_1_2_1) ||  false ) { { String  tom_match8_1_1_2_1_1=tom_get_slot_Name_string(tom_match8_1_1_2_1); { String  tomName=tom_match8_1_1_2_1_1; { jtom.adt.tomsignature.types.TomList termTail=tom_match8_1_2;


          /*
           * get an element
           * perform syntactic matching
           */
        Instruction subAction = genArrayMatchingAutomata(p,termTail,indexTerm+1,true);

        subAction = genSyntacticMatchingAutomata(subAction,tom_cons_list_concTomTerm(term,tom_empty_list_concTomTerm()),p.path,indexTerm);
        TomSymbol tomSymbol = symbolTable().getSymbol(tomName);
        TomType termType = tomSymbol.getTypesToType().getCodomain();
        TomNumberList newPath  = appendNumber(indexTerm,p.path);
        TomTerm var =  tom_make_Variable(option(),tom_make_PositionName(newPath),termType,tom_empty_list_concConstraint());

        return genGetElementArray(p.subjectListName, p.subjectListIndex, var, termType, subAction, ensureNotEmptyList);
      }}} }} }}} }}} }}} } if(tom_is_fun_sym_manyTomList(tom_match8_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match8_1_1=tom_get_slot_manyTomList_head(tom_match8_1); { jtom.adt.tomsignature.types.TomList tom_match8_1_2=tom_get_slot_manyTomList_tail(tom_match8_1); if(tom_is_fun_sym_VariableStar(tom_match8_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm var=tom_match8_1_1; { jtom.adt.tomsignature.types.OptionList tom_match8_1_1_1=tom_get_slot_VariableStar_option(tom_match8_1_1); { jtom.adt.tomsignature.types.TomType tom_match8_1_1_3=tom_get_slot_VariableStar_astType(tom_match8_1_1); { jtom.adt.tomsignature.types.OptionList optionList=tom_match8_1_1_1; { jtom.adt.tomsignature.types.TomType termType=tom_match8_1_1_3; { jtom.adt.tomsignature.types.TomList termTail=tom_match8_1_2;



          /*
           * 3 cases:
           * - tail = emptyList
           * - tail = only VariableStar or UnamedVariableStar
           * - tail = other
           */
        if(termTail.isEmpty()) {
            /*
             * generate:
             * ---------
             * Let E_n = GET_SLICE_L(subjectList,subjectIndex,GET_SIZE_L(subjectList));
             * ...
             */
          Expression source = tom_make_GetSliceArray(p.symbol.getAstName(),
                                             tom_make_Ref(p.subjectListName),
                                             tom_make_Ref(p.subjectListIndex),
                                             tom_make_ExpressionToTomTerm(tom_make_GetSize(p.subjectListName))
                                             )



;
          Instruction let = buildLet(var, source, p.action);
          return let;
        } else {
          /*
           * generate:
           * ---------
           * int begin_i = subjectIndex;
           * int end_i   = subjectIndex;
           * ...
           */
          Instruction subAction = genArrayMatchingAutomata(p,termTail,indexTerm+1,false);
          TomNumberList pathBegin = (TomNumberList) p.path.append(tom_make_Begin(makeNumber(indexTerm)));
          TomNumberList pathEnd = (TomNumberList) p.path.append(tom_make_End(makeNumber(indexTerm)));
          TomTerm variableBeginAST = tom_make_Variable(option(),tom_make_PositionName(pathBegin),symbolTable().getIntType(),tom_empty_list_concConstraint());
          TomTerm variableEndAST   = tom_make_Variable(option(),tom_make_PositionName(pathEnd),symbolTable().getIntType(),tom_empty_list_concConstraint());

          Expression source = tom_make_GetSliceArray(p.symbol.getAstName(),
                                             tom_make_Ref(p.subjectListName),
                                             variableBeginAST,
                                             tom_make_Ref(variableEndAST))


;

          Instruction let = buildLet(var, source, subAction);
          Instruction increment = tom_make_Assign(variableEndAST,tom_make_AddOne(tom_make_Ref(variableEndAST)));
          Instruction loop;
          if(containOnlyVariableStar(termTail)) {
            /*
             * do {
             *   * SUBSTITUTION: E_i
             *   TomList E_i = GET_SLICE_TomList(subjectList,begin_i,end_i);
             *   ...
             *   end_i++;
             *   subjectIndex = end_i;
             * } while( !IS_EMPTY_TomList(subjectList) )
             */
            Instruction assign = tom_make_Assign(p.subjectListIndex,tom_make_TomTermToExpression(tom_make_Ref(variableEndAST)));
            
            loop = tom_make_DoWhile(tom_make_UnamedBlock(tom_cons_list_concInstruction(let,tom_cons_list_concInstruction(increment,tom_cons_list_concInstruction(assign,tom_empty_list_concInstruction())))),
                            tom_make_Not(tom_make_IsEmptyArray(tom_make_Ref(p.subjectListName), tom_make_Ref(p.subjectListIndex))))
;
          } else {
            /*
             * while( !IS_EMPTY_TomList(end_isubjectList) ) {
             *   * SUBSTITUTION: E_i
             *   TomList E_i = GET_SLICE_TomList(subjectList,begin_i,end_i);
             *   ...
             *   end_i++;
             *   subjectIndex = end_i;
             * } 
             */
            Instruction letAssign = tom_make_LetAssign(p.subjectListIndex,tom_make_TomTermToExpression(tom_make_Ref(variableEndAST)),tom_make_UnamedBlock(tom_cons_list_concInstruction(let,tom_cons_list_concInstruction(increment,tom_empty_list_concInstruction()))));
            loop = tom_make_WhileDo(tom_make_Not(tom_make_IsEmptyArray(tom_make_Ref(p.subjectListName), tom_make_Ref(variableEndAST))),
                            letAssign)
;
            
          }
          Instruction letEnd = tom_make_LetRef(variableEndAST,
                                       tom_make_TomTermToExpression(tom_make_Ref(p.subjectListIndex)),
                                       loop)

;
          Instruction letBegin = tom_make_Let(variableBeginAST,
                                      tom_make_TomTermToExpression(tom_make_Ref(p.subjectListIndex)),
                                      letEnd)

;
          return letBegin;
        }
      }}}}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match8_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match8_1_1=tom_get_slot_manyTomList_head(tom_match8_1); { jtom.adt.tomsignature.types.TomList tom_match8_1_2=tom_get_slot_manyTomList_tail(tom_match8_1); if(tom_is_fun_sym_UnamedVariableStar(tom_match8_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm var=tom_match8_1_1; { jtom.adt.tomsignature.types.OptionList tom_match8_1_1_1=tom_get_slot_UnamedVariableStar_option(tom_match8_1_1); { jtom.adt.tomsignature.types.TomType tom_match8_1_1_2=tom_get_slot_UnamedVariableStar_astType(tom_match8_1_1); { jtom.adt.tomsignature.types.OptionList optionList=tom_match8_1_1_1; { jtom.adt.tomsignature.types.TomType termType=tom_match8_1_1_2; { jtom.adt.tomsignature.types.TomList termTail=tom_match8_1_2;            /*             * 3 cases:             * - tail = emptyList             * - tail = only VariableStar or UnamedVariableStar             * - tail = other             */          if(termTail.isEmpty()) {              /*               * generate:               * ---------               * Let E_n = GET_SLICE_L(subjectList,subjectIndex,GET_SIZE_L(subjectList));               * ...               */            Expression source = tom_make_GetSliceArray(p.symbol.getAstName(),
                                             tom_make_Ref(p.subjectListName),
                                             tom_make_Ref(p.subjectListIndex),
                                             tom_make_ExpressionToTomTerm(tom_make_GetSize(p.subjectListName))
                                             );            Instruction let = buildLet(var, source, p.action);            return let;          } else {            /*             * generate:             * ---------             * int begin_i = subjectIndex;             * int end_i   = subjectIndex;             * ...             */            Instruction subAction = genArrayMatchingAutomata(p,termTail,indexTerm+1,false);            TomNumberList pathBegin = (TomNumberList) p.path.append(tom_make_Begin(makeNumber(indexTerm)));            TomNumberList pathEnd = (TomNumberList) p.path.append(tom_make_End(makeNumber(indexTerm)));            TomTerm variableBeginAST = tom_make_Variable(option(),tom_make_PositionName(pathBegin),symbolTable().getIntType(),tom_empty_list_concConstraint());            TomTerm variableEndAST   = tom_make_Variable(option(),tom_make_PositionName(pathEnd),symbolTable().getIntType(),tom_empty_list_concConstraint());              Expression source = tom_make_GetSliceArray(p.symbol.getAstName(),
                                             tom_make_Ref(p.subjectListName),
                                             variableBeginAST,
                                             tom_make_Ref(variableEndAST));              Instruction let = buildLet(var, source, subAction);            Instruction increment = tom_make_Assign(variableEndAST,tom_make_AddOne(tom_make_Ref(variableEndAST)));            Instruction loop;            if(containOnlyVariableStar(termTail)) {              /*               * do {               *   * SUBSTITUTION: E_i               *   TomList E_i = GET_SLICE_TomList(subjectList,begin_i,end_i);               *   ...               *   end_i++;               *   subjectIndex = end_i;               * } while( !IS_EMPTY_TomList(subjectList) )               */              Instruction assign = tom_make_Assign(p.subjectListIndex,tom_make_TomTermToExpression(tom_make_Ref(variableEndAST)));                            loop = tom_make_DoWhile(tom_make_UnamedBlock(tom_cons_list_concInstruction(let,tom_cons_list_concInstruction(increment,tom_cons_list_concInstruction(assign,tom_empty_list_concInstruction())))),
                            tom_make_Not(tom_make_IsEmptyArray(tom_make_Ref(p.subjectListName), tom_make_Ref(p.subjectListIndex))));            } else {              /*               * while( !IS_EMPTY_TomList(end_isubjectList) ) {               *   * SUBSTITUTION: E_i               *   TomList E_i = GET_SLICE_TomList(subjectList,begin_i,end_i);               *   ...               *   end_i++;               *   subjectIndex = end_i;               * }                */              Instruction letAssign = tom_make_LetAssign(p.subjectListIndex,tom_make_TomTermToExpression(tom_make_Ref(variableEndAST)),tom_make_UnamedBlock(tom_cons_list_concInstruction(let,tom_cons_list_concInstruction(increment,tom_empty_list_concInstruction()))));              loop = tom_make_WhileDo(tom_make_Not(tom_make_IsEmptyArray(tom_make_Ref(p.subjectListName), tom_make_Ref(variableEndAST))),
                            letAssign);                          }            Instruction letEnd = tom_make_LetRef(variableEndAST,
                                       tom_make_TomTermToExpression(tom_make_Ref(p.subjectListIndex)),
                                       loop);            Instruction letBegin = tom_make_Let(variableBeginAST,
                                      tom_make_TomTermToExpression(tom_make_Ref(p.subjectListIndex)),
                                      letEnd);            return letBegin;          }        }}}}}} }}} }



        System.out.println("GenArrayMatchingAutomata strange termList: " + termList);
        throw new TomRuntimeException("GenArrayMatchingAutomata strange termList: " + termList);
      }}

  }

  private Instruction genIsEmptyArray(TomTerm subjectListName,
                                      TomTerm subjectListIndex,
                                     Instruction succes, Instruction failure) {
      /*
       * generate:
       * ---------
       * if(IS_EMPTY_TomList(subjectList,subjectIndex)) {
       *   ...
       * }
       */
    return tom_make_IfThenElse(tom_make_IsEmptyArray(tom_make_Ref(subjectListName),tom_make_Ref(subjectListIndex)),succes,failure);
  }


  private Instruction genGetElementArray(TomTerm subjectListName, 
                                         TomTerm subjectListIndex, 
                                         TomTerm var,
                                         TomType termType,
                                         Instruction subAction, 
                                         boolean notEmptyList) {
      /*
       * generate:
       * ---------
       * if(!IS_EMPTY_TomList(subjectList,subjectIndex)) {
       *   Let TomTerm var = (TomTerm) GET_HEAD_TomList(subjectList);
       *   subjectList = (TomList) GET_TAIL_TomList(subjectList);
       *   ...
       * }
       */
    Instruction body = tom_make_LetAssign(subjectListIndex,tom_make_AddOne(tom_make_Ref(subjectListIndex)),subAction);
    Expression source = tom_make_GetElement(termType,subjectListName,subjectListIndex);
    Instruction let = buildLet(var, source, body);
    if(notEmptyList) {
      return genIsEmptyArray(subjectListName,subjectListIndex,tom_make_Nop(),let);
    } else {
      return let;
    }
  }


    /*
     * given a list of subject t1,...,tn
     * declare/assign internal matching variables: match_path_i = ti
     */
  private Instruction collectSubtermFromSubjectList(TomList termArgList, TomTypeList termTypeList,
                                                    TomSymbol tomSymbol,TomTerm subjectVariableAST, 
                                                    int indexSubterm, TomNumberList path, Instruction body) {
    TomName termNameAST = tomSymbol.getAstName();
     { jtom.adt.tomsignature.types.TomList tom_match9_1=(( jtom.adt.tomsignature.types.TomList)termArgList);{ if(tom_is_fun_sym_emptyTomList(tom_match9_1) ||  false ) {
 return body;  } if(tom_is_fun_sym_manyTomList(tom_match9_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match9_1_1=tom_get_slot_manyTomList_head(tom_match9_1); { jtom.adt.tomsignature.types.TomList tom_match9_1_2=tom_get_slot_manyTomList_tail(tom_match9_1); { jtom.adt.tomsignature.types.TomTerm subtermArg=tom_match9_1_1; { jtom.adt.tomsignature.types.TomList tail=tom_match9_1_2;


        body = collectSubtermFromSubjectList(tail,termTypeList.getTail(),
                                             tomSymbol,subjectVariableAST,
                                             indexSubterm+1,path,body);
        if(subtermArg.isUnamedVariable() && !isAnnotedVariable(subtermArg)) {
            // This is an optimisation 
            // Do not assign the subterm: skip the subterm 
          return body;
        } else {
          TomType subtermType = termTypeList.getHead();
          Expression getSubtermAST;
          TomName slotName = getSlotName(tomSymbol, indexSubterm);
          if(slotName == null) {
            getSubtermAST = tom_make_GetSubterm(subtermType,subjectVariableAST,makeNumber(indexSubterm));
          } else {
            getSubtermAST = tom_make_GetSlot(subtermType,termNameAST,slotName.getString(),subjectVariableAST);
          }
          TomNumberList newPath  = appendNumber(indexSubterm+1,path);
          TomTerm newVariableAST = tom_make_Variable(option(),tom_make_PositionName(newPath),subtermType,tom_empty_list_concConstraint());
          return tom_make_Let(newVariableAST,getSubtermAST,body);
        }
      }}}} }}}


    return tom_make_Nop();
  }

  private Expression expandDisjunction(Expression exp) {
    Expression cond = tom_make_FalseTL();
     { jtom.adt.tomsignature.types.Expression tom_match10_1=(( jtom.adt.tomsignature.types.Expression)exp);{ if(tom_is_fun_sym_EqualFunctionSymbol(tom_match10_1) ||  false ) { { jtom.adt.tomsignature.types.TomType tom_match10_1_1=tom_get_slot_EqualFunctionSymbol_astType(tom_match10_1); { jtom.adt.tomsignature.types.TomTerm tom_match10_1_2=tom_get_slot_EqualFunctionSymbol_exp1(tom_match10_1); { jtom.adt.tomsignature.types.TomTerm tom_match10_1_3=tom_get_slot_EqualFunctionSymbol_exp2(tom_match10_1); { jtom.adt.tomsignature.types.TomType termType=tom_match10_1_1; { jtom.adt.tomsignature.types.TomTerm exp1=tom_match10_1_2; if(tom_is_fun_sym_Appl(tom_match10_1_3) ||  false ) { { jtom.adt.tomsignature.types.OptionList tom_match10_1_3_1=tom_get_slot_Appl_option(tom_match10_1_3); { jtom.adt.tomsignature.types.NameList tom_match10_1_3_2=tom_get_slot_Appl_nameList(tom_match10_1_3); { jtom.adt.tomsignature.types.TomList tom_match10_1_3_3=tom_get_slot_Appl_args(tom_match10_1_3); { jtom.adt.tomsignature.types.OptionList option=tom_match10_1_3_1; { jtom.adt.tomsignature.types.NameList nameList=tom_match10_1_3_2; { jtom.adt.tomsignature.types.TomList l=tom_match10_1_3_3;

        while(!nameList.isEmpty()) {
          TomName name = nameList.getHead();
          Expression check = tom_make_EqualFunctionSymbol(termType,exp1,tom_make_Appl(option,tom_cons_list_concTomName(name,tom_empty_list_concTomName()),l,tom_empty_list_concConstraint()));
          cond = tom_make_Or(check,cond);
          nameList = nameList.getTail();
        }
      }}}}}} }}}}}} }}}

    return cond;
  }

  private Instruction buildLet(TomTerm dest,
                               Expression source,
                               Instruction body) {
      // Take care of constraints
    body = compileConstraint(dest,source,body);
    return tom_make_Let(dest,source,body);
  }

  private Instruction compileConstraint(TomTerm subject, Expression source, Instruction body) {
     { jtom.adt.tomsignature.types.TomTerm tom_match11_1=(( jtom.adt.tomsignature.types.TomTerm)subject);{ if(tom_is_fun_sym_VariableStar(tom_match11_1) || tom_is_fun_sym_Variable(tom_match11_1) ||  false ) { { jtom.adt.tomsignature.types.ConstraintList tom_match11_1_4=tom_get_slot_Variable_constraints(tom_match11_1); { jtom.adt.tomsignature.types.ConstraintList constraints=tom_match11_1_4;

        return buildConstraint(constraints,tom_make_TomTermToExpression(subject),body);
      }} } if(tom_is_fun_sym_UnamedVariableStar(tom_match11_1) || tom_is_fun_sym_UnamedVariable(tom_match11_1) ||  false ) { { jtom.adt.tomsignature.types.ConstraintList tom_match11_1_3=tom_get_slot_UnamedVariable_constraints(tom_match11_1); { jtom.adt.tomsignature.types.ConstraintList constraints=tom_match11_1_3;


        return buildConstraint(constraints,source,body);
      }} } if(tom_is_fun_sym_Appl(tom_match11_1) ||  false ) { { jtom.adt.tomsignature.types.ConstraintList tom_match11_1_4=tom_get_slot_Appl_constraints(tom_match11_1); { jtom.adt.tomsignature.types.ConstraintList constraints=tom_match11_1_4;


        return buildConstraint(constraints,source,body);
      }} }


        throw new TomRuntimeException("compileConstraint: strange subject: " + subject);
      }}

  }

  private Instruction buildConstraint(ConstraintList constraints, Expression source, Instruction body) {
     { jtom.adt.tomsignature.types.ConstraintList tom_match12_1=(( jtom.adt.tomsignature.types.ConstraintList)constraints);{ if(tom_is_fun_sym_concConstraint(tom_match12_1) ||  false ) { { jtom.adt.tomsignature.types.ConstraintList tom_match12_1_list1=tom_match12_1; if(tom_is_empty_ConstraintList(tom_match12_1_list1)) {

        return body;
       }} } if(tom_is_fun_sym_concConstraint(tom_match12_1) ||  false ) { { jtom.adt.tomsignature.types.ConstraintList tom_match12_1_list1=tom_match12_1; if(!(tom_is_empty_ConstraintList(tom_match12_1_list1))) { { jtom.adt.tomsignature.types.Constraint tom_match12_1_1=tom_get_head_ConstraintList(tom_match12_1_list1);tom_match12_1_list1=tom_get_tail_ConstraintList(tom_match12_1_list1); if(tom_is_fun_sym_Equal(tom_match12_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match12_1_1_1=tom_get_slot_Equal_variable(tom_match12_1_1); { jtom.adt.tomsignature.types.TomTerm var=tom_match12_1_1_1; { jtom.adt.tomsignature.types.ConstraintList tail=tom_match12_1_list1;


          //System.out.println("constraint: " + source + " EqualTo " + var);
        Instruction subBody = compileConstraint(var,source,body);
        return buildConstraint(tail,source,tom_make_IfThenElse(tom_make_EqualTerm(var,tom_make_ExpressionToTomTerm(source)),subBody,tom_make_Nop()));
      }}} }} }} } if(tom_is_fun_sym_concConstraint(tom_match12_1) ||  false ) { { jtom.adt.tomsignature.types.ConstraintList tom_match12_1_list1=tom_match12_1; if(!(tom_is_empty_ConstraintList(tom_match12_1_list1))) { { jtom.adt.tomsignature.types.Constraint tom_match12_1_1=tom_get_head_ConstraintList(tom_match12_1_list1);tom_match12_1_list1=tom_get_tail_ConstraintList(tom_match12_1_list1); if(tom_is_fun_sym_AssignTo(tom_match12_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm tom_match12_1_1_1=tom_get_slot_AssignTo_variable(tom_match12_1_1); if(tom_is_fun_sym_VariableStar(tom_match12_1_1_1) || tom_is_fun_sym_Variable(tom_match12_1_1_1) ||  false ) { { jtom.adt.tomsignature.types.TomTerm var=tom_match12_1_1_1; { jtom.adt.tomsignature.types.ConstraintList tail=tom_match12_1_list1;


          //System.out.println("constraint: " + source + " AssignTo " + var);
        Instruction subBody = compileConstraint(var,source,body);
        return buildConstraint(tail,source,tom_make_Let(var,source,subBody));
      }} }} }} }} } if(tom_is_fun_sym_concConstraint(tom_match12_1) ||  false ) { { jtom.adt.tomsignature.types.ConstraintList tom_match12_1_list1=tom_match12_1; if(!(tom_is_empty_ConstraintList(tom_match12_1_list1))) { { jtom.adt.tomsignature.types.Constraint head=tom_get_head_ConstraintList(tom_match12_1_list1);tom_match12_1_list1=tom_get_tail_ConstraintList(tom_match12_1_list1); { jtom.adt.tomsignature.types.ConstraintList tail=tom_match12_1_list1;


        throw new TomRuntimeException("buildConstraint: unknown constraint: " + head);
      }} }} }}}

    throw new TomRuntimeException("buildConstraint: unknown constraints: " + constraints);
  }


  private class MatchingParameter {
      /*
       * This object is used by matching-algorithms to store common parameters
       * which are not modified during the matching process
       *
       * symbol:           root symbol
       * path:             path up-to the root symbol
       * action:           list of actions to be fired when matching
       * subjectListName:  name of the internal variable supposed to store the subject
       * subjectListIndex: name of the internal variable supposed to store the index
       */
    public TomSymbol symbol;
    public TomNumberList path;
    public Instruction action;
    public TomTerm subjectListName;
    public TomTerm subjectListIndex;

    MatchingParameter(TomSymbol symbol, 
                      TomNumberList path,
                      Instruction action,
                      TomTerm subjectListName,
                      TomTerm subjectListIndex) {
      this.symbol=symbol;
      this.path=path;
      this.action=action;
      this.subjectListName=subjectListName;
      this.subjectListIndex=subjectListIndex;
    }

  }
  
} // end of class
