/* Generated by TOM: Do not edit this file */ /*
  
    TOM - To One Matching Compiler

    Copyright (C) 2000-2004 INRIA
			    Nancy, France.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    Pierre-Etienne Moreau	e-mail: Pierre-Etienne.Moreau@loria.fr

*/

package jtom.compiler;
  
import jtom.TomBase;
import jtom.adt.tomsignature.types.*;
import jtom.runtime.Replace1;
import aterm.*;
import jtom.exception.TomRuntimeException;

public class TomKernelCompiler extends TomBase {

  private boolean debugMode = false;

  public TomKernelCompiler(jtom.TomEnvironment environment, boolean debugMode) {
    super(environment);
    this.debugMode = debugMode;
  }

// ------------------------------------------------------------
  /* Generated by TOM: Do not edit this file */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
// ------------------------------------------------------------
 
  private int matchNumber = 0;

  private OptionList option() {
    return ast().makeOption();
  }

  private TomName getLabel(OptionList list) {
     { OptionList tom_match1_1 = ( OptionList) list;{ if(tom_is_fun_sym_concOption(tom_match1_1) ||  false ) { { OptionList tom_match1_1_list1 = ( OptionList) tom_match1_1; { OptionList tom_match1_1_begin1 = ( OptionList) tom_match1_1_list1; { OptionList tom_match1_1_end1 = ( OptionList) tom_match1_1_list1; do {{ if(!(tom_is_empty_OptionList(tom_match1_1_list1))) { { Option tom_absvar1 = ( Option) tom_get_head_OptionList(tom_match1_1_list1);{ tom_match1_1_list1 = ( OptionList) tom_get_tail_OptionList(tom_match1_1_list1); { Option tom_match2_1 = ( Option) tom_absvar1;{ if(tom_is_fun_sym_Label(tom_match2_1) ||  false ) { { TomName tom_match2_1_1 = ( TomName) tom_get_slot_Label_astName(tom_match2_1); if(tom_is_fun_sym_Name(tom_match2_1_1) ||  false ) { { TomName name = ( TomName) tom_match2_1_1;{
  return name; }} }} }}}}} } if(!(tom_is_empty_OptionList(tom_match1_1_end1))) { tom_match1_1_end1 = ( OptionList) tom_get_tail_OptionList(tom_match1_1_end1); } tom_match1_1_list1 = ( OptionList) tom_match1_1_end1;} } while(!(tom_is_empty_OptionList(tom_match1_1_list1)));}}} }}}
 
    return null;
  }
  
    /* 
     * compileMatching:
     * compiles the Match construct into a matching automaton: CompiledMatch
     */

  private Replace1 replace_compileMatching = new Replace1() {
      public ATerm apply(ATerm subject) {
        if(subject instanceof Instruction) {
           { Instruction tom_match3_1 = ( Instruction) subject;{ if(tom_is_fun_sym_Match(tom_match3_1) ||  false ) { { TomTerm tom_match3_1_1 = ( TomTerm) tom_get_slot_Match_subjectList(tom_match3_1); { TomTerm tom_match3_1_2 = ( TomTerm) tom_get_slot_Match_patternList(tom_match3_1); { OptionList tom_match3_1_3 = ( OptionList) tom_get_slot_Match_option(tom_match3_1); if(tom_is_fun_sym_SubjectList(tom_match3_1_1) ||  false ) { { TomList tom_match3_1_1_1 = ( TomList) tom_get_slot_SubjectList_tomList(tom_match3_1_1); { TomList l1 = ( TomList) tom_match3_1_1_1; if(tom_is_fun_sym_PatternList(tom_match3_1_2) ||  false ) { { TomList tom_match3_1_2_1 = ( TomList) tom_get_slot_PatternList_tomList(tom_match3_1_2); { TomList l2 = ( TomList) tom_match3_1_2_1; { OptionList optionList = ( OptionList) tom_match3_1_3;{
 
              boolean generatedMatch = false;
              String currentDebugKey = "noDebug";
              if(debugMode) {
                generatedMatch = hasGeneratedMatch(optionList);
                Option orgTrack = findOriginTracking(optionList);
                currentDebugKey = orgTrack.getFileName().getString() + orgTrack.getLine();
              }
                
              TomList patternList = null;
              Instruction actionInst = null;
              TomList automataList = empty();
              TomNumberList rootpath = tsf().makeTomNumberList();
              matchNumber++;
              rootpath = (TomNumberList) rootpath.append(tom_make_MatchNumber(makeNumber(matchNumber)) );
                
                /*
                 * for each pattern action (<term>,...,<term> -> <action>)
                 * build a matching automata
                 */
              int actionNumber = 0;
              boolean defaultPA =false;
              while(!l2.isEmpty()) {
                actionNumber++;
                TomTerm pa = l2.getHead();
                defaultPA = hasDefaultCase(pa.getOption());
                patternList = pa.getTermList().getTomList();
                if (debugMode && defaultPA) {
                    // replace success by leaving structure
                  TargetLanguage tl = tsf().makeTargetLanguage_ITL("jtom.debug.TomDebugger.debugger.patternSuccess(\""+currentDebugKey+"\");\njtom.debug.TomDebugger.debugger.leavingStructure(\""+currentDebugKey+"\");\n");
                  actionInst = tom_make_UnamedBlock(tom_make_insert_concInstruction(pa .getAction(),tom_make_insert_concInstruction(tom_make_TargetLanguageToInstruction(tl),( InstructionList) tom_make_empty_concInstruction()))) ;
                } else {
                  actionInst = pa.getAction();
                }
                if(patternList==null || actionInst==null) {
                  System.out.println("TomKernelCompiler: null value");
                  throw new TomRuntimeException(new Throwable("TomKernelCompiler: null value"));
                }
                  
                  /*
                   * compile nested match constructs
                   * given a list of pattern: we build a matching automaton
                   */
                actionInst = (Instruction) this.apply(actionInst);
                Instruction matchingAutomata = genSyntacticMatchingAutomata(actionInst,
                                                                            patternList,rootpath,1);
                OptionList automataOptionList = tom_make_insert_concOption(tom_make_Debug(tom_make_Name(currentDebugKey)),( OptionList) tom_make_empty_concOption()) ;
                TomName label = getLabel(pa.getOption());
                if(label != null) {
                  automataOptionList = tom_make_manyOptionList(tom_make_Label(label),automataOptionList) ;
                }
                if(defaultPA) {
                  automataOptionList = tom_make_manyOptionList(tom_make_DefaultCase(),automataOptionList) ;
                }
                TomNumberList numberList = (TomNumberList) rootpath.append(tom_make_PatternNumber(makeNumber(actionNumber)) );
                TomTerm automata = tom_make_Automata(automataOptionList,numberList,matchingAutomata) ;
                  //System.out.println("automata = " + automata);
                  
                automataList = append(automata,automataList);
                l2 = l2.getTail();
              }
                
                /*
                 * return the compiled Match construction
                 */
              InstructionList astAutomataList = automataListCompileMatchingList(automataList, generatedMatch);
              Instruction astAutomata = collectVariableFromSubjectList(l1,1,rootpath,tom_make_UnamedBlock(astAutomataList) );
              return tom_make_CompiledMatch(astAutomata,optionList) ;
            }}}} }}} }}}} }{


 
              return traversal().genericTraversal(subject,this);
            }}}
  // end match
        } else { // not instance of TomTerm
          return traversal().genericTraversal(subject,this);
        }
      } // end apply
    }; // end new

  public TomTerm compileMatching(TomTerm subject) {
    return (TomTerm) replace_compileMatching.apply(subject);
  }

    /*
     * collect match variables (from match(t1,...,tn))
     * create a list of declaration/assignement: v1=t1 ... vn=tn in body
     */
  private Instruction collectVariableFromSubjectList(TomList subjectList, int index, TomNumberList path, Instruction body) {
     { TomList tom_match4_1 = ( TomList) subjectList;{ if(tom_is_fun_sym_emptyTomList(tom_match4_1) ||  false ) {{
  return body; } } if(tom_is_fun_sym_manyTomList(tom_match4_1) ||  false ) { { TomTerm tom_match4_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match4_1); { TomList tom_match4_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match4_1); if(tom_is_fun_sym_Variable(tom_match4_1_1) ||  false ) { { TomTerm subjectVar = ( TomTerm) tom_match4_1_1; { OptionList tom_match4_1_1_1 = ( OptionList) tom_get_slot_Variable_option(tom_match4_1_1); { TomType tom_match4_1_1_3 = ( TomType) tom_get_slot_Variable_astType(tom_match4_1_1); { OptionList option = ( OptionList) tom_match4_1_1_1; { TomType variableType = ( TomType) tom_match4_1_1_3; { TomList tail = ( TomList) tom_match4_1_2;{
 
        body = collectVariableFromSubjectList(tail,index+1,path,body);
        TomTerm variable = tom_make_Variable(option,tom_make_PositionName(appendNumber(index,path)),variableType) ;
        return tom_make_Let(variable,tom_make_TomTermToExpression(subjectVar),body) ;
      }}}}}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match4_1) ||  false ) { { TomTerm tom_match4_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match4_1); { TomList tom_match4_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match4_1); if(tom_is_fun_sym_FunctionCall(tom_match4_1_1) || tom_is_fun_sym_BuildList(tom_match4_1_1) || tom_is_fun_sym_BuildTerm(tom_match4_1_1) ||  false ) { { TomTerm subjectVar = ( TomTerm) tom_match4_1_1; { TomName tom_match4_1_1_1 = ( TomName) tom_get_slot_BuildTerm_astName(tom_match4_1_1); if(tom_is_fun_sym_Name(tom_match4_1_1_1) ||  false ) { { String tom_match4_1_1_1_1 = ( String) tom_get_slot_Name_string(tom_match4_1_1_1); { String tomName = ( String) tom_match4_1_1_1_1; { TomList tail = ( TomList) tom_match4_1_2;{

 
        body = collectVariableFromSubjectList(tail,index+1,path,body);
        TomSymbol tomSymbol = symbolTable().getSymbol(tomName);
        TomType tomType = getSymbolCodomain(tomSymbol);
        TomTerm variable = tom_make_Variable(option(),tom_make_PositionName(appendNumber(index,path)),tomType) ;
        return tom_make_Let(variable,tom_make_TomTermToExpression(subjectVar),body) ;
      }}}} }}} }}} } if(tom_is_fun_sym_manyTomList(tom_match4_1) ||  false ) { { TomTerm tom_match4_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match4_1); { TomList tom_match4_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match4_1); { TomTerm subjectVar = ( TomTerm) tom_match4_1_1; { TomList tail = ( TomList) tom_match4_1_2;{

 
        System.out.println("collectVariableFromSubjectList: strange term: " + subjectVar);
      }}}}} }}}

 
    return tom_make_Nop() ;
  }

  /*
   * build a list of instructions from a list of automata
   */
  private InstructionList automataListCompileMatchingList(TomList automataList, boolean generatedMatch) {
     { TomList tom_match5_1 = ( TomList) automataList;{ if(tom_is_fun_sym_emptyTomList(tom_match5_1) ||  false ) {{
  return tom_make_emptyInstructionList() ; } } if(tom_is_fun_sym_manyTomList(tom_match5_1) ||  false ) { { TomTerm tom_match5_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match5_1); { TomList tom_match5_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match5_1); if(tom_is_fun_sym_Automata(tom_match5_1_1) ||  false ) { { OptionList tom_match5_1_1_1 = ( OptionList) tom_get_slot_Automata_option(tom_match5_1_1); { TomNumberList tom_match5_1_1_2 = ( TomNumberList) tom_get_slot_Automata_numberList(tom_match5_1_1); { Instruction tom_match5_1_1_3 = ( Instruction) tom_get_slot_Automata_inst(tom_match5_1_1); { OptionList optionList = ( OptionList) tom_match5_1_1_1; { TomNumberList numberList = ( TomNumberList) tom_match5_1_1_2; { Instruction instruction = ( Instruction) tom_match5_1_1_3; { TomList l = ( TomList) tom_match5_1_2;{
 
        InstructionList newList = automataListCompileMatchingList(l, generatedMatch);

        if(!generatedMatch && debugMode) {
          String debugKey = getDebug(optionList);
          Instruction tl1 = tom_make_TargetLanguageToInstruction(tom_make_ITL( "jtom.debug.TomDebugger.debugger.enteringPattern(\"" +debugKey + "\");\n")) ;
          Instruction tl2 = tom_make_TargetLanguageToInstruction(tom_make_ITL( "jtom.debug.TomDebugger.debugger.leavingPattern(\"" +debugKey + "\");\n")) ;
          if(!hasDefaultCase(optionList)) {
            instruction = tom_make_UnamedBlock(tom_make_insert_concInstruction(tl1,tom_make_insert_concInstruction(instruction,tom_make_insert_concInstruction(tl2,( InstructionList) tom_make_empty_concInstruction())))) ;
          } else {
            instruction = tom_make_UnamedBlock(tom_make_insert_concInstruction(tl1,tom_make_insert_concInstruction(instruction,( InstructionList) tom_make_empty_concInstruction()))) ;
          }
        }
         
        if(getLabel(optionList) != null) {
            /*
             * if a label is assigned to a pattern (label:pattern -> action)
             * we generate corresponding labeled-block
             */
          instruction = tom_make_NamedBlock(getLabel(optionList) .getString(),tom_make_insert_concInstruction(instruction,( InstructionList) tom_make_empty_concInstruction()))
 ;
          					 
        }
        return tom_make_insert_concInstruction(tom_make_CompiledPattern(instruction),tom_insert_list_concInstruction(newList,( InstructionList) tom_make_empty_concInstruction())) ;
      }}}}}}}} }}} }}}
 
    return null;
  }
  
    /*
     * ------------------------------------------------------------
     * Generate a matching automaton
     * ------------------------------------------------------------
     */
  
    /*
     * given a pattern, this function generatesthe discrimitation test on the root symbol
     * and recursively calls the algorithm on subterms
     */
  Instruction genSyntacticMatchingAutomata(Instruction action,
                                           TomList termList,
                                           TomNumberList rootpath,
                                           int indexTerm) {
    TomNumberList path = appendNumber(indexTerm,rootpath);
        
     { TomList tom_match6_1 = ( TomList) termList;{ if(tom_is_fun_sym_emptyTomList(tom_match6_1) ||  false ) {{
  
        return action;
      } } if(tom_is_fun_sym_manyTomList(tom_match6_1) ||  false ) { { TomTerm tom_match6_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match6_1); { TomList tom_match6_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match6_1); if(tom_is_fun_sym_Variable(tom_match6_1_1) ||  false ) { { TomTerm var = ( TomTerm) tom_match6_1_1; { OptionList tom_match6_1_1_1 = ( OptionList) tom_get_slot_Variable_option(tom_match6_1_1); { TomType tom_match6_1_1_3 = ( TomType) tom_get_slot_Variable_astType(tom_match6_1_1); { OptionList optionList = ( OptionList) tom_match6_1_1_1; { TomType termType = ( TomType) tom_match6_1_1_3; { TomList termTail = ( TomList) tom_match6_1_2;{


 
        Instruction subAction = genSyntacticMatchingAutomata(action,termTail,rootpath,indexTerm+1);
        Expression source = tom_make_TomTermToExpression(tom_make_Variable(option(),tom_make_PositionName(path),termType)) ;
        return buildAnnotedLet(optionList, source, var, subAction);
      }}}}}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match6_1) ||  false ) { { TomTerm tom_match6_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match6_1); { TomList tom_match6_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match6_1); if(tom_is_fun_sym_UnamedVariable(tom_match6_1_1) ||  false ) { { TomTerm var = ( TomTerm) tom_match6_1_1; { OptionList tom_match6_1_1_1 = ( OptionList) tom_get_slot_UnamedVariable_option(tom_match6_1_1); { TomType tom_match6_1_1_2 = ( TomType) tom_get_slot_UnamedVariable_astType(tom_match6_1_1); { OptionList optionList = ( OptionList) tom_match6_1_1_1; { TomType termType = ( TomType) tom_match6_1_1_2; { TomList termTail = ( TomList) tom_match6_1_2;{          Instruction subAction = genSyntacticMatchingAutomata(action,termTail,rootpath,indexTerm+1);         Expression source = tom_make_TomTermToExpression(tom_make_Variable(option(),tom_make_PositionName(path),termType)) ;         return buildAnnotedLet(optionList, source, var, subAction);       }}}}}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match6_1) ||  false ) { { TomTerm tom_match6_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match6_1); { TomList tom_match6_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match6_1); if(tom_is_fun_sym_Appl(tom_match6_1_1) ||  false ) { { TomTerm term = ( TomTerm) tom_match6_1_1; { OptionList tom_match6_1_1_1 = ( OptionList) tom_get_slot_Appl_option(tom_match6_1_1); { NameList tom_match6_1_1_2 = ( NameList) tom_get_slot_Appl_nameList(tom_match6_1_1); { TomList tom_match6_1_1_3 = ( TomList) tom_get_slot_Appl_args(tom_match6_1_1); { OptionList optionList = ( OptionList) tom_match6_1_1_1; if(tom_is_fun_sym_concTomName(tom_match6_1_1_2) ||  false ) { { NameList nameList = ( NameList) tom_match6_1_1_2; { NameList tom_match6_1_1_2_list1 = ( NameList) tom_match6_1_1_2; if(!(tom_is_empty_NameList(tom_match6_1_1_2_list1))) { { TomName tom_absvar2 = ( TomName) tom_get_head_NameList(tom_match6_1_1_2_list1);{ tom_match6_1_1_2_list1 = ( NameList) tom_get_tail_NameList(tom_match6_1_1_2_list1); { TomList termArgs = ( TomList) tom_match6_1_1_3; { TomList termTail = ( TomList) tom_match6_1_2; { TomName tom_match7_1 = ( TomName) tom_absvar2;{ if(tom_is_fun_sym_Name(tom_match7_1) ||  false ) { { String tom_match7_1_1 = ( String) tom_get_slot_Name_string(tom_match7_1); { String tomName = ( String) tom_match7_1_1;{

 
        Instruction subAction = genSyntacticMatchingAutomata(action,termTail,rootpath,indexTerm+1);
        TomSymbol tomSymbol = symbolTable().getSymbol(tomName);
        TomTypeList termTypeList = tomSymbol.getTypesToType().getDomain();
        TomType termType = tomSymbol.getTypesToType().getCodomain();
        
        // SUCCES
        TomTerm subjectVariableAST =  tom_make_Variable(option(),tom_make_PositionName(path),termType) ;
        Instruction automataInstruction;
        if(isListOperator(tomSymbol)) {
          /*
           * store the subject into an internal variable
           * call genListMatchingAutomata with the new internal variable
           */
          int indexSubterm = 1;
          TomNumberList newPath = (TomNumberList) path.append(tom_make_ListNumber(makeNumber(indexSubterm)) );
          TomTerm newSubjectVariableAST =  tom_make_Variable(option(),tom_make_PositionName(newPath),termType) ;
          Instruction automata = genListMatchingAutomata(new MatchingParameter(
                                                           tomSymbol,path,subAction,
                                                           newSubjectVariableAST,
                                                           newSubjectVariableAST),
                                                         termArgs,indexSubterm);
          automataInstruction = tom_make_LetRef(newSubjectVariableAST,tom_make_TomTermToExpression(subjectVariableAST),automata)

 ;
        } else if(isArrayOperator(tomSymbol)) {
          int indexSubterm = 1;
          TomNumberList newPathList = (TomNumberList) path.append(tom_make_ListNumber(makeNumber(indexSubterm)) );
          TomNumberList newPathIndex = (TomNumberList) path.append(tom_make_IndexNumber(makeNumber(indexSubterm)) );
          TomTerm newVariableListAST = tom_make_Variable(option(),tom_make_PositionName(newPathList),termType) ;
          TomTerm newVariableIndexAST = tom_make_Variable(option(),tom_make_PositionName(newPathIndex),symbolTable() .getIntType()) ;
          Instruction automata = genArrayMatchingAutomata(new MatchingParameter(
                                                            tomSymbol,path,subAction,
                                                            newVariableListAST, newVariableIndexAST),
                                                          termArgs,indexSubterm
                                                          );
          Expression glZero = tom_make_TomTermToExpression(tom_make_TargetLanguageToTomTerm(tom_make_ITL( "0"))) ;
          automataInstruction = tom_make_Let(newVariableIndexAST,glZero,tom_make_Let(newVariableListAST,tom_make_TomTermToExpression(subjectVariableAST),automata))


 ;
        } else {
          int indexSubterm = 0;
          Instruction automata = genSyntacticMatchingAutomata(subAction,termArgs,path,indexSubterm+1);
          automataInstruction = collectSubtermFromSubjectList(termArgs,termTypeList,tomSymbol,subjectVariableAST,indexSubterm,path,automata) ; 
        }
        
        TomTerm annotedVariable = getAnnotedVariable(optionList);
        if(annotedVariable != null) {
          automataInstruction = tom_make_Let(annotedVariable,tom_make_TomTermToExpression(subjectVariableAST),automataInstruction) ;
        }
        
        Expression cond = expandDisjunction(tom_make_EqualFunctionSymbol(subjectVariableAST,term)) ;
        Instruction test = tom_make_IfThenElse(cond,automataInstruction,tom_make_Nop()) ;
        return test;
      }}} }}}}}}} }}} }}}}}} }}} }{

 
        System.out.println("GenSyntacticMatchingAutomata strange term: " + termList);
        throw new TomRuntimeException(new Throwable("GenSyntacticMatchingAutomata strange term: " + termList));
      }}}
 
  }

    /*
     * function which compiles list-matching
     * 
     * p:         parameters (which are not modified during the matching process)
     * termList:  list of subterms
     * indexTerm: index of the considered subterm (indexTerm=1 for the first call)
     */
  Instruction genListMatchingAutomata(MatchingParameter p,TomList termList,int indexTerm) {
     { TomList tom_match8_1 = ( TomList) termList;{ if(tom_is_fun_sym_emptyTomList(tom_match8_1) ||  false ) {{
 
        /*
         * generate:
         * ---------
         * if(IS_EMPTY_TomList(subjectList)) {
         *   ...
         * }
         */
        Instruction test = tom_make_IfThenElse(tom_make_IsEmptyList(p .subjectListName),p .action,tom_make_Nop())

 ;
        return test;
      } } if(tom_is_fun_sym_manyTomList(tom_match8_1) ||  false ) { { TomTerm tom_match8_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match8_1); { TomList tom_match8_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match8_1); if(tom_is_fun_sym_Variable(tom_match8_1_1) ||  false ) { { TomTerm var = ( TomTerm) tom_match8_1_1; { OptionList tom_match8_1_1_1 = ( OptionList) tom_get_slot_Variable_option(tom_match8_1_1); { TomType tom_match8_1_1_3 = ( TomType) tom_get_slot_Variable_astType(tom_match8_1_1); { OptionList optionList = ( OptionList) tom_match8_1_1_1; { TomType termType = ( TomType) tom_match8_1_1_3; { TomList termTail = ( TomList) tom_match8_1_2;{


 
        /*
         * generate:
         * ---------
         * if(!IS_EMPTY_TomList(subjectList)) {
         *   Let TomTerm x_j = (TomTerm) GET_HEAD_TomList(subjectList);
         *   subjectList =  (TomList) GET_TAIL_TomList(subjectList);
         *   ...
         * }
         */
        Instruction subAction = genListMatchingAutomata(p,termTail,indexTerm+1);
     
        Instruction body = tom_make_UnamedBlock(tom_make_insert_concInstruction(tom_make_Assign(p .subjectListName,tom_make_GetTail(p .subjectListName)),tom_make_insert_concInstruction(subAction,( InstructionList) tom_make_empty_concInstruction()))) ;
        Expression source = tom_make_GetHead(p .subjectListName) ;
        Instruction let = buildAnnotedLet(optionList, source, var, body);
        Instruction test = tom_make_IfThenElse(tom_make_Not(tom_make_IsEmptyList(p .subjectListName)),let,tom_make_Nop())
 ;
        return test;
      }}}}}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match8_1) ||  false ) { { TomTerm tom_match8_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match8_1); { TomList tom_match8_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match8_1); if(tom_is_fun_sym_UnamedVariable(tom_match8_1_1) ||  false ) { { TomTerm var = ( TomTerm) tom_match8_1_1; { OptionList tom_match8_1_1_1 = ( OptionList) tom_get_slot_UnamedVariable_option(tom_match8_1_1); { TomType tom_match8_1_1_2 = ( TomType) tom_get_slot_UnamedVariable_astType(tom_match8_1_1); { OptionList optionList = ( OptionList) tom_match8_1_1_1; { TomType termType = ( TomType) tom_match8_1_1_2; { TomList termTail = ( TomList) tom_match8_1_2;{          /*          * generate:          * ---------          * if(!IS_EMPTY_TomList(subjectList)) {          *   Let TomTerm x_j = (TomTerm) GET_HEAD_TomList(subjectList);          *   subjectList =  (TomList) GET_TAIL_TomList(subjectList);          *   ...          * }          */         Instruction subAction = genListMatchingAutomata(p,termTail,indexTerm+1);               Instruction body = tom_make_UnamedBlock(tom_make_insert_concInstruction(tom_make_Assign(p .subjectListName,tom_make_GetTail(p .subjectListName)),tom_make_insert_concInstruction(subAction,( InstructionList) tom_make_empty_concInstruction()))) ;         Expression source = tom_make_GetHead(p .subjectListName) ;         Instruction let = buildAnnotedLet(optionList, source, var, body);         Instruction test = tom_make_IfThenElse(tom_make_Not(tom_make_IsEmptyList(p .subjectListName)),let,tom_make_Nop()) ;         return test;       }}}}}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match8_1) ||  false ) { { TomTerm tom_match8_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match8_1); { TomList tom_match8_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match8_1); if(tom_is_fun_sym_VariableStar(tom_match8_1_1) ||  false ) { { TomTerm var = ( TomTerm) tom_match8_1_1; { OptionList tom_match8_1_1_1 = ( OptionList) tom_get_slot_VariableStar_option(tom_match8_1_1); { TomType tom_match8_1_1_3 = ( TomType) tom_get_slot_VariableStar_astType(tom_match8_1_1); { OptionList optionList = ( OptionList) tom_match8_1_1_1; { TomType termType = ( TomType) tom_match8_1_1_3; { TomList termTail = ( TomList) tom_match8_1_2;{


 
        if(termTail.isEmpty()) {
          /*
           * generate:
           * ---------
           * Let E_n = subjectList;
           * ...
           */
          Expression source = tom_make_TomTermToExpression(p .subjectListName) ;
          Instruction let = buildAnnotedLet(optionList, source, var, p.action);
          return  let;
        } else {
          /*
           * generate:
           * ---------
           * LetRef begin_i = subjectList;
           * LetRef end_i   = subjectList;
           * do {
           *   * SUBSTITUTION: E_i
           *   TomList E_i = GET_SLICE_TomList(begin_i,end_i);
           *   ...
           *   if(!IS_EMPTY_TomList(end_i) )
           *     end_i = (TomList) GET_TAIL_TomList(end_i);
           *   subjectList = end_i;
           * } while( !IS_EMPTY_TomList(subjectList) )
           */
          Instruction subAction = genListMatchingAutomata(p,termTail,indexTerm+1);
          TomNumberList pathBegin = (TomNumberList) p.path.append(tom_make_Begin(makeNumber(indexTerm)) );
          TomNumberList pathEnd = (TomNumberList) p.path.append(tom_make_End(makeNumber(indexTerm)) );
          TomTerm variableBeginAST = tom_make_Variable(option(),tom_make_PositionName(pathBegin),termType) ;
          TomTerm variableEndAST   = tom_make_Variable(option(),tom_make_PositionName(pathEnd),termType) ;

          Expression source = tom_make_GetSliceList(p .symbol .getAstName(),variableBeginAST,variableEndAST) ;
          Instruction let = buildAnnotedLet(optionList, source, var, subAction);
          Instruction test1 = tom_make_IfThenElse(tom_make_Not(tom_make_IsEmptyList(variableEndAST)),tom_make_Assign(variableEndAST,tom_make_GetTail(variableEndAST)),tom_make_Nop())

 ;
          Instruction assign = tom_make_Assign(p .subjectListName,tom_make_TomTermToExpression(variableEndAST)) ;
          Instruction doWhile = tom_make_DoWhile(tom_make_UnamedBlock(tom_make_insert_concInstruction(let,tom_make_insert_concInstruction(test1,tom_make_insert_concInstruction(assign,( InstructionList) tom_make_empty_concInstruction())))),tom_make_Not(tom_make_IsEmptyList(p .subjectListName)))
 ;
         
          Instruction letEnd = tom_make_LetRef(variableEndAST,tom_make_TomTermToExpression(p .subjectListName),doWhile)

 ;
          Instruction letBegin = tom_make_LetRef(variableBeginAST,tom_make_TomTermToExpression(p .subjectListName),letEnd)

 ;
          return letBegin;
        }
      }}}}}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match8_1) ||  false ) { { TomTerm tom_match8_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match8_1); { TomList tom_match8_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match8_1); if(tom_is_fun_sym_UnamedVariableStar(tom_match8_1_1) ||  false ) { { TomTerm var = ( TomTerm) tom_match8_1_1; { OptionList tom_match8_1_1_1 = ( OptionList) tom_get_slot_UnamedVariableStar_option(tom_match8_1_1); { TomType tom_match8_1_1_2 = ( TomType) tom_get_slot_UnamedVariableStar_astType(tom_match8_1_1); { OptionList optionList = ( OptionList) tom_match8_1_1_1; { TomType termType = ( TomType) tom_match8_1_1_2; { TomList termTail = ( TomList) tom_match8_1_2;{          if(termTail.isEmpty()) {           /*            * generate:            * ---------            * Let E_n = subjectList;            * ...            */           Expression source = tom_make_TomTermToExpression(p .subjectListName) ;           Instruction let = buildAnnotedLet(optionList, source, var, p.action);           return  let;         } else {           /*            * generate:            * ---------            * LetRef begin_i = subjectList;            * LetRef end_i   = subjectList;            * do {            *   * SUBSTITUTION: E_i            *   TomList E_i = GET_SLICE_TomList(begin_i,end_i);            *   ...            *   if(!IS_EMPTY_TomList(end_i) )            *     end_i = (TomList) GET_TAIL_TomList(end_i);            *   subjectList = end_i;            * } while( !IS_EMPTY_TomList(subjectList) )            */           Instruction subAction = genListMatchingAutomata(p,termTail,indexTerm+1);           TomNumberList pathBegin = (TomNumberList) p.path.append(tom_make_Begin(makeNumber(indexTerm)) );           TomNumberList pathEnd = (TomNumberList) p.path.append(tom_make_End(makeNumber(indexTerm)) );           TomTerm variableBeginAST = tom_make_Variable(option(),tom_make_PositionName(pathBegin),termType) ;           TomTerm variableEndAST   = tom_make_Variable(option(),tom_make_PositionName(pathEnd),termType) ;            Expression source = tom_make_GetSliceList(p .symbol .getAstName(),variableBeginAST,variableEndAST) ;           Instruction let = buildAnnotedLet(optionList, source, var, subAction);           Instruction test1 = tom_make_IfThenElse(tom_make_Not(tom_make_IsEmptyList(variableEndAST)),tom_make_Assign(variableEndAST,tom_make_GetTail(variableEndAST)),tom_make_Nop()) ;           Instruction assign = tom_make_Assign(p .subjectListName,tom_make_TomTermToExpression(variableEndAST)) ;           Instruction doWhile = tom_make_DoWhile(tom_make_UnamedBlock(tom_make_insert_concInstruction(let,tom_make_insert_concInstruction(test1,tom_make_insert_concInstruction(assign,( InstructionList) tom_make_empty_concInstruction())))),tom_make_Not(tom_make_IsEmptyList(p .subjectListName))) ;                     Instruction letEnd = tom_make_LetRef(variableEndAST,tom_make_TomTermToExpression(p .subjectListName),doWhile) ;           Instruction letBegin = tom_make_LetRef(variableBeginAST,tom_make_TomTermToExpression(p .subjectListName),letEnd) ;           return letBegin;         }       }}}}}}} }}} }{

 
        System.out.println("GenListMatchingAutomata strange termList: " + termList);
        throw new TomRuntimeException(new Throwable("GenListMatchingAutomata strange termList: " + termList));
      }}}
 
  }

    /*
     * function which compiles array-matching
     * 
     * p:         parameters (which are not modified during the matching process)
     * termList:  list of subterms
     * indexTerm: index of the considered subterm (indexTerm=1 for the first call)
     */
  Instruction genArrayMatchingAutomata(MatchingParameter p,TomList termList,int indexTerm) {
     { TomList tom_match9_1 = ( TomList) termList;{ if(tom_is_fun_sym_emptyTomList(tom_match9_1) ||  false ) {{
 
        /*
         * generate:
         * ---------
         * if(IS_EMPTY_TomList(subjectList,subjectIndex)) {
         *   ...
         * }
         */
        Expression cond = tom_make_IsEmptyArray(p .subjectListName,p .subjectListIndex) ;
        Instruction test = tom_make_IfThenElse(cond,p .action,tom_make_Nop()) ;
        return test;
      } } if(tom_is_fun_sym_manyTomList(tom_match9_1) ||  false ) { { TomTerm tom_match9_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match9_1); { TomList tom_match9_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match9_1); if(tom_is_fun_sym_Variable(tom_match9_1_1) ||  false ) { { TomTerm var = ( TomTerm) tom_match9_1_1; { OptionList tom_match9_1_1_1 = ( OptionList) tom_get_slot_Variable_option(tom_match9_1_1); { TomType tom_match9_1_1_3 = ( TomType) tom_get_slot_Variable_astType(tom_match9_1_1); { OptionList optionList = ( OptionList) tom_match9_1_1_1; { TomType termType = ( TomType) tom_match9_1_1_3; { TomList termTail = ( TomList) tom_match9_1_2;{


 
          /*
           * generate:
           * ---------
           * if(!IS_EMPTY_TomList(subjectList,subjectIndex)) {
           *   Let TomTerm x_j = (TomTerm) GET_ELEMENT_L(subjectList,subjectIndex);
           *   subjectIndex++;
           *     ...
           * }
           */
        Instruction subAction = genArrayMatchingAutomata(p,termTail,indexTerm+1);
        InstructionList bodyList = tom_make_insert_concInstruction(tom_make_Increment(p .subjectListIndex),tom_make_insert_concInstruction(subAction,( InstructionList) tom_make_empty_concInstruction())) ;
        Instruction body = tom_make_UnamedBlock(bodyList) ;
        Expression source = tom_make_GetElement(p .subjectListName,p .subjectListIndex) ;
        Instruction let = buildAnnotedLet(optionList, source, var, body);
        Instruction test = tom_make_IfThenElse(tom_make_Not(tom_make_IsEmptyArray(p .subjectListName,p .subjectListIndex)),let,tom_make_Nop())
 ;
        return test;
      }}}}}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match9_1) ||  false ) { { TomTerm tom_match9_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match9_1); { TomList tom_match9_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match9_1); if(tom_is_fun_sym_UnamedVariable(tom_match9_1_1) ||  false ) { { TomTerm var = ( TomTerm) tom_match9_1_1; { OptionList tom_match9_1_1_1 = ( OptionList) tom_get_slot_UnamedVariable_option(tom_match9_1_1); { TomType tom_match9_1_1_2 = ( TomType) tom_get_slot_UnamedVariable_astType(tom_match9_1_1); { OptionList optionList = ( OptionList) tom_match9_1_1_1; { TomType termType = ( TomType) tom_match9_1_1_2; { TomList termTail = ( TomList) tom_match9_1_2;{            /*            * generate:            * ---------            * if(!IS_EMPTY_TomList(subjectList,subjectIndex)) {            *   Let TomTerm x_j = (TomTerm) GET_ELEMENT_L(subjectList,subjectIndex);            *   subjectIndex++;            *     ...            * }            */         Instruction subAction = genArrayMatchingAutomata(p,termTail,indexTerm+1);         InstructionList bodyList = tom_make_insert_concInstruction(tom_make_Increment(p .subjectListIndex),tom_make_insert_concInstruction(subAction,( InstructionList) tom_make_empty_concInstruction())) ;         Instruction body = tom_make_UnamedBlock(bodyList) ;         Expression source = tom_make_GetElement(p .subjectListName,p .subjectListIndex) ;         Instruction let = buildAnnotedLet(optionList, source, var, body);         Instruction test = tom_make_IfThenElse(tom_make_Not(tom_make_IsEmptyArray(p .subjectListName,p .subjectListIndex)),let,tom_make_Nop()) ;         return test;       }}}}}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match9_1) ||  false ) { { TomTerm tom_match9_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match9_1); { TomList tom_match9_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match9_1); if(tom_is_fun_sym_VariableStar(tom_match9_1_1) ||  false ) { { TomTerm var = ( TomTerm) tom_match9_1_1; { OptionList tom_match9_1_1_1 = ( OptionList) tom_get_slot_VariableStar_option(tom_match9_1_1); { TomType tom_match9_1_1_3 = ( TomType) tom_get_slot_VariableStar_astType(tom_match9_1_1); { OptionList optionList = ( OptionList) tom_match9_1_1_1; { TomType termType = ( TomType) tom_match9_1_1_3; { TomList termTail = ( TomList) tom_match9_1_2;{


 
        if(termTail.isEmpty()) {
            /*
             * generate:
             * ---------
             * Let E_n = GET_SLICE_L(subjectList,subjectIndex,GET_SIZE_L(subjectList));
             * ...
             */
          Expression source = tom_make_GetSliceArray(p .symbol .getAstName(),p .subjectListName,p .subjectListIndex,tom_make_ExpressionToTomTerm(tom_make_GetSize(p .subjectListName)))



 ;
          Instruction let = buildAnnotedLet(optionList, source, var, p.action);
          return let;
        } else {
            /*
             * generate:
             * ---------
             * int begin_i = subjectIndex;
             * int end_i   = subjectIndex;
             * do {
             *   * SUBSTITUTION: E_i
             *   TomList E_i = GET_SLICE_TomList(subjectList,begin_i,end_i);
             *   ...
             *   end_i++;
             *   subjectIndex = end_i;
             * } while( !IS_EMPTY_TomList(subjectList) )
             */
          Instruction subAction = genArrayMatchingAutomata(p,termTail,indexTerm+1);
          TomNumberList pathBegin = (TomNumberList) p.path.append(tom_make_Begin(makeNumber(indexTerm)) );
          TomNumberList pathEnd = (TomNumberList) p.path.append(tom_make_End(makeNumber(indexTerm)) );
            /* TODO: termType */
          TomTerm variableBeginAST = tom_make_Variable(option(),tom_make_PositionName(pathBegin),symbolTable() .getIntType()) ;
          TomTerm variableEndAST   = tom_make_Variable(option(),tom_make_PositionName(pathEnd),symbolTable() .getIntType()) ;

          Expression source = tom_make_GetSliceArray(p .symbol .getAstName(),p .subjectListName,variableBeginAST,variableEndAST)

 ;

          Instruction let = buildAnnotedLet(optionList, source, var, subAction);
          Instruction increment = tom_make_Increment(variableEndAST) ;
          Instruction assign = tom_make_Assign(p .subjectListIndex,tom_make_TomTermToExpression(variableEndAST)) ;
          Instruction doWhile = tom_make_DoWhile(tom_make_UnamedBlock(tom_make_insert_concInstruction(let,tom_make_insert_concInstruction(increment,tom_make_insert_concInstruction(assign,( InstructionList) tom_make_empty_concInstruction())))),tom_make_Not(tom_make_IsEmptyArray(p .subjectListName,p .subjectListIndex)))
 ;
          Instruction letEnd = tom_make_LetRef(variableEndAST,tom_make_TomTermToExpression(p .subjectListIndex),doWhile)

 ;
          Instruction letBegin = tom_make_LetRef(variableBeginAST,tom_make_TomTermToExpression(p .subjectListIndex),letEnd)

 ;
          return letBegin;
        }
      }}}}}}} }}} } if(tom_is_fun_sym_manyTomList(tom_match9_1) ||  false ) { { TomTerm tom_match9_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match9_1); { TomList tom_match9_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match9_1); if(tom_is_fun_sym_UnamedVariableStar(tom_match9_1_1) ||  false ) { { TomTerm var = ( TomTerm) tom_match9_1_1; { OptionList tom_match9_1_1_1 = ( OptionList) tom_get_slot_UnamedVariableStar_option(tom_match9_1_1); { TomType tom_match9_1_1_2 = ( TomType) tom_get_slot_UnamedVariableStar_astType(tom_match9_1_1); { OptionList optionList = ( OptionList) tom_match9_1_1_1; { TomType termType = ( TomType) tom_match9_1_1_2; { TomList termTail = ( TomList) tom_match9_1_2;{          if(termTail.isEmpty()) {             /*              * generate:              * ---------              * Let E_n = GET_SLICE_L(subjectList,subjectIndex,GET_SIZE_L(subjectList));              * ...              */           Expression source = tom_make_GetSliceArray(p .symbol .getAstName(),p .subjectListName,p .subjectListIndex,tom_make_ExpressionToTomTerm(tom_make_GetSize(p .subjectListName))) ;           Instruction let = buildAnnotedLet(optionList, source, var, p.action);           return let;         } else {             /*              * generate:              * ---------              * int begin_i = subjectIndex;              * int end_i   = subjectIndex;              * do {              *   * SUBSTITUTION: E_i              *   TomList E_i = GET_SLICE_TomList(subjectList,begin_i,end_i);              *   ...              *   end_i++;              *   subjectIndex = end_i;              * } while( !IS_EMPTY_TomList(subjectList) )              */           Instruction subAction = genArrayMatchingAutomata(p,termTail,indexTerm+1);           TomNumberList pathBegin = (TomNumberList) p.path.append(tom_make_Begin(makeNumber(indexTerm)) );           TomNumberList pathEnd = (TomNumberList) p.path.append(tom_make_End(makeNumber(indexTerm)) );             /* TODO: termType */           TomTerm variableBeginAST = tom_make_Variable(option(),tom_make_PositionName(pathBegin),symbolTable() .getIntType()) ;           TomTerm variableEndAST   = tom_make_Variable(option(),tom_make_PositionName(pathEnd),symbolTable() .getIntType()) ;            Expression source = tom_make_GetSliceArray(p .symbol .getAstName(),p .subjectListName,variableBeginAST,variableEndAST) ;            Instruction let = buildAnnotedLet(optionList, source, var, subAction);           Instruction increment = tom_make_Increment(variableEndAST) ;           Instruction assign = tom_make_Assign(p .subjectListIndex,tom_make_TomTermToExpression(variableEndAST)) ;           Instruction doWhile = tom_make_DoWhile(tom_make_UnamedBlock(tom_make_insert_concInstruction(let,tom_make_insert_concInstruction(increment,tom_make_insert_concInstruction(assign,( InstructionList) tom_make_empty_concInstruction())))),tom_make_Not(tom_make_IsEmptyArray(p .subjectListName,p .subjectListIndex))) ;           Instruction letEnd = tom_make_LetRef(variableEndAST,tom_make_TomTermToExpression(p .subjectListIndex),doWhile) ;           Instruction letBegin = tom_make_LetRef(variableBeginAST,tom_make_TomTermToExpression(p .subjectListIndex),letEnd) ;           return letBegin;         }       }}}}}}} }}} }{

 
        System.out.println("GenArrayMatchingAutomata strange termList: " + termList);
        throw new TomRuntimeException(new Throwable("GenArrayMatchingAutomata strange termList: " + termList));
      }}}
 
  }

    /*
     * given a list of subject t1,...,tn
     * declare/assign internal matching variables: match_path_i = ti
     */
  private Instruction collectSubtermFromSubjectList(TomList termArgList, TomTypeList termTypeList,
                                                    TomSymbol tomSymbol,TomTerm subjectVariableAST, 
                                                    int indexSubterm, TomNumberList path, Instruction body) {
    TomName termNameAST = tomSymbol.getAstName();
     { TomList tom_match10_1 = ( TomList) termArgList;{ if(tom_is_fun_sym_emptyTomList(tom_match10_1) ||  false ) {{
  return body; } } if(tom_is_fun_sym_manyTomList(tom_match10_1) ||  false ) { { TomTerm tom_match10_1_1 = ( TomTerm) tom_get_slot_manyTomList_head(tom_match10_1); { TomList tom_match10_1_2 = ( TomList) tom_get_slot_manyTomList_tail(tom_match10_1); { TomTerm subtermArg = ( TomTerm) tom_match10_1_1; { TomList tail = ( TomList) tom_match10_1_2;{

 
        body = collectSubtermFromSubjectList(tail,termTypeList.getTail(),
                                             tomSymbol,subjectVariableAST,
                                             indexSubterm+1,path,body);
        if(subtermArg.isUnamedVariable() && !isAnnotedVariable(subtermArg)) {
            // This is an optimisation 
            // Do not assign the subterm: skip the subterm 
          return body;
        } else {
          TomType subtermType    = termTypeList.getHead();
          Expression getSubtermAST;
          TomName slotName = getSlotName(tomSymbol, indexSubterm);
          if(slotName == null) {
            getSubtermAST = tom_make_GetSubterm(subjectVariableAST,makeNumber(indexSubterm)) ;
          } else {
            getSubtermAST = tom_make_GetSlot(termNameAST,slotName .getString(),subjectVariableAST) ;
          }
          TomNumberList newPath  = appendNumber(indexSubterm+1,path);
          TomTerm newVariableAST = tom_make_Variable(option(),tom_make_PositionName(newPath),subtermType) ;
          return tom_make_Let(newVariableAST,getSubtermAST,body) ;
        }
      }}}}} }}}

 
    return tom_make_Nop() ;
  }

  private Expression expandDisjunction(Expression exp) {
    Expression cond = tom_make_FalseTL() ;
     { Expression tom_match11_1 = ( Expression) exp;{ if(tom_is_fun_sym_EqualFunctionSymbol(tom_match11_1) ||  false ) { { TomTerm tom_match11_1_1 = ( TomTerm) tom_get_slot_EqualFunctionSymbol_kid1(tom_match11_1); { TomTerm tom_match11_1_2 = ( TomTerm) tom_get_slot_EqualFunctionSymbol_kid2(tom_match11_1); if(tom_is_fun_sym_Variable(tom_match11_1_1) ||  false ) { { TomTerm var = ( TomTerm) tom_match11_1_1; if(tom_is_fun_sym_Appl(tom_match11_1_2) ||  false ) { { OptionList tom_match11_1_2_1 = ( OptionList) tom_get_slot_Appl_option(tom_match11_1_2); { NameList tom_match11_1_2_2 = ( NameList) tom_get_slot_Appl_nameList(tom_match11_1_2); { TomList tom_match11_1_2_3 = ( TomList) tom_get_slot_Appl_args(tom_match11_1_2); { OptionList option = ( OptionList) tom_match11_1_2_1; { NameList nameList = ( NameList) tom_match11_1_2_2; { TomList l = ( TomList) tom_match11_1_2_3;{
 
        while(!nameList.isEmpty()) {
          TomName name = nameList.getHead();
          Expression check = tom_make_EqualFunctionSymbol(var,tom_make_Appl(option,tom_make_insert_concTomName(name,( NameList) tom_make_empty_concTomName()),l)) ;
          cond = tom_make_Or(check,cond) ;
          nameList = nameList.getTail();
        }
      }}}}}}} }} }}} }}}
 
    return cond;
  }

  private Instruction buildAnnotedLet(OptionList optionList,
                                      Expression source,
                                      TomTerm dest,
                                      Instruction body) {
    TomTerm annotedVariable = getAnnotedVariable(optionList);
    if(annotedVariable != null) {
      body = tom_make_Let(annotedVariable,source,body) ;
    }
    return tom_make_Let(dest,source,body) ;
  }

  private class MatchingParameter {
      /*
       * This object is used by matching-algorithms to store common parameters
       * which are not modified during the matching process
       *
       * symbol:           root symbol
       * path:             path up-to the root symbol
       * action:           list of actions to be fired when matching
       * subjectListName:  name of the internal variable supposed to store the subject
       * subjectListIndex: name of the internal variable supposed to store the index
       */
    public TomSymbol symbol;
    public TomNumberList path;
    public Instruction action;
    public TomTerm subjectListName;
    public TomTerm subjectListIndex;

    MatchingParameter(TomSymbol symbol, 
                      TomNumberList path,
                      Instruction action,
                      TomTerm subjectListName,
                      TomTerm subjectListIndex) {
      this.symbol=symbol;
      this.path=path;
      this.action=action;
      this.subjectListName=subjectListName;
      this.subjectListIndex=subjectListIndex;
    }

  }
  
} // end of class
  


    
