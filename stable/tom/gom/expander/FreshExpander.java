/* Generated by TOM (version 2.6): Do not edit this file *//*
 * Gom
 * 
 * Copyright (c) 2000-2008, INRIA
 * Nancy, France.
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 * 
 * Antoine Reilles    e-mail: Antoine.Reilles@loria.fr
 * 
 **/

package tom.gom.expander;

import java.util.logging.Level;
import tom.gom.GomStreamManager;
import tom.gom.SymbolTable;
import tom.gom.adt.gom.types.*;
import tom.library.sl.*;
import java.util.ArrayList;
import java.util.Set;
import tom.gom.SymbolTable.*;
import tom.gom.tools.GomEnvironment;

public class FreshExpander {

  /* Generated by TOM (version 2.6): Do not edit this file *//* Generated by TOM (version 2.6): Do not edit this file *//* Generated by TOM (version 2.6): Do not edit this file */  /* Generated by TOM (version 2.6): Do not edit this file */    public static   tom.gom.adt.gom.types.ArgList  tom_append_list_ConcArg( tom.gom.adt.gom.types.ArgList l1,  tom.gom.adt.gom.types.ArgList  l2) {     if( l1.isEmptyConcArg() ) {       return l2;     } else if( l2.isEmptyConcArg() ) {       return l1;     } else if(  l1.getTailConcArg() .isEmptyConcArg() ) {       return  tom.gom.adt.gom.types.arglist.ConsConcArg.make( l1.getHeadConcArg() ,l2) ;     } else {       return  tom.gom.adt.gom.types.arglist.ConsConcArg.make( l1.getHeadConcArg() ,tom_append_list_ConcArg( l1.getTailConcArg() ,l2)) ;     }   }   public static   tom.gom.adt.gom.types.ArgList  tom_get_slice_ConcArg( tom.gom.adt.gom.types.ArgList  begin,  tom.gom.adt.gom.types.ArgList  end, tom.gom.adt.gom.types.ArgList  tail) {     if( (begin==end) ) {       return tail;     } else if( (end==tail)  && ( end.isEmptyConcArg()  ||  (end== tom.gom.adt.gom.types.arglist.EmptyConcArg.make() ) )) {       /* code to avoid a call to make, and thus to avoid looping during list-matching */       return begin;     }     return  tom.gom.adt.gom.types.arglist.ConsConcArg.make( begin.getHeadConcArg() ,( tom.gom.adt.gom.types.ArgList )tom_get_slice_ConcArg( begin.getTailConcArg() ,end,tail)) ;   }      public static   tom.gom.adt.gom.types.AtomList  tom_append_list_ConcAtom( tom.gom.adt.gom.types.AtomList l1,  tom.gom.adt.gom.types.AtomList  l2) {     if( l1.isEmptyConcAtom() ) {       return l2;     } else if( l2.isEmptyConcAtom() ) {       return l1;     } else if(  l1.getTailConcAtom() .isEmptyConcAtom() ) {       return  tom.gom.adt.gom.types.atomlist.ConsConcAtom.make( l1.getHeadConcAtom() ,l2) ;     } else {       return  tom.gom.adt.gom.types.atomlist.ConsConcAtom.make( l1.getHeadConcAtom() ,tom_append_list_ConcAtom( l1.getTailConcAtom() ,l2)) ;     }   }   public static   tom.gom.adt.gom.types.AtomList  tom_get_slice_ConcAtom( tom.gom.adt.gom.types.AtomList  begin,  tom.gom.adt.gom.types.AtomList  end, tom.gom.adt.gom.types.AtomList  tail) {     if( (begin==end) ) {       return tail;     } else if( (end==tail)  && ( end.isEmptyConcAtom()  ||  (end== tom.gom.adt.gom.types.atomlist.EmptyConcAtom.make() ) )) {       /* code to avoid a call to make, and thus to avoid looping during list-matching */       return begin;     }     return  tom.gom.adt.gom.types.atomlist.ConsConcAtom.make( begin.getHeadConcAtom() ,( tom.gom.adt.gom.types.AtomList )tom_get_slice_ConcAtom( begin.getTailConcAtom() ,end,tail)) ;   }      public static   tom.gom.adt.gom.types.ProductionList  tom_append_list_ConcProduction( tom.gom.adt.gom.types.ProductionList l1,  tom.gom.adt.gom.types.ProductionList  l2) {     if( l1.isEmptyConcProduction() ) {       return l2;     } else if( l2.isEmptyConcProduction() ) {       return l1;     } else if(  l1.getTailConcProduction() .isEmptyConcProduction() ) {       return  tom.gom.adt.gom.types.productionlist.ConsConcProduction.make( l1.getHeadConcProduction() ,l2) ;     } else {       return  tom.gom.adt.gom.types.productionlist.ConsConcProduction.make( l1.getHeadConcProduction() ,tom_append_list_ConcProduction( l1.getTailConcProduction() ,l2)) ;     }   }   public static   tom.gom.adt.gom.types.ProductionList  tom_get_slice_ConcProduction( tom.gom.adt.gom.types.ProductionList  begin,  tom.gom.adt.gom.types.ProductionList  end, tom.gom.adt.gom.types.ProductionList  tail) {     if( (begin==end) ) {       return tail;     } else if( (end==tail)  && ( end.isEmptyConcProduction()  ||  (end== tom.gom.adt.gom.types.productionlist.EmptyConcProduction.make() ) )) {       /* code to avoid a call to make, and thus to avoid looping during list-matching */       return begin;     }     return  tom.gom.adt.gom.types.productionlist.ConsConcProduction.make( begin.getHeadConcProduction() ,( tom.gom.adt.gom.types.ProductionList )tom_get_slice_ConcProduction( begin.getTailConcProduction() ,end,tail)) ;   }      public static   tom.gom.adt.gom.types.FieldList  tom_append_list_ConcField( tom.gom.adt.gom.types.FieldList l1,  tom.gom.adt.gom.types.FieldList  l2) {     if( l1.isEmptyConcField() ) {       return l2;     } else if( l2.isEmptyConcField() ) {       return l1;     } else if(  l1.getTailConcField() .isEmptyConcField() ) {       return  tom.gom.adt.gom.types.fieldlist.ConsConcField.make( l1.getHeadConcField() ,l2) ;     } else {       return  tom.gom.adt.gom.types.fieldlist.ConsConcField.make( l1.getHeadConcField() ,tom_append_list_ConcField( l1.getTailConcField() ,l2)) ;     }   }   public static   tom.gom.adt.gom.types.FieldList  tom_get_slice_ConcField( tom.gom.adt.gom.types.FieldList  begin,  tom.gom.adt.gom.types.FieldList  end, tom.gom.adt.gom.types.FieldList  tail) {     if( (begin==end) ) {       return tail;     } else if( (end==tail)  && ( end.isEmptyConcField()  ||  (end== tom.gom.adt.gom.types.fieldlist.EmptyConcField.make() ) )) {       /* code to avoid a call to make, and thus to avoid looping during list-matching */       return begin;     }     return  tom.gom.adt.gom.types.fieldlist.ConsConcField.make( begin.getHeadConcField() ,( tom.gom.adt.gom.types.FieldList )tom_get_slice_ConcField( begin.getTailConcField() ,end,tail)) ;   }      public static   tom.gom.adt.gom.types.Option  tom_append_list_OptionList( tom.gom.adt.gom.types.Option  l1,  tom.gom.adt.gom.types.Option  l2) {     if( l1.isEmptyOptionList() ) {       return l2;     } else if( l2.isEmptyOptionList() ) {       return l1;     } else if( ((l1 instanceof tom.gom.adt.gom.types.option.ConsOptionList) || (l1 instanceof tom.gom.adt.gom.types.option.EmptyOptionList)) ) {       if( (( ((l1 instanceof tom.gom.adt.gom.types.option.ConsOptionList) || (l1 instanceof tom.gom.adt.gom.types.option.EmptyOptionList)) )? l1.getTailOptionList() : tom.gom.adt.gom.types.option.EmptyOptionList.make() ).isEmptyOptionList() ) {         return  tom.gom.adt.gom.types.option.ConsOptionList.make((( ((l1 instanceof tom.gom.adt.gom.types.option.ConsOptionList) || (l1 instanceof tom.gom.adt.gom.types.option.EmptyOptionList)) )? l1.getHeadOptionList() :l1),l2) ;       } else {         return  tom.gom.adt.gom.types.option.ConsOptionList.make((( ((l1 instanceof tom.gom.adt.gom.types.option.ConsOptionList) || (l1 instanceof tom.gom.adt.gom.types.option.EmptyOptionList)) )? l1.getHeadOptionList() :l1),tom_append_list_OptionList((( ((l1 instanceof tom.gom.adt.gom.types.option.ConsOptionList) || (l1 instanceof tom.gom.adt.gom.types.option.EmptyOptionList)) )? l1.getTailOptionList() : tom.gom.adt.gom.types.option.EmptyOptionList.make() ),l2)) ;       }     } else {       return  tom.gom.adt.gom.types.option.ConsOptionList.make(l1,l2) ;     }   }   public static   tom.gom.adt.gom.types.Option  tom_get_slice_OptionList( tom.gom.adt.gom.types.Option  begin,  tom.gom.adt.gom.types.Option  end, tom.gom.adt.gom.types.Option  tail) {     if( (begin==end) ) {       return tail;     } else if( (end==tail)  && ( end.isEmptyOptionList()  ||  (end== tom.gom.adt.gom.types.option.EmptyOptionList.make() ) )) {       /* code to avoid a call to make, and thus to avoid looping during list-matching */       return begin;     }     return  tom.gom.adt.gom.types.option.ConsOptionList.make((( ((begin instanceof tom.gom.adt.gom.types.option.ConsOptionList) || (begin instanceof tom.gom.adt.gom.types.option.EmptyOptionList)) )? begin.getHeadOptionList() :begin),( tom.gom.adt.gom.types.Option )tom_get_slice_OptionList((( ((begin instanceof tom.gom.adt.gom.types.option.ConsOptionList) || (begin instanceof tom.gom.adt.gom.types.option.EmptyOptionList)) )? begin.getTailOptionList() : tom.gom.adt.gom.types.option.EmptyOptionList.make() ),end,tail)) ;   }    /* Generated by TOM (version 2.6): Do not edit this file *//* Generated by TOM (version 2.6): Do not edit this file */ /* Generated by TOM (version 2.6): Do not edit this file */   private static java.util.ArrayList concArrayListAppend(Object o, java.util.ArrayList l) {   java.util.ArrayList res = (java.util.ArrayList)l.clone();   res.add(o);   return res; } /* Generated by TOM (version 2.6): Do not edit this file *//* Generated by TOM (version 2.6): Do not edit this file */   public static   tom.library.sl.Strategy  tom_append_list_Sequence( tom.library.sl.Strategy  l1,  tom.library.sl.Strategy  l2) {     if(( l1 == null )) {       return l2;     } else if(( l2 == null )) {       return l1;     } else if(( (l1 instanceof tom.library.sl.Sequence) )) {       if(( ((( (l1 instanceof tom.library.sl.Sequence) ))?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Sequence.THEN) ):( null )) == null )) {         return ( (l2==null)?((( (l1 instanceof tom.library.sl.Sequence) ))?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Sequence.FIRST) ):l1):new tom.library.sl.Sequence(((( (l1 instanceof tom.library.sl.Sequence) ))?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Sequence.FIRST) ):l1),l2) );       } else {         return ( (tom_append_list_Sequence(((( (l1 instanceof tom.library.sl.Sequence) ))?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Sequence.THEN) ):( null )),l2)==null)?((( (l1 instanceof tom.library.sl.Sequence) ))?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Sequence.FIRST) ):l1):new tom.library.sl.Sequence(((( (l1 instanceof tom.library.sl.Sequence) ))?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Sequence.FIRST) ):l1),tom_append_list_Sequence(((( (l1 instanceof tom.library.sl.Sequence) ))?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Sequence.THEN) ):( null )),l2)) );       }     } else {       return ( (l2==null)?l1:new tom.library.sl.Sequence(l1,l2) );     }   }   public static   tom.library.sl.Strategy  tom_get_slice_Sequence( tom.library.sl.Strategy  begin,  tom.library.sl.Strategy  end, tom.library.sl.Strategy  tail) {     if( (begin.equals(end)) ) {       return tail;     } else if( (end.equals(tail))  && (( end == null ) ||  (end.equals(( null ))) )) {       /* code to avoid a call to make, and thus to avoid looping during list-matching */       return begin;     }     return ( (( tom.library.sl.Strategy )tom_get_slice_Sequence(((( (begin instanceof tom.library.sl.Sequence) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Sequence.THEN) ):( null )),end,tail)==null)?((( (begin instanceof tom.library.sl.Sequence) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Sequence.FIRST) ):begin):new tom.library.sl.Sequence(((( (begin instanceof tom.library.sl.Sequence) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Sequence.FIRST) ):begin),( tom.library.sl.Strategy )tom_get_slice_Sequence(((( (begin instanceof tom.library.sl.Sequence) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Sequence.THEN) ):( null )),end,tail)) );   }      public static   tom.library.sl.Strategy  tom_append_list_Choice( tom.library.sl.Strategy  l1,  tom.library.sl.Strategy  l2) {     if(( l1 ==null )) {       return l2;     } else if(( l2 ==null )) {       return l1;     } else if(( (l1 instanceof tom.library.sl.Choice) )) {       if(( ((( (l1 instanceof tom.library.sl.Choice) ))?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Choice.THEN) ):( null )) ==null )) {         return ( (l2==null)?((( (l1 instanceof tom.library.sl.Choice) ))?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Choice.FIRST) ):l1):new tom.library.sl.Choice(((( (l1 instanceof tom.library.sl.Choice) ))?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Choice.FIRST) ):l1),l2) );       } else {         return ( (tom_append_list_Choice(((( (l1 instanceof tom.library.sl.Choice) ))?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Choice.THEN) ):( null )),l2)==null)?((( (l1 instanceof tom.library.sl.Choice) ))?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Choice.FIRST) ):l1):new tom.library.sl.Choice(((( (l1 instanceof tom.library.sl.Choice) ))?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Choice.FIRST) ):l1),tom_append_list_Choice(((( (l1 instanceof tom.library.sl.Choice) ))?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Choice.THEN) ):( null )),l2)) );       }     } else {       return ( (l2==null)?l1:new tom.library.sl.Choice(l1,l2) );     }   }   public static   tom.library.sl.Strategy  tom_get_slice_Choice( tom.library.sl.Strategy  begin,  tom.library.sl.Strategy  end, tom.library.sl.Strategy  tail) {     if( (begin.equals(end)) ) {       return tail;     } else if( (end.equals(tail))  && (( end ==null ) ||  (end.equals(( null ))) )) {       /* code to avoid a call to make, and thus to avoid looping during list-matching */       return begin;     }     return ( (( tom.library.sl.Strategy )tom_get_slice_Choice(((( (begin instanceof tom.library.sl.Choice) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Choice.THEN) ):( null )),end,tail)==null)?((( (begin instanceof tom.library.sl.Choice) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Choice.FIRST) ):begin):new tom.library.sl.Choice(((( (begin instanceof tom.library.sl.Choice) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Choice.FIRST) ):begin),( tom.library.sl.Strategy )tom_get_slice_Choice(((( (begin instanceof tom.library.sl.Choice) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Choice.THEN) ):( null )),end,tail)) );   }    /* Generated by TOM (version 2.6): Do not edit this file */ /* Generated by TOM (version 2.6): Do not edit this file */public static  tom.library.sl.Strategy  tom_make_TopDown( tom.library.sl.Strategy  v) { return ( ( new tom.library.sl.Mu(( new tom.library.sl.MuVar("_x") ),( (( (( null )==null)?( new tom.library.sl.All(( new tom.library.sl.MuVar("_x") )) ):new tom.library.sl.Sequence(( new tom.library.sl.All(( new tom.library.sl.MuVar("_x") )) ),( null )) )==null)?v:new tom.library.sl.Sequence(v,( (( null )==null)?( new tom.library.sl.All(( new tom.library.sl.MuVar("_x") )) ):new tom.library.sl.Sequence(( new tom.library.sl.All(( new tom.library.sl.MuVar("_x") )) ),( null )) )) )) ) );}public static  tom.library.sl.Strategy  tom_make_OnceTopDown( tom.library.sl.Strategy  v) { return ( ( new tom.library.sl.Mu(( new tom.library.sl.MuVar("_x") ),( (( (( null )==null)?( new tom.library.sl.One(( new tom.library.sl.MuVar("_x") )) ):new tom.library.sl.Choice(( new tom.library.sl.One(( new tom.library.sl.MuVar("_x") )) ),( null )) )==null)?v:new tom.library.sl.Choice(v,( (( null )==null)?( new tom.library.sl.One(( new tom.library.sl.MuVar("_x") )) ):new tom.library.sl.Choice(( new tom.library.sl.One(( new tom.library.sl.MuVar("_x") )) ),( null )) )) )) ) );}   





  private SymbolTable st = new SymbolTable();
  private static GomEnvironment env = GomEnvironment.getInstance();

  public GomModuleList expand(GomModuleList m, String pack) {
    try {
      ArrayList list = new ArrayList();
      GomModuleList res = (GomModuleList) 
        ( (( (( null )==null)?tom_make_TopDown(tom_make_UpdateSpecialization(list)):new tom.library.sl.Sequence(tom_make_TopDown(tom_make_UpdateSpecialization(list)),( null )) )==null)?tom_make_TopDown(tom_make_ExpandAtoms(list)):new tom.library.sl.Sequence(tom_make_TopDown(tom_make_ExpandAtoms(list)),( (( null )==null)?tom_make_TopDown(tom_make_UpdateSpecialization(list)):new tom.library.sl.Sequence(tom_make_TopDown(tom_make_UpdateSpecialization(list)),( null )) )) )

.visitLight(m);
      st.setPackage(pack);
      st.fill(res);
      //System.out.println(st);
      res = addRawSortsAndConstructors(res);
      res = addAtomHooks(res);
      res = addSortHooks(res);
      res = addRawSortHooks(res);
      res = addConstructorHooks(res);
      res = addRawConstructorHooks(res);
      res = addMappingHooks(res);
      return res;
    } catch (VisitFailure e) {
      throw new RuntimeException("should not happen");
    } catch (SymbolTable.SortException e) {
      e.printStackTrace();
      throw new RuntimeException("should not happen");
    } catch (SymbolTable.ConstructorException e) {
      e.printStackTrace();
      throw new RuntimeException("should not happen");
    }
  }
  

  /* -- export, convert and alpha maps argument lists -- */

  private String alphamapArgList(String sort) {
    StringBuffer buf = new StringBuffer();
    for(String a: st.getAccessibleAtoms(sort)) {
      String aid = st.getFullSortClassName(a);
      if(st.isPatternType(sort)) {
        if (st.getBoundAtoms(sort).contains(a)) {
          buf.append(",tom.library.freshgom.AlphaMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"OuterMap");
          buf.append(",tom.library.freshgom.AlphaMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"InnerMap");
        } else 
          buf.append(",tom.library.freshgom.AlphaMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
      } else {
        buf.append(",tom.library.freshgom.AlphaMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
      }
    }
    return buf.toString();
  }

  private String newAlphamapList(String sort) {
    StringBuffer buf = new StringBuffer();
    for(String a: st.getAccessibleAtoms(sort)) {
      String aid = st.getFullSortClassName(a);
      buf.append(",new tom.library.freshgom.AlphaMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+">()");
      if(st.isPatternType(sort) && st.getBoundAtoms(sort).contains(a)) 
        buf.append(",new tom.library.freshgom.AlphaMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+">()");
    }
    return buf.toString();
  }

  private String exportmapArgList(String sort) {
    StringBuffer buf = new StringBuffer();
    boolean first = true; 
    for(String a: st.getAccessibleAtoms(sort)) {
      if(!first) buf.append(", ");
      else first = false;
      String aid = st.getFullSortClassName(a);
      if(st.isPatternType(sort)) {
        if (st.getBoundAtoms(sort).contains(a)) {
          buf.append("tom.library.freshgom.ExportMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"OuterMap");
          buf.append(",tom.library.freshgom.ExportMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"InnerMap");
        } else 
          buf.append("tom.library.freshgom.ExportMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
      } else {
        buf.append("tom.library.freshgom.ExportMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
      }
    }
    return buf.toString();
  }

  private String newExportmapList(String sort) {
    StringBuffer buf = new StringBuffer();
    boolean first = true; 
    for(String a: st.getAccessibleAtoms(sort)) {
      if(!first) buf.append(", ");
      else first = false;
      String aid = st.getFullSortClassName(a);
      buf.append("new tom.library.freshgom.ExportMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+">()");
      if(st.isPatternType(sort) && st.getBoundAtoms(sort).contains(a)) 
        buf.append(",new tom.library.freshgom.ExportMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+">()");
    }
    return buf.toString();
  }

  private String convertmapArgList(String sort) {
    StringBuffer buf = new StringBuffer();
    boolean first = true; 
    for(String a: st.getAccessibleAtoms(sort)) {
      if(!first) buf.append(", ");
      else first = false;
      String aid = st.getFullSortClassName(a);
      if(st.isPatternType(sort)) {
        if (st.getBoundAtoms(sort).contains(a)) {
          buf.append("tom.library.freshgom.ConvertMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"OuterMap");
          buf.append(",tom.library.freshgom.ConvertMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"InnerMap");
        } else 
          buf.append("tom.library.freshgom.ConvertMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
      } else {
        buf.append("tom.library.freshgom.ConvertMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
      }
    }
    return buf.toString();
  }

  private String newConvertmapList(String sort) {
    StringBuffer buf = new StringBuffer();
    boolean first = true; 
    for(String a: st.getAccessibleAtoms(sort)) {
      if(!first) buf.append(", ");
      else first = false;
      String aid = st.getFullSortClassName(a);
      buf.append("new tom.library.freshgom.ConvertMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+">()");
      if(st.isPatternType(sort) && st.getBoundAtoms(sort).contains(a)) 
        buf.append(",new tom.library.freshgom.ConvertMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+">()");
    }
    return buf.toString();
  }

  /* call to expression field inside expression type */
  private String alphaRecCall1(String sort) {
    StringBuffer buf = new StringBuffer();
    for(String a: st.getAccessibleAtoms(sort)) {
      buf.append(","/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
    }
    return buf.toString();
  }

  /* call to pattern field inside expression type */
  private String alphaRecCall2(String sort) {
    StringBuffer buf = new StringBuffer();
    for(String a: st.getAccessibleAtoms(sort)) {
      buf.append(","/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
      if(st.getBoundAtoms(sort).contains(a))
        buf.append(","/* Generated by TOM (version 2.6): Do not edit this file */+a+"InnerMap");
    }
    return buf.toString();
  }

  /* call to inner field inside pattern type */
  private String alphaRecCall3(String tosort, String fromsort) {
    StringBuffer buf = new StringBuffer();
    for(String a: st.getAccessibleAtoms(tosort)) {
      if(st.getBoundAtoms(fromsort).contains(a)) 
        buf.append(","/* Generated by TOM (version 2.6): Do not edit this file */+a+"InnerMap");
      else
        buf.append(","/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
    }
    return buf.toString();
  }

  /* call to outer field inside pattern type */
  private String alphaRecCall4(String tosort, String fromsort) {
    StringBuffer buf = new StringBuffer();
    for(String a: st.getAccessibleAtoms(tosort)) {
      if(st.getBoundAtoms(fromsort).contains(a)) 
        buf.append(","/* Generated by TOM (version 2.6): Do not edit this file */+a+"OuterMap");
      else
        buf.append(","/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
    }
    return buf.toString();
  }

  /* call to neutral field inside pattern type */
  private String alphaRecCall5(String sort) {
    StringBuffer buf = new StringBuffer();
    for(String a: st.getAccessibleAtoms(sort)) {
      buf.append(","/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
    }
    return buf.toString();
  }

  /* call to pattern field inside pattern type */
  private String alphaRecCall6(String tosort) {
    StringBuffer buf = new StringBuffer();
    for(String a: st.getAccessibleAtoms(tosort)) {
      // bound atoms have to be the same
      if(st.getBoundAtoms(tosort).contains(a)) {
        buf.append(","/* Generated by TOM (version 2.6): Do not edit this file */+a+"OuterMap");
        buf.append(","/* Generated by TOM (version 2.6): Do not edit this file */+a+"InnerMap");
      } else buf.append(","/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
    }
    return buf.toString();
  }



  /* call to expression field inside expression type */
  private String recCall1(String sort) {
    StringBuffer buf = new StringBuffer();
    boolean first = true;
    for(String a: st.getAccessibleAtoms(sort)) {
      if(!first) buf.append(",");
      else first = false;
      buf.append(""/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
    }
    return buf.toString();
  }

  /* call to pattern field inside expression type */
  private String recCall2(String sort) {
    StringBuffer buf = new StringBuffer();
    boolean first = true;
    for(String a: st.getAccessibleAtoms(sort)) {
      if(!first) buf.append(",");
      else first = false;
      buf.append(""/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
      if(st.getBoundAtoms(sort).contains(a))
        buf.append(","/* Generated by TOM (version 2.6): Do not edit this file */+a+"InnerMap");
    }
    return buf.toString();
  }

  /* call to inner field inside pattern type */
  private String recCall3(String tosort, String fromsort) {
    StringBuffer buf = new StringBuffer();
    boolean first = true;
    for(String a: st.getAccessibleAtoms(tosort)) {
      if(!first) buf.append(",");
      else first = false;
      if(st.getBoundAtoms(fromsort).contains(a)) 
        buf.append(""/* Generated by TOM (version 2.6): Do not edit this file */+a+"InnerMap");
      else
        buf.append(""/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
    }
    return buf.toString();
  }

  /* call to outer field inside pattern type */
  private String recCall4(String tosort, String fromsort) {
    StringBuffer buf = new StringBuffer();
    boolean first = true;
    for(String a: st.getAccessibleAtoms(tosort)) {
      if(!first) buf.append(",");
      else first = false;
      if(st.getBoundAtoms(fromsort).contains(a)) 
        buf.append(""/* Generated by TOM (version 2.6): Do not edit this file */+a+"OuterMap");
      else
        buf.append(""/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
    }
    return buf.toString();
  }

  /* call to neutral field inside pattern type */
  private String recCall5(String sort) {
    StringBuffer buf = new StringBuffer();
    boolean first = true;
    for(String a: st.getAccessibleAtoms(sort)) {
      if(!first) buf.append(",");
      else first = false;
      buf.append(""/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
    }
    return buf.toString();
  }

  /* call to pattern field inside pattern type */
  private String recCall6(String tosort) {
    StringBuffer buf = new StringBuffer();
    boolean first = true;
    for(String a: st.getAccessibleAtoms(tosort)) {
      if(!first) buf.append(",");
      else first = false;
      // bound atoms have to be the same
      if(st.getBoundAtoms(tosort).contains(a)) {
        buf.append(""/* Generated by TOM (version 2.6): Do not edit this file */+a+"OuterMap");
        buf.append(","/* Generated by TOM (version 2.6): Do not edit this file */+a+"InnerMap");
      } else buf.append(""/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
    }
    return buf.toString();
  }

  /* hashTables for 'refresh' methods" */
  private String hashtableArgList(String sort) {
    StringBuffer buf = new StringBuffer();
    boolean first = true;
    for(String a: st.getBoundAtoms(sort)) {
      if(!first) buf.append(", ");
      else first = false;
      String aid = st.getFullSortClassName(a);
      buf.append( "java.util.Hashtable<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+","/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map" );
    }
    return buf.toString();
  }

  /* hashTables for 'refresh' methods" */
  private String newHashtableList(String sort) {
    StringBuffer buf = new StringBuffer();
    boolean first = true;
    for(String a: st.getBoundAtoms(sort)) {
      if(!first) buf.append(", ");
      else first = false;
      String aid = st.getFullSortClassName(a);
      buf.append("new java.util.Hashtable<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+","/* Generated by TOM (version 2.6): Do not edit this file */+aid+">()");
    }
    return buf.toString();
  }

  /* generates "A1Map,A2Map,...,AnMap" */
  private String hashtableRecursiveCall(String sort) {
    StringBuffer buf = new StringBuffer();
    boolean first = true;
    for(String a: st.getBoundAtoms(sort)) {
      if(!first) buf.append(", ");
      else first = false;
      buf.append(""/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map");
    }
    return buf.toString();
  }

  /* generates "raw_f1,raw_f2,...,raw_fn" for fields of cons
   except for builtins where no new is added */
  private String rawArgList(String cons) {
    String sort = st.getSort(cons);
    StringBuffer buf = new StringBuffer();
    boolean first = true;
    for(String f: st.getFields(cons)) {
      if(!first) buf.append(",");
      else first = false;
      buf.append(env.isBuiltin(st.getSort(cons,f))? "get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"()":"raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+"");
    }
    return buf.toString();
  }

  /* generates "f1,f2,...,fn" for fields of cons
   except for builtins where no new is added */
  private String convertArgList(String cons) {
    String sort = st.getSort(cons);
    StringBuffer buf = new StringBuffer();
    boolean first = true;
    for(String f: st.getFields(cons)) {
      if(!first) buf.append(",");
      else first = false;
      buf.append(env.isBuiltin(st.getSort(cons,f))? st.rawGetter(cons,f) :f);
    }
    return buf.toString();
  }


  /* -- hooks utilities -- */

  public static class AddHook extends tom.library.sl.BasicStrategy {private  String  sort;private  tom.gom.adt.gom.types.Production  hook;public AddHook( String  sort,  tom.gom.adt.gom.types.Production  hook) {super(( new tom.library.sl.Fail() ));this.sort=sort;this.hook=hook;}public  String  getsort() {return sort;}public  tom.gom.adt.gom.types.Production  gethook() {return hook;}public tom.library.sl.Visitable[] getChildren() {tom.library.sl.Visitable[] stratChilds = new tom.library.sl.Visitable[getChildCount()];stratChilds[0] = super.getChildAt(0);return stratChilds;}public tom.library.sl.Visitable setChildren(tom.library.sl.Visitable[] children) {super.setChildAt(0, children[0]);return this;}public int getChildCount() {return 1;}public tom.library.sl.Visitable getChildAt(int index) {switch (index) {case 0: return super.getChildAt(0);default: throw new IndexOutOfBoundsException();}}public tom.library.sl.Visitable setChildAt(int index, tom.library.sl.Visitable child) {switch (index) {case 0: return super.setChildAt(0, child);default: throw new IndexOutOfBoundsException();}}public  tom.gom.adt.gom.types.ProductionList  visit_ProductionList( tom.gom.adt.gom.types.ProductionList  tom__arg, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {{{if ( (tom__arg instanceof tom.gom.adt.gom.types.ProductionList) ) {if ( (((( tom.gom.adt.gom.types.ProductionList )tom__arg) instanceof tom.gom.adt.gom.types.productionlist.ConsConcProduction) || ((( tom.gom.adt.gom.types.ProductionList )tom__arg) instanceof tom.gom.adt.gom.types.productionlist.EmptyConcProduction)) ) {if (!( (( tom.gom.adt.gom.types.ProductionList )tom__arg).isEmptyConcProduction() )) { tom.gom.adt.gom.types.Production  tomMatch494NameNumber_freshVar_5= (( tom.gom.adt.gom.types.ProductionList )tom__arg).getHeadConcProduction() ;if ( (tomMatch494NameNumber_freshVar_5 instanceof tom.gom.adt.gom.types.production.SortType) ) { tom.gom.adt.gom.types.GomType  tomMatch494NameNumber_freshVar_4= tomMatch494NameNumber_freshVar_5.getType() ;if ( (tomMatch494NameNumber_freshVar_4 instanceof tom.gom.adt.gom.types.gomtype.GomType) ) {


        if( tomMatch494NameNumber_freshVar_4.getName() .equals(sort)) 
          return  tom.gom.adt.gom.types.productionlist.ConsConcProduction.make( (( tom.gom.adt.gom.types.ProductionList )tom__arg).getHeadConcProduction() , tom.gom.adt.gom.types.productionlist.ConsConcProduction.make(hook,tom_append_list_ConcProduction( (( tom.gom.adt.gom.types.ProductionList )tom__arg).getTailConcProduction() , tom.gom.adt.gom.types.productionlist.EmptyConcProduction.make() )) ) ;
      }}}}}}}return _visit_ProductionList(tom__arg,introspector); }public  tom.gom.adt.gom.types.ProductionList  _visit_ProductionList( tom.gom.adt.gom.types.ProductionList  arg, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {if (!((environment ==  null ))) {return (( tom.gom.adt.gom.types.ProductionList )any.visit(environment,introspector));} else {return (( tom.gom.adt.gom.types.ProductionList )any.visitLight(arg,introspector));} }public Object visitLight(Object v, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {if ( (v instanceof tom.gom.adt.gom.types.ProductionList) ) {return visit_ProductionList((( tom.gom.adt.gom.types.ProductionList )v),introspector);}if (!((environment ==  null ))) {return any.visit(environment,introspector);} else {return any.visitLight(v,introspector);} }}public static  tom.library.sl.Strategy  tom_make_AddHook( String  t0,  tom.gom.adt.gom.types.Production  t1) { return new AddHook(t0,t1);}



  /* add the hook next to sort declaration */
  private static GomModuleList addSortBlockHook
    (GomModuleList ml, String sort, String code) {
      Production hook = 
         tom.gom.adt.gom.types.production.Hook.make( tom.gom.adt.gom.types.idkind.KindSort.make() , sort,  tom.gom.adt.gom.types.hookkind.HookKind.make("block") ,  tom.gom.adt.gom.types.arglist.EmptyConcArg.make() , code,  tom.gom.adt.gom.types.option.EmptyOptionList.make() ) 
;
      try { 
        return (GomModuleList)
          tom_make_OnceTopDown(tom_make_AddHook(sort,hook)).visitLight(ml); 
      }
      catch (VisitFailure e) { 
        throw new RuntimeException("Should never happen"); 
      }
    }

  /* add the hook next to the declaration of the constructor's sort */
  private GomModuleList addConstructorBlockHook
    (GomModuleList ml, String cons, String code) {
      String sort = st.getSort(cons);

      IdKind kind =  tom.gom.adt.gom.types.idkind.KindOperator.make() ;
      // if the constructor is a generated cons or nil, add a 'future' hook
      if(st.isGeneratedCons(cons)) { 
        kind =  tom.gom.adt.gom.types.idkind.KindFutureOperator.make( tom.gom.adt.gom.types.future.FutureCons.make() ) ;
        cons = st.getBaseName(cons);
      } else if (st.isGeneratedNil(cons)) { 
        kind =  tom.gom.adt.gom.types.idkind.KindFutureOperator.make( tom.gom.adt.gom.types.future.FutureNil.make() ) ;
        cons = st.getBaseName(cons);
      }

      Production hook =  tom.gom.adt.gom.types.production.Hook.make(kind, cons,  tom.gom.adt.gom.types.hookkind.HookKind.make("block") ,  tom.gom.adt.gom.types.arglist.EmptyConcArg.make() , code,  tom.gom.adt.gom.types.option.EmptyOptionList.make() ) 
;
      try { 
        return (GomModuleList)
          tom_make_OnceTopDown(tom_make_AddHook(sort,hook)).visitLight(ml); 
      } catch (VisitFailure e) { 
        throw new RuntimeException("Should never happen"); 
      }
    }

  /* add the hook next to the declaration of the constructor's sort */
  private GomModuleList addRawConstructorBlockHook
    (GomModuleList ml, String cons, String code) {
      String sort = st.getSort(cons);

      IdKind kind =  tom.gom.adt.gom.types.idkind.KindOperator.make() ;
      // if the constructor is a generated cons or nil, add a 'future' hook
      if(st.isGeneratedCons(cons)) { 
        kind =  tom.gom.adt.gom.types.idkind.KindFutureOperator.make( tom.gom.adt.gom.types.future.FutureCons.make() ) ;
        cons = st.getBaseName(cons);
      } else if (st.isGeneratedNil(cons)) { 
        kind =  tom.gom.adt.gom.types.idkind.KindFutureOperator.make( tom.gom.adt.gom.types.future.FutureNil.make() ) ;
        cons = st.getBaseName(cons);
      }

      Production hook = 
         tom.gom.adt.gom.types.production.Hook.make(kind, st.rawCons(cons),  tom.gom.adt.gom.types.hookkind.HookKind.make("block") ,  tom.gom.adt.gom.types.arglist.EmptyConcArg.make() , code,  tom.gom.adt.gom.types.option.EmptyOptionList.make() ) 
;
      try { 
        return (GomModuleList)
          tom_make_OnceTopDown(tom_make_AddHook(st.rawCons(sort),hook)).visitLight(ml); 
      }
      catch (VisitFailure e) { 
        throw new RuntimeException("Should never happen"); 
      }
    }

  /* add the hook next to the sort declaration */
  private GomModuleList addSortInterfaceHook
    (GomModuleList ml, String sort, String code) {
      Production hook = 
         tom.gom.adt.gom.types.production.Hook.make( tom.gom.adt.gom.types.idkind.KindSort.make() , sort,  tom.gom.adt.gom.types.hookkind.HookKind.make("interface") ,  tom.gom.adt.gom.types.arglist.EmptyConcArg.make() , code,  tom.gom.adt.gom.types.option.EmptyOptionList.make() ) 
;
      try { 
        return (GomModuleList)
          tom_make_OnceTopDown(tom_make_AddHook(sort,hook)).visitLight(ml); 
      }
      catch (VisitFailure e) { 
        throw new RuntimeException("Should never happen"); 
      }
    }

  /* add the hook next to the declaration of the constructor's sort */
  private GomModuleList addConstructorMappingHook
    (GomModuleList ml, String cons, String code) {
      String sort = st.getSort(cons);

      IdKind kind =  tom.gom.adt.gom.types.idkind.KindOperator.make() ;
      // if the constructor is a generated cons or nil, add a 'future' hook
      if(st.isGeneratedCons(cons)) { 
        kind =  tom.gom.adt.gom.types.idkind.KindFutureOperator.make( tom.gom.adt.gom.types.future.FutureCons.make() ) ;
        cons = st.getBaseName(cons);
      } else if (st.isGeneratedNil(cons)) { 
        kind =  tom.gom.adt.gom.types.idkind.KindFutureOperator.make( tom.gom.adt.gom.types.future.FutureNil.make() ) ;
        cons = st.getBaseName(cons);
      }

      Production hook =  tom.gom.adt.gom.types.production.Hook.make(kind, cons,  tom.gom.adt.gom.types.hookkind.HookKind.make("mapping") ,  tom.gom.adt.gom.types.arglist.EmptyConcArg.make() , code,  tom.gom.adt.gom.types.option.EmptyOptionList.make() ) 
;
      try { 
        return (GomModuleList)
          tom_make_OnceTopDown(tom_make_AddHook(sort,hook)).visitLight(ml); 
      } catch (VisitFailure e) { 
        throw new RuntimeException("Should never happen"); 
      }
    }

  /* -- sort hooks -- */

  private GomModuleList addSortHooks(GomModuleList ml) {
    for(String s: st.getSorts()) 
      if(st.isExpressionType(s) || st.isPatternType(s))
        ml = addSortBlockHook(ml,s,sortBlockHookString(s));
    return ml;
  }


  private String sortBlockHookString(String sort) {
    String alphamapargs = alphamapArgList(sort);
    String newalphamaps = newAlphamapList(sort);
    String exportmapargs = exportmapArgList(sort);
    String newexportmaps = newExportmapList(sort);
    String rawsortid = st.qualifiedRawSortId(sort);
    String sortid = st.getFullSortClassName(sort);

    String res = "{";

    for(String a: st.getAccessibleAtoms(sort)) {
      String aid = st.getFullSortClassName(a);
      res += " \n        public abstract "/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" \n          rename"/* Generated by TOM (version 2.6): Do not edit this file */+a+"(java.util.Hashtable<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+","/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> map); \n      "


;
    }

    res += "\n     /**\n      * alpha equivalence \n      */\n      public boolean equals("/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" o) {\n        try { \n          alpha(o "/* Generated by TOM (version 2.6): Do not edit this file */+newalphamaps+"); \n          return true;\n        } catch (tom.library.freshgom.AlphaMap.AlphaException e) {\n          return false;\n        }\n      }\n\n      public abstract void alpha ("/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" o "/* Generated by TOM (version 2.6): Do not edit this file */+alphamapargs+")\n        throws tom.library.freshgom.AlphaMap.AlphaException;\n\n     /**\n      * exportation (term -> raw term) \n      */\n      public "/* Generated by TOM (version 2.6): Do not edit this file */+rawsortid+" export() {\n        return _export("/* Generated by TOM (version 2.6): Do not edit this file */+newexportmaps+");\n      }\n\n      public abstract "/* Generated by TOM (version 2.6): Do not edit this file */+rawsortid+" _export("/* Generated by TOM (version 2.6): Do not edit this file */+exportmapargs+");\n    "























;

    if(st.isPatternType(sort)) {
      String newhashtables = newHashtableList(sort);
      String hashtableargs = hashtableArgList(sort);
      res += " \n        public "/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" refresh() {\n          return _refresh("/* Generated by TOM (version 2.6): Do not edit this file */+newhashtables+");\n        }\n\n        public abstract "/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" _refresh("/* Generated by TOM (version 2.6): Do not edit this file */+hashtableargs+"); \n      "





;

      for(String a: st.getBoundAtoms(sort)) {
        String aid = st.getFullSortClassName(a);
        res += "\n          public java.util.Set<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> getBound"/* Generated by TOM (version 2.6): Do not edit this file */+a+"() {\n            java.util.HashSet<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> res = new java.util.HashSet<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+">();\n            getBound"/* Generated by TOM (version 2.6): Do not edit this file */+a+"(res);\n            return res;\n          }\n\n          public abstract void getBound"/* Generated by TOM (version 2.6): Do not edit this file */+a+"(java.util.Set<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> atoms); \n\n          public abstract void getBound"/* Generated by TOM (version 2.6): Do not edit this file */+a+"2(\n              "/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" o, tom.library.freshgom.AlphaMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> m)\n              throws tom.library.freshgom.AlphaMap.AlphaException;\n \n        "












;
      }
    }

    return res + "}";
  }

  /* -- raw sort hooks -- */

  private GomModuleList addRawSortHooks(GomModuleList ml) {
    for(String s: st.getSorts()) 
      if(st.isExpressionType(s) || st.isPatternType(s))
        ml = addSortBlockHook(ml,st.rawSort(s),rawSortBlockHookString(s));
    return ml;
  }


  private String rawSortBlockHookString(String sort) {
    String convertmapargs = convertmapArgList(sort);
    String newconvertmaps = newConvertmapList(sort);
    String sortid = st.getFullSortClassName(sort);

    String res = "{\n     /**\n      * importation (raw term -> term) \n      */\n      public "/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" convert() {\n        return _convert("/* Generated by TOM (version 2.6): Do not edit this file */+newconvertmaps+");\n      }\n\n      public abstract "/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" _convert("/* Generated by TOM (version 2.6): Do not edit this file */+convertmapargs+");\n    "








;

    if(st.isPatternType(sort)) {
      for(String a: st.getBoundAtoms(sort)) {
        String aid = st.getFullSortClassName(a);
        res += "\n          public tom.library.freshgom.ConvertMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> getBound"/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map() {\n            tom.library.freshgom.ConvertMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> res = \n              new tom.library.freshgom.ConvertMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+">();\n            getBound"/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map(res);\n            return res;\n          }\n\n          public abstract void \n            getBound"/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map(tom.library.freshgom.ConvertMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> m);\n        "









;
      }
    }
    return res + "}";
  }

  /* -- non variadic constructor hooks -- */

  private GomModuleList addConstructorHooks(GomModuleList ml) {
    for(String s: st.getSorts()) 
      if(st.isExpressionType(s) || st.isPatternType(s))
        for(String c: st.getConstructors(s))
          if(! st.isVariadic(c))
            ml = addConstructorBlockHook(ml,c,constructorBlockHookString(c));
    return ml;
  }

  private String renameRecursiveCalls(String c, String atomSort) {
    String sortid = st.getFullSortClassName(st.getSort(c));
    String res = ""/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" res = this;"; 
    String atomSortId = st.getFullSortClassName(atomSort);
    for(String f: st.getFields(c)) {
      String fsort = st.getSort(c,f);
      if (env.isBuiltin(fsort)) continue;
      if (st.isAtomType(fsort)) {
        if (fsort.equals(atomSort))
          res += " \n            "/* Generated by TOM (version 2.6): Do not edit this file */+atomSortId+" n_"/* Generated by TOM (version 2.6): Do not edit this file */+f+" = map.get(get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"());\n        if (n_"/* Generated by TOM (version 2.6): Do not edit this file */+f+" != null) res = res.set"/* Generated by TOM (version 2.6): Do not edit this file */+f+"(n_"/* Generated by TOM (version 2.6): Do not edit this file */+f+"); \n        "


;
      } else {
        if (!st.getAccessibleAtoms(fsort).contains(atomSort)) continue;
        res += " res = res.set"/* Generated by TOM (version 2.6): Do not edit this file */+f+"(get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"().rename"/* Generated by TOM (version 2.6): Do not edit this file */+atomSort+"(map)); ";
      }
    }
    return res + "return res;";
  }

  private String refreshRecursiveCalls(String c) {
    String sort = st.getSort(c);
    String sortid = st.getFullSortClassName(sort);
    String res = ""/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" res = this;"; 
    for(String f: st.getPatternFields(c)) {
      String fsort = st.getSort(c,f);
      if (env.isBuiltin(fsort)) continue;
      if (st.isAtomType(fsort)) {
        String fsortid = st.getFullSortClassName(fsort);
        res += "\n          "/* Generated by TOM (version 2.6): Do not edit this file */+fsortid+" "/* Generated by TOM (version 2.6): Do not edit this file */+f+" = get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"();\n          if ("/* Generated by TOM (version 2.6): Do not edit this file */+fsort+"Map.containsKey("/* Generated by TOM (version 2.6): Do not edit this file */+f+"))\n            res = res.set"/* Generated by TOM (version 2.6): Do not edit this file */+f+"("/* Generated by TOM (version 2.6): Do not edit this file */+fsort+"Map.get("/* Generated by TOM (version 2.6): Do not edit this file */+f+"));\n          else {\n            "/* Generated by TOM (version 2.6): Do not edit this file */+fsortid+" fresh_"/* Generated by TOM (version 2.6): Do not edit this file */+f+" = "/* Generated by TOM (version 2.6): Do not edit this file */+fsortid+".fresh"/* Generated by TOM (version 2.6): Do not edit this file */+fsort+"("/* Generated by TOM (version 2.6): Do not edit this file */+f+");\n            "/* Generated by TOM (version 2.6): Do not edit this file */+fsort+"Map.put("/* Generated by TOM (version 2.6): Do not edit this file */+f+",fresh_"/* Generated by TOM (version 2.6): Do not edit this file */+f+");\n            res = res.set"/* Generated by TOM (version 2.6): Do not edit this file */+f+"(fresh_"/* Generated by TOM (version 2.6): Do not edit this file */+f+");\n          }\n        "








;
      } else {
        String arglist = hashtableRecursiveCall(sort); 
        res += "res = res.set"/* Generated by TOM (version 2.6): Do not edit this file */+f+"(get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"()._refresh("/* Generated by TOM (version 2.6): Do not edit this file */+arglist+"));";
      }
    }
    for(String f: st.getInnerFields(c)) {
      String fsort = st.getSort(c,f);
      if (env.isBuiltin(fsort)) continue;
      for(String a: st.getBoundAtoms(sort)) {
        if (st.getAccessibleAtoms(fsort).contains(a))
          res += "res = res.set"/* Generated by TOM (version 2.6): Do not edit this file */+f+"(res.get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"().rename"/* Generated by TOM (version 2.6): Do not edit this file */+a+"("/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map));";
      }
    }
    return res + "return res;";
  }

  private String alphaRecursiveCalls(String c) {
    String sort = st.getSort(c);
    String sortid = st.getFullSortClassName(sort);
    String res = ""; 
    /* if c is a constructor in expression position
       the args are of the form atomsort1Map, atomsort2Map .. */
    if(st.isExpressionType(sort)) {
      for(String f: st.getFields(c)) {
        String fsort = st.getSort(c,f);
        if (env.isBuiltin(fsort)) {
          res += "\n            if (get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"() != o.get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"()) \n              throw new tom.library.freshgom.AlphaMap.AlphaException();\n           "


;
        } else {
          String fsortid = st.getFullSortClassName(fsort);
          String rawfsortid = st.qualifiedRawSortId(fsort);
          if (st.isAtomType(fsort)) {
            res += "\n              if (!"/* Generated by TOM (version 2.6): Do not edit this file */+fsort+"Map.equal(get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"(),o.get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"()))\n                throw new tom.library.freshgom.AlphaMap.AlphaException();\n            "


;
          } else if (st.isExpressionType(fsort)) {
            res += "get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"().alpha(o.get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"() "/* Generated by TOM (version 2.6): Do not edit this file */+alphaRecCall1(fsort)+");";
          } else if (st.isPatternType(fsort)) {
            res += "\n              { /* to limit declared variables scope */\n              "/* Generated by TOM (version 2.6): Do not edit this file */+fsortid+" "/* Generated by TOM (version 2.6): Do not edit this file */+f+" = get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"();;\n              "/* Generated by TOM (version 2.6): Do not edit this file */+fsortid+" o_"/* Generated by TOM (version 2.6): Do not edit this file */+f+" = o.get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"();\n            "



;
            for(String a: st.getBoundAtoms(fsort)) {
              String aid = st.getFullSortClassName(a);
              res += "\n                tom.library.freshgom.AlphaMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+f+"_bound"/* Generated by TOM (version 2.6): Do not edit this file */+a+"\n                  = new tom.library.freshgom.AlphaMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+">();\n                "/* Generated by TOM (version 2.6): Do not edit this file */+f+".getBound"/* Generated by TOM (version 2.6): Do not edit this file */+a+"2(o_"/* Generated by TOM (version 2.6): Do not edit this file */+f+", "/* Generated by TOM (version 2.6): Do not edit this file */+f+"_bound"/* Generated by TOM (version 2.6): Do not edit this file */+a+");\n                tom.library.freshgom.AlphaMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"InnerMap \n                  = "/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map.combine("/* Generated by TOM (version 2.6): Do not edit this file */+f+"_bound"/* Generated by TOM (version 2.6): Do not edit this file */+a+");\n              "





;
            }
            res += ""/* Generated by TOM (version 2.6): Do not edit this file */+f+".alpha(o.get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"() "/* Generated by TOM (version 2.6): Do not edit this file */+alphaRecCall2(fsort)+");";
            res += "}";
          }
        }
      }
    /* if c is a constructor in pattern position --
       the args are of the form 
        as1OuterMap, as1InnerMap, as2Map, as3OuterMap, as3InnerMap .. */
    } else if(st.isPatternType(sort)) {
      for(String f: st.getFields(c)) {
        String fsort = st.getSort(c,f);
        if (env.isBuiltin(fsort)) {
          res += "\n            if (get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"() != o.get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"()) \n              throw new tom.library.freshgom.AlphaMap.AlphaException();\n          "


;
        } else {
          String fsortid = st.getFullSortClassName(fsort);
          String rawfsortid = st.qualifiedRawSortId(fsort);
          if (st.isAtomType(fsort)) {
            if (st.isBound(c,f)) 
              res += "\n                if (!"/* Generated by TOM (version 2.6): Do not edit this file */+fsort+"InnerMap.equal(get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"(),o.get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"()))\n                  throw new tom.library.freshgom.AlphaMap.AlphaException();\n            "


;
                else
                  res += "\n                    if (!"/* Generated by TOM (version 2.6): Do not edit this file */+fsort+"Map.equal(get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"(),o.get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"()))\n                      throw new tom.library.freshgom.AlphaMap.AlphaException();\n            "


;
          } else if (st.isInner(c,f)) /* must be expression type */ {
            res += "get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"().alpha(o.get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"() "/* Generated by TOM (version 2.6): Do not edit this file */+alphaRecCall3(fsort,sort)+");";
          } else if (st.isOuter(c,f)) /* must be expression type */ {
            res += "get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"().alpha(o.get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"() "/* Generated by TOM (version 2.6): Do not edit this file */+alphaRecCall4(fsort,sort)+");";
          } else if (st.isNeutral(c,f)) /* must be expression type */ {
            res += "get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"().alpha(o.get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"() "/* Generated by TOM (version 2.6): Do not edit this file */+alphaRecCall5(fsort)+");";
          } else /* must be pattern type */ {
            res += "get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"().alpha(o.get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"() "/* Generated by TOM (version 2.6): Do not edit this file */+alphaRecCall6(fsort)+");";
          }
        }
      }
    }
    return res;
  }

  private String exportRecursiveCalls(String c) {
    String sort = st.getSort(c);
    String sortid = st.getFullSortClassName(sort);
    String res = ""; 
    /* if c is a constructor in expression position
       the args are of the form atomsort1Map, atomsort2Map .. */
    if(st.isExpressionType(sort)) {
      for(String f: st.getFields(c)) {
        String fsort = st.getSort(c,f);
        if (env.isBuiltin(fsort)) continue;
        String fsortid = st.getFullSortClassName(fsort);
        String rawfsortid = st.qualifiedRawSortId(fsort);
        if (st.isAtomType(fsort)) {
          res += "String raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+" = "/* Generated by TOM (version 2.6): Do not edit this file */+fsort+"Map.get(get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"());";
        } else if (st.isExpressionType(fsort)) {
          res += ""/* Generated by TOM (version 2.6): Do not edit this file */+rawfsortid+" raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+" \n            = get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"()._export("/* Generated by TOM (version 2.6): Do not edit this file */+recCall1(fsort)+");"
;
        } else if (st.isPatternType(fsort)) {
          res += "\n            /* declaration before scoping */\n            "/* Generated by TOM (version 2.6): Do not edit this file */+rawfsortid+" raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+" = null; "

;
          res += "{ /* to limit declared variables scope */";
          res += ""/* Generated by TOM (version 2.6): Do not edit this file */+fsortid+" "/* Generated by TOM (version 2.6): Do not edit this file */+f+" = get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"();";
          for(String a: st.getBoundAtoms(fsort)) {
            String aid = st.getFullSortClassName(a);
            res += "\n              java.util.Set<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+f+"_bound"/* Generated by TOM (version 2.6): Do not edit this file */+a+" = "/* Generated by TOM (version 2.6): Do not edit this file */+f+".getBound"/* Generated by TOM (version 2.6): Do not edit this file */+a+"();\n              tom.library.freshgom.ExportMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"InnerMap \n                = "/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map.addSet("/* Generated by TOM (version 2.6): Do not edit this file */+f+"_bound"/* Generated by TOM (version 2.6): Do not edit this file */+a+");\n            "



;
          }
          res += "raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+" = "/* Generated by TOM (version 2.6): Do not edit this file */+f+"._export("/* Generated by TOM (version 2.6): Do not edit this file */+recCall2(fsort)+");";
          res += "}";
        }
      }
    /* if c is a constructor in pattern position --
       the args are of the form 
        as1OuterMap, as1InnerMap, as2Map, as3OuterMap, as3InnerMap .. */
    } else if(st.isPatternType(sort)) {
      for(String f: st.getFields(c)) {
        String fsort = st.getSort(c,f);
        if (env.isBuiltin(fsort)) continue;
        String fsortid = st.getFullSortClassName(fsort);
        String rawfsortid = st.qualifiedRawSortId(fsort);
        if (st.isAtomType(fsort)) {
          if (st.isBound(c,f))
            res += "String raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+" = "/* Generated by TOM (version 2.6): Do not edit this file */+fsort+"InnerMap.get(get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"());";
          else
            res += "String raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+" = "/* Generated by TOM (version 2.6): Do not edit this file */+fsort+"Map.get(get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"());";
        } else if (st.isInner(c,f)) /* must be expression type */ {
          res += ""/* Generated by TOM (version 2.6): Do not edit this file */+rawfsortid+" raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+" \n            = get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"()._export("/* Generated by TOM (version 2.6): Do not edit this file */+recCall3(fsort,sort)+");"
;
        } else if (st.isOuter(c,f)) /* must be expression type */ {
          res += ""/* Generated by TOM (version 2.6): Do not edit this file */+rawfsortid+" raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+" \n            = get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"()._export("/* Generated by TOM (version 2.6): Do not edit this file */+recCall4(fsort,sort)+");"
;
        } else if (st.isNeutral(c,f)) /* must be expression type */ {
          res += ""/* Generated by TOM (version 2.6): Do not edit this file */+rawfsortid+" raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+" \n            = get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"()._export("/* Generated by TOM (version 2.6): Do not edit this file */+recCall5(fsort)+");"
;
        } else /* must be pattern type */ {
          res += ""/* Generated by TOM (version 2.6): Do not edit this file */+rawfsortid+" raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+" \n            = get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"()._export("/* Generated by TOM (version 2.6): Do not edit this file */+recCall6(fsort)+");"
;
        }
      }
    }
    return res + "return `"/* Generated by TOM (version 2.6): Do not edit this file */+st.rawCons(c)+"("/* Generated by TOM (version 2.6): Do not edit this file */+rawArgList(c)+");";
  }

  private String getBoundRecursiveCalls(String c, String atomSort) {
    String sort = st.getSort(c);
    String sortid = st.getFullSortClassName(sort);
    String res = ""; 
    for(String f: st.getPatternFields(c)) {
      String fsort = st.getSort(c,f);
      if (env.isBuiltin(fsort)) continue;
      if (st.isAtomType(fsort)) {
        if (fsort.equals(atomSort)) {
          res += "atoms.add(get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"());";
        }
      } else if (st.getBoundAtoms(fsort).contains(atomSort)) {
        res += "get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"().getBound"/* Generated by TOM (version 2.6): Do not edit this file */+atomSort+"(atoms);";
      }
    }
    return res;
  }

  private String getBound2RecursiveCalls(String c, String a) {
    String sort = st.getSort(c);
    String sortid = st.getFullSortClassName(sort);
    String aid = st.getFullSortClassName(a);
    String res = ""; 
    for(String f: st.getPatternFields(c)) {
      String fsort = st.getSort(c,f);
      if (env.isBuiltin(fsort)) continue;
      if (st.isAtomType(fsort)) {
        if (fsort.equals(a)) {
          res += "\n            "/* Generated by TOM (version 2.6): Do not edit this file */+aid+" "/* Generated by TOM (version 2.6): Do not edit this file */+f+" = get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"();\n            m.put("/* Generated by TOM (version 2.6): Do not edit this file */+f+",o.get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"(),"/* Generated by TOM (version 2.6): Do not edit this file */+aid+".fresh"/* Generated by TOM (version 2.6): Do not edit this file */+a+"("/* Generated by TOM (version 2.6): Do not edit this file */+f+"));\n          "


;
        }
      } else if (st.getBoundAtoms(fsort).contains(a)) {
        res += "get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"().getBound"/* Generated by TOM (version 2.6): Do not edit this file */+a+"2(o.get"/* Generated by TOM (version 2.6): Do not edit this file */+f+"(),m);";
      }
    }
    return res;
  }

  private String constructorBlockHookString(String c) {
    String cid = st.getFullConstructorClassName(c);
    String sort = st.getSort(c);
    String alphamapargs = alphamapArgList(sort);
    String exportmapargs = exportmapArgList(sort);
    String rawsortid = st.qualifiedRawSortId(sort);
    String sortid = st.getFullSortClassName(sort);

    String res = "{";

    for(String a: st.getAccessibleAtoms(sort)) {
      String aid = st.getFullSortClassName(a);
      res += "\n        public "/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" rename"/* Generated by TOM (version 2.6): Do not edit this file */+a+"(java.util.Hashtable<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+","/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> map) {\n          "/* Generated by TOM (version 2.6): Do not edit this file */+renameRecursiveCalls(c,a)+"\n        }"


;
    }

    res += "\n      /**\n       * alpha equivalence \n       */\n      public void alpha ("/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" o "/* Generated by TOM (version 2.6): Do not edit this file */+alphamapargs+") \n        throws tom.library.freshgom.AlphaMap.AlphaException {\n          if (! (o instanceof "/* Generated by TOM (version 2.6): Do not edit this file */+cid+"))\n            throw new tom.library.freshgom.AlphaMap.AlphaException();\n          "/* Generated by TOM (version 2.6): Do not edit this file */+alphaRecursiveCalls(c)+"\n        };\n\n    /**\n     * exportation (term -> raw term) \n     */\n    public "/* Generated by TOM (version 2.6): Do not edit this file */+rawsortid+" _export("/* Generated by TOM (version 2.6): Do not edit this file */+exportmapargs+") {\n      "/* Generated by TOM (version 2.6): Do not edit this file */+exportRecursiveCalls(c)+"\n    }\n    "
















;

    if(st.isPatternType(sort)) {
      res += " \n        public "/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" _refresh("/* Generated by TOM (version 2.6): Do not edit this file */+hashtableArgList(sort)+") {\n          "/* Generated by TOM (version 2.6): Do not edit this file */+refreshRecursiveCalls(c)+"\n        }\n      "



;

      for(String a: st.getBoundAtoms(sort)) {
        String aid = st.getFullSortClassName(a);
        res += " \n          public void getBound"/* Generated by TOM (version 2.6): Do not edit this file */+a+"(java.util.Set<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> atoms) {\n            "/* Generated by TOM (version 2.6): Do not edit this file */+getBoundRecursiveCalls(c,a)+"\n          }\n\n          public void getBound"/* Generated by TOM (version 2.6): Do not edit this file */+a+"2(\n              "/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" o, tom.library.freshgom.AlphaMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> m) \n              throws tom.library.freshgom.AlphaMap.AlphaException {\n                if (! (o instanceof "/* Generated by TOM (version 2.6): Do not edit this file */+cid+"))\n                  throw new tom.library.freshgom.AlphaMap.AlphaException();\n                "/* Generated by TOM (version 2.6): Do not edit this file */+getBound2RecursiveCalls(c,a)+"\n              }\n\n        "












;
      }
    }

    return res + "}";
  }

  /* -- non variadic raw constructor hooks -- */

  private GomModuleList addRawConstructorHooks(GomModuleList ml) {
    for(String s: st.getSorts()) 
      if(st.isExpressionType(s) || st.isPatternType(s))
        for(String c: st.getConstructors(s))
          if(! st.isVariadic(c))
            ml = addRawConstructorBlockHook(
                ml,c,rawConstructorBlockHookString(c));
    return ml;
  }

  private String getBoundMapRecursiveCalls(String c, String atomSort) {
    String sort = st.getSort(c);
    String sortid = st.getFullSortClassName(sort);
    String aid = st.getFullSortClassName(atomSort);
    String res = ""; 
    for(String f: st.getPatternFields(c)) {
      String fsort = st.getSort(c,f);
      if (env.isBuiltin(fsort)) continue;
      if (st.isAtomType(fsort)) {
        if (fsort.equals(atomSort)) {
          res += "\n            String "/* Generated by TOM (version 2.6): Do not edit this file */+f+" = "/* Generated by TOM (version 2.6): Do not edit this file */+st.rawGetter(c,f)+";\n            m.put("/* Generated by TOM (version 2.6): Do not edit this file */+f+","/* Generated by TOM (version 2.6): Do not edit this file */+aid+".fresh"/* Generated by TOM (version 2.6): Do not edit this file */+atomSort+"("/* Generated by TOM (version 2.6): Do not edit this file */+f+"));\n          "


;
        }
      } else if (st.getBoundAtoms(fsort).contains(atomSort)) {
        res += ""/* Generated by TOM (version 2.6): Do not edit this file */+st.rawGetter(c,f)+".getBound"/* Generated by TOM (version 2.6): Do not edit this file */+atomSort+"Map(m);";
      }
    }
    return res;
  }

  private String convertRecursiveCalls(String c) {
    String sort = st.getSort(c);
    String sortid = st.getFullSortClassName(sort);
    String res = ""; 
    /* if c is a constructor in expression position
       the args are of the form atomsort1Map, atomsort2Map .. */
    if(st.isExpressionType(sort)) {
      for(String f: st.getFields(c)) {
        String fsort = st.getSort(c,f);
        if (env.isBuiltin(fsort)) continue;
        String fsortid = st.getFullSortClassName(fsort);
        String rawfsortid = st.qualifiedRawSortId(fsort);
        if (st.isAtomType(fsort)) {
          res += ""/* Generated by TOM (version 2.6): Do not edit this file */+fsortid+" "/* Generated by TOM (version 2.6): Do not edit this file */+f+" = "/* Generated by TOM (version 2.6): Do not edit this file */+fsort+"Map.get("/* Generated by TOM (version 2.6): Do not edit this file */+st.rawGetter(c,f)+");";
        } else if (st.isExpressionType(fsort)) {
          res += ""/* Generated by TOM (version 2.6): Do not edit this file */+fsortid+" "/* Generated by TOM (version 2.6): Do not edit this file */+f+" \n            = "/* Generated by TOM (version 2.6): Do not edit this file */+st.rawGetter(c,f)+"._convert("/* Generated by TOM (version 2.6): Do not edit this file */+recCall1(fsort)+");"
;
        } else if (st.isPatternType(fsort)) {
          res += "\n            /* declaration before scoping */\n            "/* Generated by TOM (version 2.6): Do not edit this file */+fsortid+" "/* Generated by TOM (version 2.6): Do not edit this file */+f+" = null;\n          "


;
          res += "{ /* to limit declared variables scope */";
          res += ""/* Generated by TOM (version 2.6): Do not edit this file */+rawfsortid+" raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+" = "/* Generated by TOM (version 2.6): Do not edit this file */+st.rawGetter(c,f)+";";
          for(String a: st.getBoundAtoms(fsort)) {
            String aid = st.getFullSortClassName(a);
            res += "\n              tom.library.freshgom.ConvertMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+"_bound"/* Generated by TOM (version 2.6): Do not edit this file */+a+" \n                = raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+".getBound"/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map();\n              tom.library.freshgom.ConvertMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> "/* Generated by TOM (version 2.6): Do not edit this file */+a+"InnerMap \n                = "/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map.combine(raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+"_bound"/* Generated by TOM (version 2.6): Do not edit this file */+a+");\n            "




;
          }
          res += ""/* Generated by TOM (version 2.6): Do not edit this file */+f+" = raw_"/* Generated by TOM (version 2.6): Do not edit this file */+f+"._convert("/* Generated by TOM (version 2.6): Do not edit this file */+recCall2(fsort)+");";
          res += "}";
        }
      }
    /* if c is a constructor in pattern position --
       the args are of the form 
        as1OuterMap, as1InnerMap, as2Map, as3OuterMap, as3InnerMap .. */
    } else if(st.isPatternType(sort)) {
      for(String f: st.getFields(c)) {
        String fsort = st.getSort(c,f);
        if (env.isBuiltin(fsort)) continue;
        String fsortid = st.getFullSortClassName(fsort);
        //String rawfsortid = st.qualifiedRawSortId(fsort);
        if (st.isAtomType(fsort)) {
          if (st.isBound(c,f))
            res += ""/* Generated by TOM (version 2.6): Do not edit this file */+fsortid+" "/* Generated by TOM (version 2.6): Do not edit this file */+f+" = "/* Generated by TOM (version 2.6): Do not edit this file */+fsort+"InnerMap.get("/* Generated by TOM (version 2.6): Do not edit this file */+st.rawGetter(c,f)+");";
          else
            res += ""/* Generated by TOM (version 2.6): Do not edit this file */+fsortid+" "/* Generated by TOM (version 2.6): Do not edit this file */+f+" = "/* Generated by TOM (version 2.6): Do not edit this file */+fsort+"Map.get("/* Generated by TOM (version 2.6): Do not edit this file */+st.rawGetter(c,f)+");";
        } else if (st.isInner(c,f)) /* must be expression type */ {
          res += ""/* Generated by TOM (version 2.6): Do not edit this file */+fsortid+" "/* Generated by TOM (version 2.6): Do not edit this file */+f+" \n            = "/* Generated by TOM (version 2.6): Do not edit this file */+st.rawGetter(c,f)+"._convert("/* Generated by TOM (version 2.6): Do not edit this file */+recCall3(fsort,sort)+");"
;
        } else if (st.isOuter(c,f)) /* must be expression type */ {
          res += ""/* Generated by TOM (version 2.6): Do not edit this file */+fsortid+" "/* Generated by TOM (version 2.6): Do not edit this file */+f+" \n            = "/* Generated by TOM (version 2.6): Do not edit this file */+st.rawGetter(c,f)+"._convert("/* Generated by TOM (version 2.6): Do not edit this file */+recCall4(fsort,sort)+");"
;
        } else if (st.isNeutral(c,f)) /* must be expression type */ {
          res += ""/* Generated by TOM (version 2.6): Do not edit this file */+fsortid+" "/* Generated by TOM (version 2.6): Do not edit this file */+f+" \n            = "/* Generated by TOM (version 2.6): Do not edit this file */+st.rawGetter(c,f)+"._convert("/* Generated by TOM (version 2.6): Do not edit this file */+recCall5(fsort)+");"
;
        } else /* must be pattern type */ {
          res += ""/* Generated by TOM (version 2.6): Do not edit this file */+fsortid+" "/* Generated by TOM (version 2.6): Do not edit this file */+f+" \n            = "/* Generated by TOM (version 2.6): Do not edit this file */+st.rawGetter(c,f)+"._convert("/* Generated by TOM (version 2.6): Do not edit this file */+recCall6(fsort)+");"
;
        }
      }
    }
    return res + "return `"/* Generated by TOM (version 2.6): Do not edit this file */+c+"("/* Generated by TOM (version 2.6): Do not edit this file */+convertArgList(c)+");";
  }

  private String rawConstructorBlockHookString(String c) {
    String sort = st.getSort(c);
    String convertmapargs = convertmapArgList(sort);
    String sortid = st.getFullSortClassName(sort);

    String res = "{\n      /**\n       * importation (raw term -> term) \n       */\n      public "/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" _convert("/* Generated by TOM (version 2.6): Do not edit this file */+convertmapargs+") {\n        "/* Generated by TOM (version 2.6): Do not edit this file */+convertRecursiveCalls(c)+"\n      }\n    "






;

    if(st.isPatternType(sort)) {
      for(String a: st.getBoundAtoms(sort)) {
        String aid = st.getFullSortClassName(a);
        res += "\n          public void \n            getBound"/* Generated by TOM (version 2.6): Do not edit this file */+a+"Map(tom.library.freshgom.ConvertMap<"/* Generated by TOM (version 2.6): Do not edit this file */+aid+"> m) {\n              "/* Generated by TOM (version 2.6): Do not edit this file */+getBoundMapRecursiveCalls(c,a)+";\n            }\n        "




;
      }
    }

    return res + "}";
  }

  /* -- atom hooks -- */

  private GomModuleList addAtomHooks(GomModuleList ml) {
    for(String s: st.getAtoms()) {
      ml = addSortBlockHook(ml,s,atomBlockHookString(s));
      ml = addSortInterfaceHook(ml,s,atomInterfaceHookString);
    }
    return ml;
  }

  private String atomBlockHookString(String sort) {
    String sortid = st.getFullSortClassName(sort);
    return "{\n      private static int counter = 0;\n\n      public static "/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" \n        fresh"/* Generated by TOM (version 2.6): Do not edit this file */+sort+"("/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" hint) { \n          return fresh"/* Generated by TOM (version 2.6): Do not edit this file */+sort+"(hint.gethint()); \n        }\n\n      public static "/* Generated by TOM (version 2.6): Do not edit this file */+sortid+" \n        fresh"/* Generated by TOM (version 2.6): Do not edit this file */+sort+"(String hint) { \n          return `"/* Generated by TOM (version 2.6): Do not edit this file */+sort+"(++counter,hint.split(\"[0-9]\")[0]); \n        }\n\n      public boolean equals("/* Generated by TOM (version 2.6): Do not edit this file */+sort+" o) {\n        return this.getn() == o.getn();\n      }\n\n      public String getRepresentation(int n) {\n        return gethint() + (n==0 ? \"\" : n);\n      }\n    }"



















;
  }

  private static final String atomInterfaceHookString 
    = "{ tom.library.freshgom.Atom }";

  /* -- rawification -- */

  private GomModuleList addRawSortsAndConstructors(GomModuleList res) {
    try { return (GomModuleList) tom_make_TopDown(tom_make_AddRaw(st)).visitLight(res); }
    catch(VisitFailure e) { 
      throw new RuntimeException("should never happen"); 
    }
  }

  public static class AddRaw extends tom.library.sl.BasicStrategy {private  tom.gom.SymbolTable  st;public AddRaw( tom.gom.SymbolTable  st) {super(( new tom.library.sl.Identity() ));this.st=st;}public  tom.gom.SymbolTable  getst() {return st;}public tom.library.sl.Visitable[] getChildren() {tom.library.sl.Visitable[] stratChilds = new tom.library.sl.Visitable[getChildCount()];stratChilds[0] = super.getChildAt(0);return stratChilds;}public tom.library.sl.Visitable setChildren(tom.library.sl.Visitable[] children) {super.setChildAt(0, children[0]);return this;}public int getChildCount() {return 1;}public tom.library.sl.Visitable getChildAt(int index) {switch (index) {case 0: return super.getChildAt(0);default: throw new IndexOutOfBoundsException();}}public tom.library.sl.Visitable setChildAt(int index, tom.library.sl.Visitable child) {switch (index) {case 0: return super.setChildAt(0, child);default: throw new IndexOutOfBoundsException();}}public  tom.gom.adt.gom.types.Grammar  visit_Grammar( tom.gom.adt.gom.types.Grammar  tom__arg, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {{{if ( (tom__arg instanceof tom.gom.adt.gom.types.Grammar) ) {if ( ((( tom.gom.adt.gom.types.Grammar )tom__arg) instanceof tom.gom.adt.gom.types.grammar.Grammar) ) {

 
        return (( tom.gom.adt.gom.types.Grammar )tom__arg).setProductionList(addRaw(st, (( tom.gom.adt.gom.types.Grammar )tom__arg).getProductionList() )); 
      }}}}return _visit_Grammar(tom__arg,introspector); }public  tom.gom.adt.gom.types.Grammar  _visit_Grammar( tom.gom.adt.gom.types.Grammar  arg, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {if (!((environment ==  null ))) {return (( tom.gom.adt.gom.types.Grammar )any.visit(environment,introspector));} else {return (( tom.gom.adt.gom.types.Grammar )any.visitLight(arg,introspector));} }public Object visitLight(Object v, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {if ( (v instanceof tom.gom.adt.gom.types.Grammar) ) {return visit_Grammar((( tom.gom.adt.gom.types.Grammar )v),introspector);}if (!((environment ==  null ))) {return any.visit(environment,introspector);} else {return any.visitLight(v,introspector);} }}public static  tom.library.sl.Strategy  tom_make_AddRaw( tom.gom.SymbolTable  t0) { return new AddRaw(t0);}



  /**
   * match pl with
   *  | p::ps -> if fresh p && (not atom p) 
   *             then p::(rawify p)::(addraw pl) 
   *             else p::(addraw pl)
   *  | [] -> []
   **/
  private static ProductionList addRaw(SymbolTable st, ProductionList pl) {
    {{if ( (pl instanceof tom.gom.adt.gom.types.ProductionList) ) {if ( ((( tom.gom.adt.gom.types.ProductionList )pl) instanceof tom.gom.adt.gom.types.productionlist.ConsConcProduction) ) { tom.gom.adt.gom.types.Production  tomMatch496NameNumber_freshVar_1= (( tom.gom.adt.gom.types.ProductionList )pl).getHeadConcProduction() ;

        ProductionList nps = addRaw(st, (( tom.gom.adt.gom.types.ProductionList )pl).getTailConcProduction() );
        {{if ( (tomMatch496NameNumber_freshVar_1 instanceof tom.gom.adt.gom.types.Production) ) {if ( ((( tom.gom.adt.gom.types.Production )tomMatch496NameNumber_freshVar_1) instanceof tom.gom.adt.gom.types.production.SortType) ) { tom.gom.adt.gom.types.GomType  tomMatch497NameNumber_freshVar_1= (( tom.gom.adt.gom.types.Production )tomMatch496NameNumber_freshVar_1).getType() ;if ( (tomMatch497NameNumber_freshVar_1 instanceof tom.gom.adt.gom.types.gomtype.GomType) ) { String  tomMatch497NameNumber_freshVar_3= tomMatch497NameNumber_freshVar_1.getName() ;

            if (st.isFreshType(tomMatch497NameNumber_freshVar_3) && !st.isAtomType(tomMatch497NameNumber_freshVar_3)) 
              return  tom.gom.adt.gom.types.productionlist.ConsConcProduction.make(tomMatch496NameNumber_freshVar_1, tom.gom.adt.gom.types.productionlist.ConsConcProduction.make(rawify(tomMatch496NameNumber_freshVar_1,st),tom_append_list_ConcProduction(nps, tom.gom.adt.gom.types.productionlist.EmptyConcProduction.make() )) ) ;
          }}}}}

        return  tom.gom.adt.gom.types.productionlist.ConsConcProduction.make(tomMatch496NameNumber_freshVar_1,tom_append_list_ConcProduction(nps, tom.gom.adt.gom.types.productionlist.EmptyConcProduction.make() )) ;
      }}}{if ( (pl instanceof tom.gom.adt.gom.types.ProductionList) ) {if ( ((( tom.gom.adt.gom.types.ProductionList )pl) instanceof tom.gom.adt.gom.types.productionlist.EmptyConcProduction) ) {
 return (( tom.gom.adt.gom.types.ProductionList )pl); }}}}

    throw new RuntimeException("non exhaustive patterns");
  }

  public static class Rawify extends tom.library.sl.BasicStrategy {private  tom.gom.SymbolTable  st;public Rawify( tom.gom.SymbolTable  st) {super(( new tom.library.sl.Identity() ));this.st=st;}public  tom.gom.SymbolTable  getst() {return st;}public tom.library.sl.Visitable[] getChildren() {tom.library.sl.Visitable[] stratChilds = new tom.library.sl.Visitable[getChildCount()];stratChilds[0] = super.getChildAt(0);return stratChilds;}public tom.library.sl.Visitable setChildren(tom.library.sl.Visitable[] children) {super.setChildAt(0, children[0]);return this;}public int getChildCount() {return 1;}public tom.library.sl.Visitable getChildAt(int index) {switch (index) {case 0: return super.getChildAt(0);default: throw new IndexOutOfBoundsException();}}public tom.library.sl.Visitable setChildAt(int index, tom.library.sl.Visitable child) {switch (index) {case 0: return super.setChildAt(0, child);default: throw new IndexOutOfBoundsException();}}public  tom.gom.adt.gom.types.GomType  visit_GomType( tom.gom.adt.gom.types.GomType  tom__arg, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {{{if ( (tom__arg instanceof tom.gom.adt.gom.types.GomType) ) {if ( ((( tom.gom.adt.gom.types.GomType )tom__arg) instanceof tom.gom.adt.gom.types.gomtype.GomType) ) { String  tomMatch498NameNumber_freshVar_1= (( tom.gom.adt.gom.types.GomType )tom__arg).getName() ;

 
        if (st.isAtomType(tomMatch498NameNumber_freshVar_1)) return (( tom.gom.adt.gom.types.GomType )tom__arg).setName("String");
        else if (!env.isBuiltin(tomMatch498NameNumber_freshVar_1)) return (( tom.gom.adt.gom.types.GomType )tom__arg).setName(st.rawSort(tomMatch498NameNumber_freshVar_1));
      }}}}return _visit_GomType(tom__arg,introspector); }public  tom.gom.adt.gom.types.Production  visit_Production( tom.gom.adt.gom.types.Production  tom__arg, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {{{if ( (tom__arg instanceof tom.gom.adt.gom.types.Production) ) {if ( ((( tom.gom.adt.gom.types.Production )tom__arg) instanceof tom.gom.adt.gom.types.production.Production) ) {


 return (( tom.gom.adt.gom.types.Production )tom__arg).setName(st.rawCons( (( tom.gom.adt.gom.types.Production )tom__arg).getName() )); }}}}return _visit_Production(tom__arg,introspector); }public  tom.gom.adt.gom.types.Production  _visit_Production( tom.gom.adt.gom.types.Production  arg, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {if (!((environment ==  null ))) {return (( tom.gom.adt.gom.types.Production )any.visit(environment,introspector));} else {return (( tom.gom.adt.gom.types.Production )any.visitLight(arg,introspector));} }public  tom.gom.adt.gom.types.GomType  _visit_GomType( tom.gom.adt.gom.types.GomType  arg, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {if (!((environment ==  null ))) {return (( tom.gom.adt.gom.types.GomType )any.visit(environment,introspector));} else {return (( tom.gom.adt.gom.types.GomType )any.visitLight(arg,introspector));} }public Object visitLight(Object v, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {if ( (v instanceof tom.gom.adt.gom.types.Production) ) {return visit_Production((( tom.gom.adt.gom.types.Production )v),introspector);}if ( (v instanceof tom.gom.adt.gom.types.GomType) ) {return visit_GomType((( tom.gom.adt.gom.types.GomType )v),introspector);}if (!((environment ==  null ))) {return any.visit(environment,introspector);} else {return any.visitLight(v,introspector);} }}public static  tom.library.sl.Strategy  tom_make_Rawify( tom.gom.SymbolTable  t0) { return new Rawify(t0);}



  private static Production rawify(Production p, SymbolTable st) {
    try { return (Production) tom_make_TopDown(tom_make_Rawify(st)).visitLight(p); }
    catch(VisitFailure f) { 
      throw new RuntimeException("should never happen"); 
    }
  }

  /* -- tweaked mappings generation */

  private GomModuleList addMappingHooks(GomModuleList ml) {
    for(String c: st.getFreshConstructors()) 
      if(st.containsRefreshPoint(c)) 
        ml = addConstructorMappingHook(ml,c,mappingString(c));
    return ml;
  }


  /**
  * generates "x:A,y:B" for f(x:A,y:B)
  **/
  private String typedConsArgList(String c) {
    StringBuffer buf = new StringBuffer();
    boolean first=true;
    for(String arg: st.getFields(c)) {
      if (!first) buf.append(",");
      else first = false;
      buf.append(arg+":"+st.getSort(c,arg));
    }
    return buf.toString();
  }

  /**
  * generates "x,y" for f(x:A,y:B)
  **/
  private String consArgList(String c) {
    StringBuffer buf = new StringBuffer();
    boolean first=true;
    for(String arg: st.getFields(c)) {
      if (!first) buf.append(",");
      else first = false;
      buf.append(arg);
    }
    return buf.toString();
  }

  /**
  * generates "$x,$y" for f(x:A,y:B)
  **/
  private String dollarConsArgList(String c) {
    StringBuffer buf = new StringBuffer();
    boolean first=true;
    for(String arg: st.getFields(c)) {
      if (!first) buf.append(",");
      else first = false;
      buf.append("$" + arg);
    }
    return buf.toString();
  }

  /**
  * generates "get_slot(x,t) { $t.getx() }
  *            get_slot(y,t) { $t.gety() }"
  * for f(x:A,y:B)
  **/
  private String slotDescriptions(String c) {
    StringBuffer buf = new StringBuffer();
    boolean first=true;
    for(String arg: st.getFields(c)) {
      if(st.isRefreshPoint(c,arg))
        buf.append("get_slot("/* Generated by TOM (version 2.6): Do not edit this file */+arg+",t) { $t.get"/* Generated by TOM (version 2.6): Do not edit this file */+arg+"().refresh() }" + "\n");
      else
        buf.append("get_slot("/* Generated by TOM (version 2.6): Do not edit this file */+arg+",t) { $t.get"/* Generated by TOM (version 2.6): Do not edit this file */+arg+"() }" + "\n");
    }
    return buf.toString();
  }

  private String mappingString(String c) {
    String s = st.getSort(c);
    if (st.isVariadic(c)) {
      String codomain = st.getCoDomain(c);
      String domain = st.getDomain(c);
      String consid = st.getFullConstructorClassName("Cons" + c);
      String nilid = st.getFullConstructorClassName("Empty" + c);
      String gethead = null;
      if(st.isRefreshPoint(c)) gethead = "getHead"/* Generated by TOM (version 2.6): Do not edit this file */+c+"().refresh()";
      else gethead = "getHead"/* Generated by TOM (version 2.6): Do not edit this file */+c+"()";
      return "{\n        %oplist "/* Generated by TOM (version 2.6): Do not edit this file */+codomain+" "/* Generated by TOM (version 2.6): Do not edit this file */+c+"("/* Generated by TOM (version 2.6): Do not edit this file */+domain+"*) {\n          is_fsym(t) { (($t instanceof "/* Generated by TOM (version 2.6): Do not edit this file */+consid+") || ($t instanceof "/* Generated by TOM (version 2.6): Do not edit this file */+nilid+")) }\n          make_empty() { "/* Generated by TOM (version 2.6): Do not edit this file */+nilid+".make() }\n          make_insert(e,l) { "/* Generated by TOM (version 2.6): Do not edit this file */+consid+".make($e,$l) }\n          get_head(l) { $l."/* Generated by TOM (version 2.6): Do not edit this file */+gethead+" }\n          get_tail(l) { $l.getTail"/* Generated by TOM (version 2.6): Do not edit this file */+c+"() }\n          is_empty(l) { $l.isEmpty"/* Generated by TOM (version 2.6): Do not edit this file */+c+"() }\n        }\n      }"








;
    } else {
      String cid = st.getFullConstructorClassName(c);
      return "{\n        %op "/* Generated by TOM (version 2.6): Do not edit this file */+s+" "/* Generated by TOM (version 2.6): Do not edit this file */+c+"("/* Generated by TOM (version 2.6): Do not edit this file */+typedConsArgList(c)+") {\n          is_fsym(t) { ($t instanceof "/* Generated by TOM (version 2.6): Do not edit this file */+cid+") }\n          "/* Generated by TOM (version 2.6): Do not edit this file */+slotDescriptions(c)+"\n          make("/* Generated by TOM (version 2.6): Do not edit this file */+consArgList(c)+") { "/* Generated by TOM (version 2.6): Do not edit this file */+cid+".make("/* Generated by TOM (version 2.6): Do not edit this file */+dollarConsArgList(c)+") }\n       }\n      }"





;
    }
  }

  /* -- atom expansion --**/

  public static class ExpandAtoms extends tom.library.sl.BasicStrategy {private  java.util.ArrayList  list;public ExpandAtoms( java.util.ArrayList  list) {super(( new tom.library.sl.Identity() ));this.list=list;}public  java.util.ArrayList  getlist() {return list;}public tom.library.sl.Visitable[] getChildren() {tom.library.sl.Visitable[] stratChilds = new tom.library.sl.Visitable[getChildCount()];stratChilds[0] = super.getChildAt(0);return stratChilds;}public tom.library.sl.Visitable setChildren(tom.library.sl.Visitable[] children) {super.setChildAt(0, children[0]);return this;}public int getChildCount() {return 1;}public tom.library.sl.Visitable getChildAt(int index) {switch (index) {case 0: return super.getChildAt(0);default: throw new IndexOutOfBoundsException();}}public tom.library.sl.Visitable setChildAt(int index, tom.library.sl.Visitable child) {switch (index) {case 0: return super.setChildAt(0, child);default: throw new IndexOutOfBoundsException();}}public  tom.gom.adt.gom.types.Production  visit_Production( tom.gom.adt.gom.types.Production  tom__arg, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {{{if ( (tom__arg instanceof tom.gom.adt.gom.types.Production) ) {if ( ((( tom.gom.adt.gom.types.Production )tom__arg) instanceof tom.gom.adt.gom.types.production.AtomDecl) ) { String  tomMatch500NameNumber_freshVar_1= (( tom.gom.adt.gom.types.Production )tom__arg).getName() ;


        list.add(tomMatch500NameNumber_freshVar_1);
        return  tom.gom.adt.gom.types.production.SortType.make( tom.gom.adt.gom.types.gomtype.GomType.make( tom.gom.adt.gom.types.typespec.AtomType.make() , tomMatch500NameNumber_freshVar_1) ,  tom.gom.adt.gom.types.atomlist.EmptyConcAtom.make() ,  tom.gom.adt.gom.types.productionlist.ConsConcProduction.make( tom.gom.adt.gom.types.production.Production.make(tomMatch500NameNumber_freshVar_1,  tom.gom.adt.gom.types.fieldlist.ConsConcField.make( tom.gom.adt.gom.types.field.NamedField.make( tom.gom.adt.gom.types.scopespecifier.None.make() , "n",  tom.gom.adt.gom.types.gomtype.GomType.make( tom.gom.adt.gom.types.typespec.ExpressionType.make() , "int") ) , tom.gom.adt.gom.types.fieldlist.ConsConcField.make( tom.gom.adt.gom.types.field.NamedField.make( tom.gom.adt.gom.types.scopespecifier.None.make() , "hint",  tom.gom.adt.gom.types.gomtype.GomType.make( tom.gom.adt.gom.types.typespec.ExpressionType.make() , "String") ) , tom.gom.adt.gom.types.fieldlist.EmptyConcField.make() ) ) ,  tom.gom.adt.gom.types.gomtype.GomType.make( tom.gom.adt.gom.types.typespec.AtomType.make() , tomMatch500NameNumber_freshVar_1) ,  tom.gom.adt.gom.types.option.Origin.make(-1) ) , tom.gom.adt.gom.types.productionlist.EmptyConcProduction.make() ) ) 







; 
      }}}}return _visit_Production(tom__arg,introspector); }public  tom.gom.adt.gom.types.Production  _visit_Production( tom.gom.adt.gom.types.Production  arg, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {if (!((environment ==  null ))) {return (( tom.gom.adt.gom.types.Production )any.visit(environment,introspector));} else {return (( tom.gom.adt.gom.types.Production )any.visitLight(arg,introspector));} }public Object visitLight(Object v, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {if ( (v instanceof tom.gom.adt.gom.types.Production) ) {return visit_Production((( tom.gom.adt.gom.types.Production )v),introspector);}if (!((environment ==  null ))) {return any.visit(environment,introspector);} else {return any.visitLight(v,introspector);} }}public static  tom.library.sl.Strategy  tom_make_ExpandAtoms( java.util.ArrayList  t0) { return new ExpandAtoms(t0);}



  /* -- update expressiontype -> atomtype for atom sorts --**/

  public static class UpdateSpecialization extends tom.library.sl.BasicStrategy {private  java.util.ArrayList  list;public UpdateSpecialization( java.util.ArrayList  list) {super(( new tom.library.sl.Identity() ));this.list=list;}public  java.util.ArrayList  getlist() {return list;}public tom.library.sl.Visitable[] getChildren() {tom.library.sl.Visitable[] stratChilds = new tom.library.sl.Visitable[getChildCount()];stratChilds[0] = super.getChildAt(0);return stratChilds;}public tom.library.sl.Visitable setChildren(tom.library.sl.Visitable[] children) {super.setChildAt(0, children[0]);return this;}public int getChildCount() {return 1;}public tom.library.sl.Visitable getChildAt(int index) {switch (index) {case 0: return super.getChildAt(0);default: throw new IndexOutOfBoundsException();}}public tom.library.sl.Visitable setChildAt(int index, tom.library.sl.Visitable child) {switch (index) {case 0: return super.setChildAt(0, child);default: throw new IndexOutOfBoundsException();}}public  tom.gom.adt.gom.types.GomType  visit_GomType( tom.gom.adt.gom.types.GomType  tom__arg, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {{{if ( (tom__arg instanceof tom.gom.adt.gom.types.GomType) ) {if ( ((( tom.gom.adt.gom.types.GomType )tom__arg) instanceof tom.gom.adt.gom.types.gomtype.GomType) ) {


        if (list.contains( (( tom.gom.adt.gom.types.GomType )tom__arg).getName() )) {
          return (( tom.gom.adt.gom.types.GomType )tom__arg).setSpecialization( tom.gom.adt.gom.types.typespec.AtomType.make() );
        }
      }}}}return _visit_GomType(tom__arg,introspector); }public  tom.gom.adt.gom.types.GomType  _visit_GomType( tom.gom.adt.gom.types.GomType  arg, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {if (!((environment ==  null ))) {return (( tom.gom.adt.gom.types.GomType )any.visit(environment,introspector));} else {return (( tom.gom.adt.gom.types.GomType )any.visitLight(arg,introspector));} }public Object visitLight(Object v, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {if ( (v instanceof tom.gom.adt.gom.types.GomType) ) {return visit_GomType((( tom.gom.adt.gom.types.GomType )v),introspector);}if (!((environment ==  null ))) {return any.visit(environment,introspector);} else {return any.visitLight(v,introspector);} }}public static  tom.library.sl.Strategy  tom_make_UpdateSpecialization( java.util.ArrayList  t0) { return new UpdateSpecialization(t0);}



}
