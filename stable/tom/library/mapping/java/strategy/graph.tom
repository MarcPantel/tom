/*
 * Copyright (c) 2000-2006, INRIA
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: 
 * 	- Redistributions of source code must retain the above copyright
 * 	notice, this list of conditions and the following disclaimer.  
 * 	- Redistributions in binary form must reproduce the above copyright
 * 	notice, this list of conditions and the following disclaimer in the
 * 	documentation and/or other materials provided with the distribution.
 * 	- Neither the name of the INRIA nor the names of its
 * 	contributors may be used to endorse or promote products derived from
 * 	this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

%include { util/types/Map.tom }
%include { composed.tom }

%include{ visitable.tom}
  %op Strategy Ref(root:Visitable, s1:Strategy) {
    is_fsym(t) { (t instanceof tom.library.strategy.mutraveler.Ref) && ((tom.library.strategy.mutraveler.Ref)t).isRelative()==false && ((tom.library.strategy.mutraveler.Ref)t).isStrict()==false }
    make(v,s) { tom.library.strategy.mutraveler.Ref.make(v,s) }
    get_slot(root, t) { ((tom.library.strategy.mutraveler.Ref)t).getSubject() }
    get_slot(s1, t) { (tom.library.strategy.mutraveler.MuStrategy)t.getChildAt(tom.library.strategy.mutraveler.Ref.ARG) }
  }
  
  %op Strategy RelativeRef(root:Visitable, s1:Strategy) {
    is_fsym(t) { (t instanceof tom.library.strategy.mutraveler.Ref) && ((tom.library.strategy.mutraveler.Ref)t).isRelative()==true && ((tom.library.strategy.mutraveler.Ref)t).isStrict()==false }
    make(v,s) { tom.library.strategy.mutraveler.Ref.makeRelative(v,s) }
    get_slot(root, t) { ((tom.library.strategy.mutraveler.Ref)t).getSubject() }
    get_slot(s1, t) { (tom.library.strategy.mutraveler.MuStrategy)t.getChildAt(tom.library.strategy.mutraveler.Ref.ARG) }
  }

  %op Strategy StrictRef(root:Visitable, s1:Strategy) {
    is_fsym(t) { (t instanceof tom.library.strategy.mutraveler.Ref) && ((tom.library.strategy.mutraveler.Ref)t).isRelative()==false && ((tom.library.strategy.mutraveler.Ref)t).isStrict()==true }
    make(v,s) { tom.library.strategy.mutraveler.Ref.make(v,s) }
    get_slot(root, t) { ((tom.library.strategy.mutraveler.Ref)t).getSubject() }
    get_slot(s1, t) { (tom.library.strategy.mutraveler.MuStrategy)t.getChildAt(tom.library.strategy.mutraveler.Ref.ARG) }
  }
  
  %op Strategy StrictRelativeRef(root:Visitable, s1:Strategy) {
    is_fsym(t) { (t instanceof tom.library.strategy.mutraveler.Ref) && ((tom.library.strategy.mutraveler.Ref)t).isRelative()==true && ((tom.library.strategy.mutraveler.Ref)t).isStrict()==true }
    make(v,s) { tom.library.strategy.mutraveler.Ref.makeRelative(v,s) }
    get_slot(root, t) { ((tom.library.strategy.mutraveler.Ref)t).getSubject() }
    get_slot(s1, t) { (tom.library.strategy.mutraveler.MuStrategy)t.getChildAt(tom.library.strategy.mutraveler.Ref.ARG) }
  }

/**
 * This strategy opertor corresponds to temporal operator AU in CTL.
 * Identity() can be interpreted as True and Failure as False
 * It succeeds if s1 is "True" until s2 is "True".
 * @param s1 the first strategy.
 * @param s2 the second strategy.
 */
%op Strategy AU(s1:Strategy, s2:Strategy) {
  make(s1,s2) { `mu(MuVar("x"),Choice(s2,Sequence(Sequence(s1,All(MuVar("x"))),One(Identity())))) }
}

%op Strategy EU(s1:Strategy, s2:Strategy) {
  make(s1,s2) { `mu(MuVar("x"),Choice(s2,Sequence(s1,One(MuVar("x")))))}
}

%op Strategy TrueCtl(){
  make() {`Identity() }
}

%op Strategy FalseCtl(){
  make() {`Fail() }
}

%op Strategy AndCtl(s1:Strategy, s2:Strategy) {
  make(s1,s2) {`Sequence(s1,s2) }
}

%op Strategy OrCtl(s1:Strategy, s2:Strategy) {
  make(s1,s2) {`Choice(s1,s2)}
}

%op Strategy AF(s:Strategy) {
  make(s) {`AU(Identity(),s) }
}

%op Strategy EF(s:Strategy) {
  make(s) {`EU(Identity(),s) }
}

%op Strategy AX(s:Strategy) {
  make(s) { `All(s) }
}

%op Strategy EX(s:Strategy) {
  make(s) {`One(s) }
}
