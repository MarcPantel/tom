List of realized syntactic Test

////////////////////
TYPETERM DECLARATION
////////////////////
Grammar {
	%typeterm typeName {
		implement	     { ... }
		get_fun_sym(var)     { ... }
		cmp_fun_sym(var,var) { ... }
		get_subterm(var,var) { ... }
		[equals(var,var)     { ... }]
	}
}
Test {
     JTypeTermRef.t
     JTypeTerm1.t
	Missing functions : [get_fun_sym]
	Missing functions : [cmp_fun_sym]
	Missing functions : [get_subterm]
	Missing functions : [get_fun_sym, cmp_fun_sym, get_subterm]
	missing optional `equals` function : No message
	 Repeated macro-functions 'get_fun_sym'
	Arguments must be linear in declaration 'cmp_fun_sym'
	Arguments must be linear in declaration 'equals'
	Multiple definition of type
}

////////////////////
TYPEARRAY DECLARATION
////////////////////
Grammar {
	%typearray typeName {
		implement            { ... }
		get_fun_sym(var)     { ... }
		cmp_fun_sym(var,var) { ... }
		get_element(var,var) { ... }
		get_size(var)        { ... }
		[equals(var,var)     { ... }]
	}
}
Test {
     JTypeArrayRef.t
     JTypeArray1.t
	Missing functions : [get_fun_sym]
	Missing functions : [cmp_fun_sym]
	Missing functions : [get_element]
	Missing functions : [get_size]
	missing optional `equals` function : No message
	Arguments must be linear in declaration 'cmp_fun_sym'
	Arguments must be linear in declaration 'equals
	Repeated macro-functions 'get_element'
}

////////////////////
TYPELIST DECLARATION
////////////////////
Grammar {
	%typelist typeName {
		implement	     { ... }
		get_fun_sym(var)     { ... }
		cmp_fun_sym(var,var) { ... }
		get_head(var)    { ... }
		get_tail(var)    { ... }
		is_empty(var)    { ... }
	}
}
Test {
     JTypeListRef.t
     JTypeList1.t
	Missing functions : [get_fun_sym]
	Missing functions : [cmp_fun_sym]
	Missing functions : [get_head]
	Missing functions : [get_tail]
	Missing functions : [is_empty]
	OK: Missing equals
	Arguments must be linear in declaration 'cmp_fun_sym'
	Arguments must be linear in declaration 'equals'
	Repeated macro-functions 'get_head'
}

////////////////////
OPERATOR DECLARATION
////////////////////
Grammar {
	%op typeName opName [(slotName:type, type,... )] {
		fsym             { ... }
		[is_fsym(var)     { ... }
		 make(var, ...)   { ... }
		 get_slot(type,t) { ... }
		]
	}
}
Test {
     JOperatorRef.t
     JOperator1.t
	Operator 'op' has an unknown return type
	Slot position 1 of operator 'op' has an unknown type
	Repeated macro-functions 'make'
	Arguments must be linear in declaration 'make'
	OK: Operator defined before type declaration

     JOperator2.t
	Warning: GetSlot declaration `get_slot(slot2,...)` is missing. SlotName will not be considered
	Warning: GetSlot declaration 'type' is repeated in operator declaration
	Warning: Some GetSlot declaration are incompatible with operator signature

     JOperator3.t
	Bad number of arguments in method 'make'

     JOperator4.t
	Multiple definition of operator
     JOperator5.t	
	Repeated slot  's1' in operator declaration

}

////////////////////
OPARRAY DECLARATION
////////////////////
Grammar {
	%oparray typeName opName(typeName*) {
		fsym                  { ... }
		make_empty(var)       { ... }
		make_append(var, var) { ... }
	}
}

Test {
     JOpArrayRef.t
     JOpArray1.t
	Operator 'concArray' has an unknown return type
	Slot position 1 of operator 'concArray' has an unknown type
	Missing functions : [make_empty]
	Missing functions : [make_append]
	Arguments must be linear in declaration 'make_append'
	Repeated macro-functions 'make_append'
}

////////////////////
OPLIST DECLARATION
////////////////////
Grammar {
	%oplist typeName opName(typeName*) {
		fsym                  { ... }
		make_empty(var)       { ... }
		make_insert(var, var) { ... }
	}
}

Test {
     JOpListRef.t
     JOpList1.t
	Operator 'concList' has an unknown return type
	Slot position 1 of operator 'concList' has an unknown type
	Missing functions : [make_empty]
	Missing functions : [make_insert]
	Arguments must be linear in declaration 'make_insert'
	Repeated macro-functions 'make_empty'
}


////////////////////
MATCH DECLARATION
////////////////////
Grammar {
	%match(typeName var, typeName var, ...) {
		term, term, ...-> { ... }
	}
}

Test {
     JMatchRef.t
     JMatch1.t
	Variable 't' has an unknown type 'type' (Bad type name in signature)
	Repeated variable name in Match signature
	Bad number of arguments: 2 argument(s) required but 1 found in %match structure
	Bad number of arguments: 2 argument(s) required but 3 found in %match structure
	Single list variable x* : Not allowed in %match structure
	Single list variable _* : Not allowed in %match structure
	For slot 2 :Type 'type1' required but Type 'type0' found

}

////////////////////
RULE DECLARATION
////////////////////
Grammar {
	%rule {
	  term -> term [where term := term] [if term == term]
	  ... 
	}
}

Test {
     JRuleRef.t
     JRule1.t
	 `_`: Impossible in rule left hand side
	  `X*`: Impossible in rule left hand side
	  `_*`: Impossible in rule left hand side
	  `XML Construct a`: Impossible in rule left hand side
	  `Disjunction`: Impossible in rule left hand side
	  `Disjunction`: Impossible in rule left hand side}
	  Rule head symbol `op2` has no `make` method: It is necessary to define one!!
	  Rule head symbol name `op1` expected, but `op2` found
	  Bad number of arguments for symbol `op1`: 2 argument(s) required but 0 found
	  The symbol `op3` has type `type2` but type `type1` was required
	  The symbol `op2` has type `type1` but type `type2` was required
	  `_`: Impossible in rule right hand side
	  `_*`: Impossible in rule right hand side
	  `X*`: Impossible in rule right hand side
	  `XML construct a`: Impossible in rule right hand side
	  `Disjunction`: Impossible in rule right hand side
	   `_`: Impossible in rule right hand side
	   Bad number of arguments for symbol `op1`: 2 argument(s) required but 1 found
	   Bad number of arguments for symbol `op1`: 2 argument(s) required but 1 found
	   `op1[...]`: Impossible in rule right hand side
	
////////////////////
RECORD DECLARATION
////////////////////
JRecord1.t
	Slot Name `badslot` is not correct for symbol `op`. Possible slot names are : [slot1, slot2]
	[] are not allowed on lists or arrays, see `concList1`
	Same slot names can not be used several times in symbol `op`: Repeated slot Name : `slot1`
	Unknown symbol opp

////////////////////
APPL DECLARATION
////////////////////
JAppl1.t
	Bad number of arguments for symbol `op2`: 2 argument(s) required but 1 found
	Bad number of arguments for symbol `op2`: 2 argument(s) required but 3 found
	Too many list symbols with returned type `type2`:  concList2 concList3
	OK: Only one list symbol with returned type `type1`
	Not able to found a list symbol of type: `type0
	The symbol op1 has type `type1` but type `type2` was required (x2)
	_* (&& X*) is not allowed in non list symbol
	OK: variable opVariable
	Unknown symbol opErro (line78)
	Unknown symbol opError2 "opError2()"
	Warning: Ambiguous symbol name. Is`op0` a variable or a constructor? Prefer `op0`() if it is a constructor
	The symbol op0 has type `type0` but type `type2` was required
	The symbol op0 has type `type0` but type `type2` was required
	The symbol op0 has type `type0` but type `type2` was required "nested Appl"

////////////////////
VARIABLE DECLARATION
////////////////////
JVariable1.t
	Symbol method : 'x' not found: x()
JVariable2.t
JVariable3.t
JVariable4.t
JVariable5.t
JVariable6.t
	Variables are correctly extracted	
JVariable7.t
	Unknown variable(s) [a] used on right part of %rule
JVariable8.t
	Bad variable type for 'x': it has both type 'type2' and 'type1'
