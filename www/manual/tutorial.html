<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.06">
<TITLE>
 Tutorial and examples
</TITLE>
</HEAD>
<BODY TEXT=black BGCOLOR=white>
<A HREF="lib.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="manual.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<HR>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0f75ff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc25"><B><FONT SIZE=6>Chapter&nbsp;5</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6>Tutorial and examples</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>

<BR>
<BR>
On top of <FONT COLOR=navy>Tom</FONT> directory, you can find the tutorial directory where
all examples presented here can be found and ran.
The difficulties encountered in this tutorial is increasing with each
section and subsection. Most of the examples are based on Java and the
corresponding ATerm library for terms representation.
Each example can be ran using this default suite of commands:
<BR>
&gt; jtom Example.t
<BR>
&gt; javac Example.java
<BR>
&gt; java Example
<BR>
Extra commands are explain when necessary.<BR>
<BR>
<A NAME="toc16"></A><TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc26"><B><FONT SIZE=5>5.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Introduction to the ATerm library for Java</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
<BR>
ATerm is an abstract data type designed for tree-like data structures
representations.
More information on the C version is available at: 
<A HREF="http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/ATermLibrary">http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/ATermLibrary</A>.<BR>
<BR>
<A NAME="toc17"></A><TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc27"><B><FONT SIZE=5>5.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Peano integer</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
<BR>
The Peano integer formalism aims to represent integer as Zero or as the
successor of an integer Suc(int).<BR>
<BR>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.2.1</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Simple examples</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
<FONT COLOR=navy>Tom</FONT> allows to define such algebraic specifications. First, we define
the sort <FONT COLOR=purple>peano</FONT> and define the 2 operators: <FONT COLOR=purple>zero</FONT> and <FONT COLOR=purple>suc</FONT>.<BR>
<BR>
<A HREF="language.html#typedef"><FONT COLOR="#0000ff"><TT><B>%typeterm</B></TT></FONT></A> peano {<BR>
<BLOCKQUOTE>
 <A HREF="language.html#implement"><FONT COLOR="#0000ff"><TT>implement</TT></FONT></A>{ ATerm }<BR>
<A HREF="language.html#getfs"><FONT COLOR="#0000ff"><TT>get_fun_sym</TT></FONT></A>(t) { (((ATermAppl)t).getAFun()) }<BR>
<A HREF="language.html#cmpfs"><FONT COLOR="#0000ff"><TT>cmp_fun_sym</TT></FONT></A>(t1,t2) { t1 == t2 }<BR>
<A HREF="language.html#getsub"><FONT COLOR="#0000ff"><TT>get_subterm</TT></FONT></A>(t, n) { (((ATermAppl)t).getArgument(n)) }<BR>
</BLOCKQUOTE>
}<BR>
<BR>
<A HREF="language.html#opdef"><FONT COLOR="#0000ff"><TT><B>%op</B></TT></FONT></A> peano zero {<BR>
<BLOCKQUOTE>
<A HREF="language.html#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A>{ fzero }<BR>
</BLOCKQUOTE>
}<BR>
<BR>
<A HREF="language.html#opdef"><FONT COLOR="#0000ff"><TT><B>%op</B></TT></FONT></A> peano suc(term) {<BR>
<BLOCKQUOTE>
 <A HREF="language.html#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A>{ fsuc }<BR>
</BLOCKQUOTE>
}<BR>
This is the minimal material given to TOM to compile pattern matching
constructs on peano sort. In particular, the sort is map to ATerm java class
(see <A HREF="language.html#implement"><FONT COLOR="#0000ff"><TT>implement</TT></FONT></A>).
Once the operators are defined, let us consider a simple symbolic
computation (addition) defined on Peano integers.<BR>
<BR>
public ATerm plus(ATerm t1, ATerm t2) {<BR>
<BLOCKQUOTE>
 <A HREF="language.html#match"><FONT COLOR="#0000ff"><TT><B>%match</B></TT></FONT></A> (peano t1, peano t2) {<BR>
<BLOCKQUOTE>
 x,zero <B>-&gt;</B> { return x; }<BR>
x,suc(y) <B>-&gt;</B> { return suc(plus(x,y)); }<BR>
</BLOCKQUOTE>
 }<BR>
return null;<BR>
</BLOCKQUOTE>
}<BR>
Note: We can easily see that this match program is complete (We match
all possibilities) but we need to add a last return statement else
Java compiler will complain.<BR>
<BR>
By running the command:
<BR>
&gt; jtom Peano1;javac Peano1.java;java Peano1
<BR>
We get the result:
<BR>
plus(10,10) = suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(zero))))))))))))))))))))<BR>
<BR>
The peano integer 10 is created by hand using the instruction
<FONT COLOR=purple>for(int i=0 ; i&lt;n ; i++) { N = suc(N);}</FONT>and the defined java
suc function.<BR>
<BR>
The Peano2 examples shows how to map an algebraic sprcification to
another representation in the target language. So, in this second
example, you see that terms are <FONT COLOR=purple>implemented</FONT> by <B>ATermAppl</B> instead
of <B>ATerm</B>. This implementation choice will simplify the way
<A HREF="language.html#implement"><FONT COLOR="#0000ff"><TT>implement</TT></FONT></A>, <A HREF="language.html#getfs"><FONT COLOR="#0000ff"><TT>get_fun_sym</TT></FONT></A>, <A HREF="language.html#cmpfs"><FONT COLOR="#0000ff"><TT>cmp_fun_sym</TT></FONT></A> and <A HREF="language.html#getsub"><FONT COLOR="#0000ff"><TT>get_subterm</TT></FONT></A> are implemented (No more cast
needed).<BR>
<BR>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.2.2</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>What about with C language</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
A corresponding example to Peano1 can be found: cpeano.t.
To compile and run it, use:
<BR>
&gt;jtom -c cexample.t
<BR>
&gt; gcc cexample.c<BR>
<BR>
One of the major drawbcak in this example is the complexity of
defining terms in regard to previous examples using ATerm for Java. A
second example, cpeanofib, gives a more complex implementaion of
terms.
Of course, this is still simple in regard to the low complexity of
represented terms.<BR>
<BR>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.2.3</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Using Bacquote construct</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
The Peano3 examples illustrates the way the backquote construct can be
used to simplify term creation. This is realized by adding a
<FONT COLOR=purple>make</FONT> function to each defined operator. This way, the Java suc
function is no more usefull and is directly replace by the
corresponding <A HREF="language.html#make"><FONT COLOR="#0000ff"><TT>make</TT></FONT></A> in suc operator definition. <BR>
<BR>
<A HREF="language.html#opdef"><FONT COLOR="#0000ff"><TT><B>%op</B></TT></FONT></A> term zero {<BR>
<BLOCKQUOTE>
 <A HREF="language.html#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A>{ factory.makeAFun("zero",0,false) }<BR>
<A HREF="language.html#make"><FONT COLOR="#0000ff"><TT>make</TT></FONT></A>{ factory.makeAppl(factory.makeAFun("zero",0,false))}<BR>
</BLOCKQUOTE>
}<BR>
<A HREF="language.html#opdef"><FONT COLOR="#0000ff"><TT><B>%op</B></TT></FONT></A> term suc(term) {<BR>
<BLOCKQUOTE>
 <A HREF="language.html#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A> factory.makeAFun("suc",1,false)<BR>
<A HREF="language.html#make"><FONT COLOR="#0000ff"><TT>make</TT></FONT></A>(t)  factory.makeAppl(factory.makeAFun("suc",1,false),t)<BR>
</BLOCKQUOTE>
}<BR>
Then, the creation of the term representing the integer N become easy:<BR>
ATermAppl N = <A HREF="language.html#backquote"><FONT COLOR="#0000ff"><TT><B>`</B></TT></FONT></A>zero();
for(int i=0 ; i&lt;n ; i++) {<BR>
N = <A HREF="language.html#backquote"><FONT COLOR="#0000ff"><TT><B>`</B></TT></FONT></A>suc(N);<BR>
}<BR>
But, the Backquote construct is more powerfull. Indeed, it is
translated in a function call. This allows to write in the macth
construct:<BR>
<BR>
x,suc(y) -&gt;  return <A HREF="language.html#backquote"><FONT COLOR="#0000ff"><TT><B>`</B></TT></FONT></A>suc(plus(x,y)); <BR>
<BR>
The plus function we be called and its result will be passed to create
the successor term; Of course, this is correct because plus returns a
term expected by the successor operator: suc. Running <FONT COLOR=navy>Tom</FONT> on this
example leeds for a warning message saying that it can not inferate
type-checking for this construct, because it has no knowledge on plus
function. To avoid the warning messages, please use:
<BR>
&gt; jtom -W Peano3<BR>
<BR>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.2.4</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Advanced examples and more powerfull operators</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
As we see in previous examples, the operator definition can be
developped to simplify the use of <FONT COLOR=navy>Tom</FONT> main construct. We can also
supply others functions to specialized their default behavior defined
in the corresponding term definition.<BR>
<BR>
The Peano1 example shows this point:<BR>
<BR>
<A HREF="language.html#typedef"><FONT COLOR="#0000ff"><TT><B>%typeterm</B></TT></FONT></A>term {<BR>
<BLOCKQUOTE>
 <A HREF="language.html#implement"><FONT COLOR="#0000ff"><TT>implement</TT></FONT></A>{ ATermAppl }<BR>
<A HREF="language.html#getfs"><FONT COLOR="#0000ff"><TT>get_fun_sym</TT></FONT></A>(t) { null }<BR>
<A HREF="language.html#cmpfs"><FONT COLOR="#0000ff"><TT>cmp_fun_sym</TT></FONT></A>(t1,t2) { false }<BR>
<A HREF="language.html#getsub"><FONT COLOR="#0000ff"><TT>get_subterm</TT></FONT></A>(t, n) { null }<BR>
</BLOCKQUOTE>
}<BR>
<A HREF="language.html#opdef"><FONT COLOR="#0000ff"><TT><B>%op</B></TT></FONT></A>term zero {<BR>
<BLOCKQUOTE>
 <A HREF="language.html#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A>{ <FONT COLOR=purple>/* empty */</FONT> }<BR>
<A HREF="language.html#isfsym"><FONT COLOR="#0000ff"><TT>is_fsym</TT></FONT></A>(t) { t.getAFun() == factory.makeAFun("zero",0,false) }<BR>
<A HREF="language.html#make"><FONT COLOR="#0000ff"><TT>make</TT></FONT></A>{ factory.makeAppl(factory.makeAFun("zero",0,false)) }<BR>
</BLOCKQUOTE>
}<BR>
<A HREF="language.html#opdef"><FONT COLOR="#0000ff"><TT><B>%op</B></TT></FONT></A>term suc(pred:term) {<BR>
<BLOCKQUOTE>
 <A HREF="language.html#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A>{ <FONT COLOR=purple>/* empty */</FONT> }<BR>
<A HREF="language.html#isfsym"><FONT COLOR="#0000ff"><TT>is_fsym</TT></FONT></A>(t) { t.getAFun() == factory.makeAFun("suc",1,false) }<BR>
<A HREF="language.html#getslot"><FONT COLOR="#0000ff"><TT>get_slot</TT></FONT></A>(pred,t) { (ATermAppl)t.getArgument(0) }<BR>
<A HREF="language.html#make"><FONT COLOR="#0000ff"><TT>make</TT></FONT></A>(t) { factory.makeAppl(factory.makeAFun("suc",1,false),t) }<BR>
</BLOCKQUOTE>
}<BR>
<BR>
In the Peano2 example, we can see the facilities offered to extract
slot from match construct but also from term using defined slot names
or  facilities.<BR>
<BR>
public ATermAppl fib(ATermAppl t) {<BR>
<BLOCKQUOTE>
 <A HREF="language.html#match"><FONT COLOR="#0000ff"><TT><B>%match</B></TT></FONT></A>(term t) {<BR>
<BLOCKQUOTE>
 <FONT COLOR=purple>y@</FONT>zero -&gt; { return `suc( <FONT COLOR=purple>y</FONT>); }<BR>
<FONT COLOR=purple>y@</FONT>suc(zero) -&gt; { return <FONT COLOR=purple>y</FONT>; }<BR>
suc<FONT COLOR=purple>[pred=y@</FONT>suc(<FONT COLOR=purple>x</FONT>)<FONT COLOR=purple>]</FONT> -&gt; { return `plus(fib(<FONT COLOR=purple>x</FONT>),fib(<FONT COLOR=purple>y</FONT>)); }<BR>
</BLOCKQUOTE>
 }<BR>
return null;<BR>
</BLOCKQUOTE>
}<BR>
<A NAME="toc18"></A><TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc28"><B><FONT SIZE=5>5.3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Integer and Fibonacci</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
As seen in previous examples, all results leed to expression of the
result in Peano paradigm. <FONT COLOR=navy>Tom</FONT> offers a way to directly works with
integer.<BR>
<BR>
public class Jint {<BR>
<BLOCKQUOTE>
 <A HREF="language.html#int"><FONT COLOR="#0000ff"><TT><B>%typeint</B></TT></FONT></A><BR>
public final static void main(String[] args) {<BR>
Jint test = new Jint();<BR>
int res = test.fib(10);<BR>
System.out.println("res = " + res);<BR>
}<BR>
public int fib(int t) {<BR>
<BLOCKQUOTE>
 <A HREF="language.html#match"><FONT COLOR="#0000ff"><TT><B>%match</B></TT></FONT></A>(<FONT COLOR=purple>int t</FONT>) {<BR>
<FONT COLOR=purple>0</FONT> -&gt; { return 1; }<BR>
<FONT COLOR=purple>1</FONT> -&gt; { return 1; }<BR>
<FONT COLOR=purple>n</FONT> -&gt; { return fib(n-1) + fib(n-2); }<BR>
}<BR>
</BLOCKQUOTE>
 }<BR>
</BLOCKQUOTE>
}<BR>
<A NAME="toc19"></A><TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc29"><B><FONT SIZE=5>5.4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>List</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
<BR>
<FONT COLOR=navy>Tom</FONT> allows to work on list representation of terms.
2 examples are available to show how to use either <A HREF="language.html#listdef"><FONT COLOR="#0000ff"><TT><B>%typelist</B></TT></FONT></A> either <A HREF="language.html#arraydef"><FONT COLOR="#0000ff"><TT><B>%typearray</B></TT></FONT></A> and their
associated creator operator: <A HREF="language.html#oplistdef"><FONT COLOR="#0000ff"><TT><B>%oplist</B></TT></FONT></A> and <A HREF="language.html#oparraydef"><FONT COLOR="#0000ff"><TT><B>%oparray</B></TT></FONT></A>.<BR>
<BR>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.4.1</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Defining List</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
<BR>
<A HREF="language.html#listdef"><FONT COLOR="#0000ff"><TT><B>%typelist</B></TT></FONT></A>TomList {<BR>
<BLOCKQUOTE>
 <A HREF="language.html#implement"><FONT COLOR="#0000ff"><TT>implement</TT></FONT></A>{ ATermList }<BR>
<A HREF="language.html#getfs"><FONT COLOR="#0000ff"><TT>get_fun_sym</TT></FONT></A>(t) { ((t instanceof ATermList)?factory.makeAFun("conc", 1, false):null) }<BR>
<A HREF="language.html#cmpfs"><FONT COLOR="#0000ff"><TT>cmp_fun_sym</TT></FONT></A>(t1,t2) { t1 == t2 }<BR>
<A HREF="language.html#equals"><FONT COLOR="#0000ff"><TT>equals</TT></FONT></A>(l1,l2) { l1==l2 }<BR>
<A HREF="language.html#geth"><FONT COLOR="#0000ff"><TT>get_head</TT></FONT></A>(l) { l.getFirst() }<BR>
<A HREF="language.html#gett"><FONT COLOR="#0000ff"><TT>get_tail</TT></FONT></A>(l) { l.getNext() }<BR>
<A HREF="language.html#isempty"><FONT COLOR="#0000ff"><TT>is_empty</TT></FONT></A>(l) { l.isEmpty() }<BR>
</BLOCKQUOTE>
 }<BR>
<A HREF="language.html#oplistdef"><FONT COLOR="#0000ff"><TT><B>%oplist</B></TT></FONT></A>TomList conc( TomTerm* ) {<BR>
<BLOCKQUOTE>
 <A HREF="language.html#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A>{ factory.makeAFun("conc", 1, false) }<BR>
<A HREF="language.html#emptylist"><FONT COLOR="#0000ff"><TT>make_empty</TT></FONT></A>() { factory.makeList() }<BR>
<A HREF="language.html#insert"><FONT COLOR="#0000ff"><TT>make_insert</TT></FONT></A>(e,l) { l.insert(e) }<BR>
</BLOCKQUOTE>
}<BR>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.4.2</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Defining Array</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
<BR>
<A HREF="language.html#arraydef"><FONT COLOR="#0000ff"><TT><B>%typearray</B></TT></FONT></A>TomArray {<BR>
<A HREF="language.html#implement"><FONT COLOR="#0000ff"><TT>implement</TT></FONT></A>{ ArrayList }<BR>
<BLOCKQUOTE>
 <A HREF="language.html#getfs"><FONT COLOR="#0000ff"><TT>get_fun_sym</TT></FONT></A>(t) { ((t instanceof ArrayList)?factory.makeAFun("conc", 1, false):null) }<BR>
<A HREF="language.html#cmpfs"><FONT COLOR="#0000ff"><TT>cmp_fun_sym</TT></FONT></A>(t1,t2) { t1 == t2 }<BR>
<A HREF="language.html#equals"><FONT COLOR="#0000ff"><TT>equals</TT></FONT></A>(l1,l2) { l1.equals(l2) }<BR>
<A HREF="language.html#gete"><FONT COLOR="#0000ff"><TT>get_element</TT></FONT></A>(l,n) { l.get(n) }<BR>
<A HREF="language.html#getsize"><FONT COLOR="#0000ff"><TT>get_size</TT></FONT></A>(l) { l.size() }<BR>
</BLOCKQUOTE>
}<BR>
<A HREF="language.html#oparraydef"><FONT COLOR="#0000ff"><TT><B>%oparray</B></TT></FONT></A>TomArray conc( TomTerm* ) {<BR>
<BLOCKQUOTE>
 <A HREF="language.html#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A>{ factory.makeAFun("conc", 1, false) }<BR>
<A HREF="language.html#emptyarray"><FONT COLOR="#0000ff"><TT>make_empty</TT></FONT></A>(n) { myEmpty(n) }<BR>
<A HREF="language.html#append"><FONT COLOR="#0000ff"><TT>make_append</TT></FONT></A>(e,l) { myAdd(e,(ArrayList)l) }<BR>
</BLOCKQUOTE>
}<BR>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.4.3</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Swapsort and the power of <FONT COLOR=navy>Tom</FONT></FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
The 2 examples are very similar and allow to define 2 functions:
swapSort and removeDouble ina very efficient way.
<BR>
Have a look to swapSort function definition in List2.t (with array):<BR>
<BR>
public ArrayList swapSort(ArrayList l) {<BR>
<A HREF="language.html#match"><FONT COLOR="#0000ff"><TT><B>%match</B></TT></FONT></A>(TomList l) {<BR>
<BLOCKQUOTE>
 <FONT COLOR=purple>conc(X1*,x,X2*,y,X3*)</FONT> -&gt; {<BR>
<BLOCKQUOTE>
 String xname = x.getName();String yname = y.getName();<BR>
<FONT COLOR=purple>if(xname.compareTo(yname) &gt; 0)   return `swapSort(conc(X1*,y,X2*,x,X3*));</FONT><BR>
</BLOCKQUOTE> 
}<BR>
</BLOCKQUOTE> 
}<BR>
The compilation of the Match construct allows to generate all
combinations on the list parameter until it found the entered pattern.
Using a Backquote construct allows to naturally recursively call the
defined function!!!!!<BR>
<BR>
<A NAME="toc20"></A><TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc30"><B><FONT SIZE=5>5.5</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Apigen and the automatic generation of term representation</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
One of the more difficult stuff in writting <FONT COLOR=navy>Tom</FONT> program is to write
all stuff concerning term definitions. To help developpers, a usefull
tools called Apigen is available at <A HREF="http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/PackageBase">CWI package
 base Page</A> and use by <FONT COLOR=navy>Tom</FONT> developpers.
This tools take an abstract data type file called ADT file and
generate C or Java data-types that hide the ATerm library behind a
typed API.
For <FONT COLOR=navy>Tom</FONT>, it generates more than 300 java files to defining all used
<FONT COLOR=navy>Tom</FONT> structures.
For installing Apigen, see the <A HREF="install.html#developpers">developpers sections
 on install manual</A>.<BR>
<BR>
Both Java and C examples have an associated README file where you can
found compilation instructions.<BR>
<BR>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.5.1</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Description of Apigen</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
Full documentation on Apigen can be found at <A HREF="http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/ApiGen">http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/ApiGen</A>.
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.5.2</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Java example</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
All generated file<BR>
<BR>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.5.3</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>C example</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><BR>
<A NAME="toc21"></A><TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc31"><B><FONT SIZE=5>5.6</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5><FONT COLOR=navy>Tom</FONT></FONT></B><B><FONT SIZE=5> runtime and Mathematical expression</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
This last example combines all previous items in a single problem:
Derivation and simplification of mathematical expressions. But, it
also introduces the way the runtime library can be used.<BR>
<BR>
<A NAME="toc22"></A><TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc32"><B><FONT SIZE=5>5.7</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Debugging <FONT COLOR=navy>Tom</FONT></FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
<BR>
<HR>
<A HREF="lib.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="manual.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
</BODY>
</HTML>
