package fr.loria.eclipse.jtom.mappinggenerator;

/* Generated by TOM (version 2.6rc1): Do not edit this file */import java.io.*;
import java.lang.reflect.Method;
import java.net.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;

public class TomMappingGenerator {

  public static void main(String[] args) throws IOException {
    if (args.length < 2) {
      System.out.println("\r\nUsage: java TomMappingGenerator startPoint mappingsFileName [includeInClasspath]\r\n\r\nwhere:\r\n  startPoint            = a folder name (or a file name) to generate the mappings for (can be full paths or relative to TomMappingGenerator). If this is a folder, mappings are generated recursively for all contained classes.\r\n\r\n  mappingsFileName      = destination file name for the mappings (can be a full path or relative to TomMappingGenerator).\r\n\r\n  includeInClasspath    = a ; separated string that contains full paths to folders, jars or class names to include in CLASSPATH if needed  \r\n                            \r\n"









);
      System.exit(0);
    }
    TomMappingGenerator gen = new TomMappingGenerator();
    if ( args.length > 2 ) {
      gen.generateFromRelativePaths(args[0], args[1], args[2]);
    }else{
      gen.generateFromRelativePaths(args[0], args[1], null);
    }
  }

  /**
  * Launches the generator from relative paths
  *
  * @param startPoint full or relative (to this current class) name of the start point
  * @param mappingsFileName full or relative (to this current class) name of the mapping file to generate
  * @param includeInClasspath the path to include into classpath when searching for classes
  */
  public void generateFromRelativePaths(String startPoint, String mappingsFileName, String includeInClassPath) throws IOException {

    File startPointFile = new File(startPoint);
    if (!startPointFile.exists()){

      if (startPointFile.isAbsolute()){
        throw new FileNotFoundException("Unable to resolve start path '" + startPoint + "'.");
      }

      File currentClassFile = new File(getPath());       
      String parentPath = currentClassFile.getParent();
      String startPointFullPath = null;
      String baseFolder = null;
      if (parentPath != null) { 
        baseFolder = (new File(parentPath)).getCanonicalPath() + File.separator;
        startPointFullPath = baseFolder + startPoint;        
      } else {
        startPointFullPath = startPoint;
      }

      startPointFile = new File(startPointFullPath);
      if (!startPointFile.exists()) {
        throw new FileNotFoundException("Unable to resolve start path '" + startPointFullPath + "').");
      }  

      File mappingsFile = new File(mappingsFileName);
      if (!mappingsFile.isAbsolute()){
        mappingsFileName = baseFolder + mappingsFileName;
      }
    }
    generate(startPointFile, mappingsFileName, includeInClassPath);
  }

  /**
  * Launches the generator from full paths (it assumes that the paths received are correct)
  *
  * @param startPoint the File object for the start point (this method assumes that the file exists)
  * @param mappingsFileName the full name of the mapping file to generate
  * @param includeInClasspath the path to include into classpath when searching for classes
  *     
  */
  public void generate(File startPoint, String mappingsFileName, String includeInClasspath) throws IOException {

    Writer writer = null;    
    StringBuilder strBuilder = new StringBuilder("%include { util/types/Collection.tom }\n");
    try {
      // the types used in operator declaration
      HashMap<String, Class<?>> usedTypes = new HashMap<String, Class<?>>();
      // the types declared
      HashMap<String, Class<?>> declaredTypes = new HashMap<String, Class<?>>();      
      generate(startPoint, strBuilder, usedTypes, declaredTypes, getURLPathsFromString(includeInClasspath));
      // generate a mapping for each used type that was not declared
      // make sure it is not declared twice
      ArrayList<String> processed = new ArrayList<String>();
      for(String usedTypeName: usedTypes.keySet()){
        if (processed.contains(usedTypeName)) { continue; }
        processed.add(usedTypeName);
        Class usedTypeClass = usedTypes.get(usedTypeName);
        if (!declaredTypes.containsKey(usedTypeName) && !Collection.class.equals(usedTypeClass)){
          if (usedTypeClass.isPrimitive()){
            strBuilder.insert(0, "%include { " + usedTypeClass.getName() + ".tom }\n");
          } else {
            // generate %typeterm
            generateTypeTerm(usedTypeClass, strBuilder, declaredTypes);
          }
        }
      }  
      // add 'myAdd' method
      strBuilder.append("      \r\nprivate static java.util.List myAdd(Object e,java.util.List l) {\r\n  l.add(e);\r\n  return l;\r\n}\r\n"




);      
      writer = new BufferedWriter(new FileWriter(mappingsFileName));
      writer.append(strBuilder.toString());
    } catch (Exception e) {
      System.out.println("An error occured:"  + e.getMessage());
      e.printStackTrace();
    } finally {
      if (writer != null){
        writer.flush();
        writer.close();
      }
    }
  }

  private void generate(File startPointFile, StringBuilder strBuilder, HashMap<String, Class<?>> usedTypes,
      HashMap<String, Class<?>> declaredTypes, URL[] includeInClasspath) throws IOException, ClassNotFoundException {
    if (startPointFile.isDirectory()) {
      File[] files = startPointFile.listFiles();
      for (File file : files) {
        generate(file, strBuilder, usedTypes, declaredTypes, includeInClasspath);
      }
    } else {
      // ignore everything that is not a class (including the inner classes)
      if (!startPointFile.getName().endsWith(".class") || startPointFile.getName().contains("$")) {
        return;
      }
      System.out.print("Extracting mapping for:" + startPointFile.getName() + " ... ");      
      try {
        extractMapping((new MGClassLoader(includeInClasspath)).getClassObj(startPointFile), strBuilder, usedTypes, declaredTypes);
      } catch (NoClassDefFoundError e) {
        System.out.println("\nThe following class couldn't be found: " + e.getMessage());
        if (e.getCause() != null) {System.out.println("Cause: " + e.getCause().getMessage());}      
      } catch (Throwable e) {
        System.out.println("\nAn error occured while extracting the mapping: " + e.getMessage());
        if (e.getCause() != null) {System.out.println("Cause: " + e.getCause().getMessage());}
      }
      System.out.println("Done !");
    }
  }


  private void extractMapping(Class classObj, StringBuilder strBuilder, HashMap<String, Class<?>> usedTypes,
      HashMap<String, Class<?>> declaredTypes) throws ClassNotFoundException, IOException {    
    strBuilder.append("\n/*******************************************************************************/\n");    
    // generate %typeterm
    generateTypeTerm(classObj, strBuilder, declaredTypes);
    // generate %op    
    try{ // sometimes getMethods throws a NullPointerException
        generateOperator(classObj, strBuilder, usedTypes);    
    } catch ( NullPointerException e ) {
      System.out.println("\n An %op couldn't be generated");
    } 
    // generate %oparray (only for base classes)
    if (Object.class.equals(classObj.getSuperclass())) {
      generateOpArray(classObj.getName(), strBuilder);
    }
  }

  private void generateTypeTerm(Class classFName, StringBuilder strBuilder, HashMap<String, Class<?>> declaredTypes){
    String className = classFName.getName().substring(classFName.getName().lastIndexOf('.') + 1);
    // handle inner classes
    if (className.contains("$")) { className = className.substring(className.indexOf("$")+1); }
    String fullClassName = classFName.getName();
    if (fullClassName.contains("$")) { fullClassName = fullClassName.replace("$", "."); }
    declaredTypes.put(fullClassName,classFName);
    strBuilder.append("\r\n%typeterm "/* Generated by TOM (version 2.6rc1): Do not edit this file */+className+" {\r\n  implement     { "/* Generated by TOM (version 2.6rc1): Do not edit this file */+fullClassName+" }\r\n  is_sort(t)    { $t instanceof "/* Generated by TOM (version 2.6rc1): Do not edit this file */+fullClassName+" }\r\n  equals(t1,t2) { $t1.equals($t2) }      \r\n}\r\n"





);
  }

  private void generateOperator(Class classFName, StringBuilder strBuilder, HashMap<String, Class<?>> usedTypes){
    String fullClassName = classFName.getName();
    String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1);
    Method[] methods = classFName.getMethods();    
    // find the class that is the highest in the hierarchy
    Class superClass = null;    
    while(classFName.getSuperclass() != null && !Object.class.equals(classFName.getSuperclass()) ) {      
      superClass = classFName.getSuperclass();
      classFName = superClass;
    }
    String codomain = null;
    // if we have some super class
    if(superClass != null) {
      codomain = superClass.getName().substring(superClass.getName().lastIndexOf('.') + 1);
      usedTypes.put(superClass.getName(),superClass);
    }else{
      codomain = className;
      usedTypes.put(classFName.getName(),classFName);
    }
    strBuilder.append("\r\n%op "/* Generated by TOM (version 2.6rc1): Do not edit this file */+codomain+" "/* Generated by TOM (version 2.6rc1): Do not edit this file */+className+"("/* Generated by TOM (version 2.6rc1): Do not edit this file */+getFieldsDeclarations(methods,usedTypes)+") {\r\n  is_fsym(t)                { $t instanceof "/* Generated by TOM (version 2.6rc1): Do not edit this file */+fullClassName+" } "/* Generated by TOM (version 2.6rc1): Do not edit this file */+getSlotDeclarations(methods,className)+"     \r\n}\r\n"



);
  }

  private String getFieldsDeclarations(Method[] methods, HashMap<String, Class<?>> usedTypes) {
    StringBuilder result = new StringBuilder();
    // avoids declaring twice the same field (in case we have 2 getters for the same field)
    ArrayList<String> declaredFields = new ArrayList<String>(); 
    for (Method m : methods) {
      // not a 'get' or an 'is'
      String methodName = m.getName();
      if (!methodName.startsWith("get") && !methodName.startsWith("is")) {
        continue;
      }
      // ignore arrays for the moment
      if (m.getReturnType().isArray()) { continue; }
      
      String fieldName = methodName.startsWith("get") ? methodName.substring(3) : methodName.substring(2);
      fieldName = Character.toLowerCase(fieldName.charAt(0)) + fieldName.substring(1);
      if ("class".equalsIgnoreCase(fieldName) || declaredFields.contains(fieldName)) {
        continue;
      }
      declaredFields.add(fieldName);
      result.append(fieldName + ":");
      if (m.getReturnType().isPrimitive()) {
        result.append(m.getReturnType().getName());
      } else {        
        String tmp = m.getReturnType().getName().substring(m.getReturnType().getName().lastIndexOf('.') + 1);
        tmp = tmp.substring(tmp.indexOf('$') + 1); // for inner classes, eliminate the parent class name
        result.append(tmp);
      }
      usedTypes.put(m.getReturnType().getName(),m.getReturnType());
      result.append(",");
    }
    // remove the ","
    String finalString = result.toString();
    return (finalString == null || "".equals(finalString)) ? "" : finalString.substring(0, finalString.length() - 1);
  }

  private String getSlotDeclarations(Method[] methods, String className){
    StringBuilder result = new StringBuilder();
    // avoids declaring twice the same slot (in case we have 2 getters for the same field)
    ArrayList<String> declaredFields = new ArrayList<String>(); 
    for(Method m: methods){
      // not a 'get' or an 'is'
      String methodName = m.getName();
      if (!methodName.startsWith("get") && !methodName.startsWith("is")) { continue; };
      String fieldName = methodName.startsWith("get") ? methodName.substring(3) : methodName.substring(2);      
      fieldName = Character.toLowerCase(fieldName.charAt(0)) +  fieldName.substring(1);
      if ("class".equalsIgnoreCase(fieldName) || declaredFields.contains(fieldName)) { continue; }
      // ignore arrays for the moment
      if (m.getReturnType().isArray()) { continue; }
      declaredFields.add(fieldName);
      result.append("\r\n  get_slot("/* Generated by TOM (version 2.6rc1): Do not edit this file */+fieldName+", t)  { (("/* Generated by TOM (version 2.6rc1): Do not edit this file */+className+")$t)."/* Generated by TOM (version 2.6rc1): Do not edit this file */+methodName+"() }"
);    
    }
    return result.toString(); 
  }

  private void generateOpArray(String className, StringBuilder strBuilder){
    className = className.substring(className.lastIndexOf('.') + 1);
    String opName = Character.toLowerCase(className.charAt(0)) +  className.substring(1); 
    strBuilder.append(" \r\n%typeterm "/* Generated by TOM (version 2.6rc1): Do not edit this file */+className+"List {\r\n  implement                 { java.util.List<"/* Generated by TOM (version 2.6rc1): Do not edit this file */+className+"> }\r\n  is_sort(t)                { t instanceof java.util.List }\r\n  equals(t1,t2)             { t1.equals(t2) }\r\n}\r\n\r\n%oparray "/* Generated by TOM (version 2.6rc1): Do not edit this file */+className+"List "/* Generated by TOM (version 2.6rc1): Do not edit this file */+opName+"List("/* Generated by TOM (version 2.6rc1): Do not edit this file */+className+"*) {\r\n  is_fsym(t)                { t instanceof java.util.List  }\r\n  make_empty(n)             { new java.util.ArrayList<"/* Generated by TOM (version 2.6rc1): Do not edit this file */+className+">(n) }\r\n  make_append(e,l)          { (java.util.ArrayList<"/* Generated by TOM (version 2.6rc1): Do not edit this file */+className+">)myAdd(e,l)  }\r\n  get_element(l,n)          { l.get(n)        }\r\n  get_size(l)               { l.size()                }\r\n} \r\n"













); 
  }

  private String getPath() {
    String className = getClass().getName();
    return ClassLoader.getSystemResource(className + ".class").getPath();
  }

  /**
  * 
  * @param a string containing classpath entries separated by ; 
  * @return an array of URLs obtained from the string received 
  */
  private URL[] getURLPathsFromString(String pathString){
    if (pathString == null) { return new URL[0];}
    String[] paths = pathString.split(";");
    URL[] result = new URL[paths.length];
    int j = 0;
    for(String path:paths){
      File file = new File(path);
      if (!file.exists()){
        System.out.println("Couldn't find location: " + path);
      }else{
        try{
          result[j] = file.toURL();
          j++;
        } catch(MalformedURLException e){
          System.out.println("Couldn't transform to url: " + path);
          j--;
        }
      }
    }
    return result;
  }
}



