// Licence
package tom.mapping.dsl.generator

import com.google.inject.Inject
import java.util.List
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.generator.IFileSystemAccess
import tom.mapping.dsl.generator.tom.OperatorsCompiler
import tom.mapping.dsl.generator.tom.TomFactoryCompiler
import tom.mapping.model.ClassOperator
import tom.mapping.model.FeatureParameter
import tom.mapping.model.Mapping
import tom.mapping.model.Operator
import tom.mapping.model.Parameter

class FactoryCompiler {
	
	extension TomMappingExtensions = new TomMappingExtensions()
	extension NamingCompiler = new NamingCompiler()
	
	@Inject TomFactoryCompiler tfc
	@Inject ImportsCompiler imc
	@Inject Parameter injpa
	@Inject OperatorsCompiler injop
	
	String prefix=""
	
	def compile(Mapping m, IFileSystemAccess fsa){
		fsa.generateFile(packageToPath(prefix)+"/"+m.name.toFirstLower()+"/"+m.factoryName()+".java", m.main())
		}
	
	def main(Mapping map) {
		 tfc.main(map); // Erreur qui dispara”tra lorsque TomFactoryCompiler sera terminŽe
		 
		 '''
		 package Â«getPackagePrefix(prefix)Â»Â«map.name.toFirstLower()Â»;
		 
		 import java.util.List;
		 
		 /* PROTECTED REGION ID(map.name+"_user_factory_imports") ENABLED START */
		 // protected imports, you should add here required imports
		 // that won't be removed after regeneration of the mapping code
		 
		 Â«imc.imports(map)Â»;
		 
		 /* PROTECTED REGION END */
		 
		 /**
		 * User factory for "name"
		 * -- Generated by TOM mapping EMF generator --
		 */
		 
		 public class Â«map.factoryName()Â» {
		 	
		 	/* PROTECTED REGION ID(map.name+"_user_factory_instances") ENABLED START */
		 	
		 	Â«var packageList = operators.typeSelect(ClassOperator).collect[e | e.class_.EPackage]Â»;		!!!!! FAIL ICI !!!!!
		 	Â«for(package :packageList.intersect(packageList))Â» {
		 		public static Â«package.name.toFirstUpper()Â»Factory Â«package.nameÂ»Factory = Â«package.name.toFirstUpper()Â»Factory.eINSTANCE;
		 	}
		 	
		 	Â«var packageList = map.allDefaultOperators.filter[e | e.EPackage]Â»;								!!!!! FAIL ICI !!!!!
		 	Â«for(package: packageList.reject[e | packageList.select(f | e.name == f.name && e!= f])Â» {
		 		public static Â«package.name.toFirstUpper()Â»Factory Â«package.nameÂ»Factory = Â«package.name.toFirstUpper()Â»Factory.eINSTANCE;
		 	}
		 }
		 
		 /* PROTECTED REGION END */
		 
		 // User operators Â«operatorsÂ»
		 Â«for(module: map.modules)Â»{
		 	/** Module Â«module.nameÂ» **/
		 Â«for(op: module.operators){
		 	// Operator Â«op.nameÂ»;
		 	operator(map, op);
		 }Â» }
		 
		 /*
		 * Default TOM Operators for Â«nameÂ» mappin. Each class that has a terminal type has also a default factory function.
		 */
		 
		 Â«for(op: map.allDefaultsOperators)Â» {
		 	Â«javaFactoryCreateDefaultOperator(map,op.name, op)Â»;
		 }
		 
		 /* PROTECTED REGION ID(map.name+"_mapping_user_custom_methods"+map.name) ENABLED START */
		 
		 /*
		 * Custom factory functions that won't be removed at regeneration of mapping code
		 */
		 
		 /* PROTECTED REGION END */
		 '''	 
	}
	

	def operator(Mapping map, Operator op) {}
	
	def operator(Mapping map, ClassOperator clop) {
		if(clop.parameters.size>0) {
			val parameters = getCustomParameters(clop);
			javaFactoryCreateOperatorWithParameters(clop.parameters, clop); // Pourquoi le "parameters" seul ne fonctionne pas ?
		} else {
			javaFactoryCreateDefaultOperator(map, clop.name, clop.class_)
		}
	}
	
	
	def javaFactoryCreateOperatorWithParameters(List<FeatureParameter> parameters, ClassOperator clop) {
		'''
		public static Â«clop.class_.nameÂ» Â«name.toFirstLower()Â»(Â«for(p: parametersÂ») {Â«injpa.javaFeatureParameters(p)Â») } {		!!!!! SEPARATORS ? !!!!!
			Â«clop.class_.nameÂ» o = Â«clop.class_.EPackage.nameÂ»Factory.createÂ«clop.class_.name.toFirstUpper()Â»();
			Â«for(p: parameters)Â» {
				Â«structureFeatureSetter(p.feature)Â»;
			}
			for(p: getSettedCustomParameters()){
				o.setÂ«p.feature.name.toFirstUpper()Â»(Â«injop.settedValue(p.feature, p.value)Â»);
			}
			return o;
			}
		'''
	}
	
	
	def javaFactoryCreateDefaultOperator(Mapping mapping, String name, EClass ecl) {
		val parameters = getDefaultParameters(ecl,mapping);
		if(!ecl.abstract && !ecl.interface) {
			'''
			public static Â«ecl.nameÂ» Â«name.toFirstLower()Â»(injop.javaClassAttributes(mapping, ecl); Â«for(param: parameters)Â»{Â«injpa.defaultJavaFeatureParameter(param)Â»;} {		!!!!! SEPARATORS ? !!!!!
				Â«ecl.nameÂ» o = Â«EPackage.nameÂ»Factory.create.Â«ecl.name.toFirstUpper()Â»();
				Â«for(attribute EAllAttributes)Â» {
					Â«structureFeatureSetter(attribute)Â»;
				}
				Â«for(param: parameters)Â» {
					Â«structureFeatureSetter(param)Â»;
				}
			return o;
			}
			'''
		}
	}
	
	
	def structureFeatureSetter(EStructuralFeature esf){
		if(esf.many){
			if(esf.unsettable){
				'''
				for(int i = 0 ; i < Â«esf.nameÂ».size() ; ++i) {
					o.getÂ«name.toFirstUpper()Â»().add(_Â«nameÂ».get(i));
				}
				'''
				
				} else {
					'''
					Â«if(esf.unsettable)Â» {
						o.setÂ«name.toFirstUpper()Â»(_Â«nameÂ»);
					}
				'''
			}
		}
	}

	
}