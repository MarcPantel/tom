//Licence
package tom.mapping.dsl.generator.tom

import com.google.inject.Inject
import org.eclipse.xtext.generator.IFileSystemAccess
import tom.mapping.dsl.generator.ImportsCompiler
import tom.mapping.dsl.generator.TomMappingExtensions
import tom.mapping.model.ClassOperator
import tom.mapping.model.Mapping

class TomFactoryCompiler {
	
	extension TomMappingExtensions = new TomMappingExtensions()
	
	String prefix = "tom"
	
	@Inject OperatorsCompiler injop
	@Inject ImportsCompiler injco
	@Inject ParametersCompiler injpa
	
	def compile(Mapping m, IFileSystemAccess fsa) {
		fsa.generateFile(prefix+"/"+m.name.toFirstLower()+"/internal/"+m.tomFactoryName()+".java", m.main());
	}
	
	def main(Mapping map){
	'''
	 package «prefix.getPackagePrefix()»«map.name.toFirstLower()».internal;
	 
	 /* PROTECTED REGION ID(map.name+"_tom_factory_imports") ENABLED START */
	 // protected imports, you should add here required imports that won't be removed after regeneration of the maping code
	  
	 import java.util.List 
	  
	 «injco.imports(map)»
	 /* ENDPROTECT */
	 
	 /**
	 * Factory used by TOM for «map.name» mapping.
	 * It shouldn't be visible outside of the plugin
	 * -- Generated by TOM mapping EMF generator --
	 */
	 
	 
	 public class «map.tomFactoryName()» {
	 	
	 	/* PROTECTED REGION ID(map.name+"_tom_factory_instances") ENABLED START */
	 	
	 	«val packageList = map.operators.filter[j | j instanceof ClassOperator].reduce[e | e.class_.EPackage]»
	 	«FOR pack: packageList.filter[!e | packageList].filter[f | e.name == f.name && e!=f]»
	 		public static «pack.name.toFirstUpper()»Factory «pack.name»Factory = «pack.name.toFirstUpper())»Factory.eINSTANCE;
	 	«ENDFOR»
	 	
	 	«val packageList = map.allDefaultOperators.collect(e | e.EPackage);»
	 	«FOR pack: packageList.filter[!e | packageList.filter[f | e.name == f.name && e!=f]]»
	 		public static «pack.name.toFirstUpper()»Factory «pack.name»Factory = «pack.name.toFirstUpper())»Factory.eINSTANCE;
	 	«ENDFOR»
	 }
	 	/* ENDPROTECT */
	 
	 
	 // User operators «map.operators»
	 
	 «FOR module: map.modules»
	 	/** Module «module.name» **/
	 	«FOR op: module.operators»
	 		// Operator «op.name»
	 		«operator(map,op);»
	 	«ENDFOR»
	 «ENDFOR»
	 
	 /*
	 * Default TOM operators for «map.name» mapping. Each class that has a terminal type has aloso a default create function.
	 */
	 
	 «FOR op: map.allDefaultOperators»
	 	«IF !op.instanceClassName.contains("java.util.Map$Entry")»
	 		«javaFactoryCreateDefaultOperator(map,op.name,op)»
	 	«ENDIF»
	 «ENDFOR»
	 '''
	} 


	def operator(Mapping mapping, Operator op) {
		'''// «op.eClass().name»'''
	}

	
	def operator(Mapping mapping, ClassOperator clop) {
		if(clop.parameters.size>0) {
			val parameters = getCustomParameters(clop) as List<FeatureParameter>;
			javaFactoryCreateOperatorWithParameters(parameters, mapping, clop);
		} else {
			javaFactoryCreateDefaultOperator(mapping, clop.name, clop.class_);
		}
	}


	def javaFactoryCreateOperatorWithParameters(List[FeatureParameter] parameters, Mapping mapping, ClassOperator clop) {
	'''	
	// CreateOperatorWithParameters «clop.name»
	public static «clop.class_.name» create«clop.name.toFirstUpper()»(«FOR p: parameters SEPARATOR ","»«typeOfParameter(mapping, p.feature)» _«p.feature.name»«ENDFOR») {
		«clop.class_.name» o = «clop.class_.EPackage.name»Factory.create«clop.class_.name.toFirstUpper()»();
		«FOR p: parameters»
			«structureFeatureSetter(p.feature)»
		«ENDFOR»
		«FOR p: clop.getSettedCustomParameters())»
			o.set«p.feature.name.toFirstUpper()»(«injop.settedValue(p.feature, p.value)»
		«ENDFOR»
		return o;
	}
	'''
	}
	
	
	def javaFactoryCreateDefaultOperator(Mapping mapping, String name, EClass ecl) {
		val parameters = getDefaultParameters(ecl,mapping);
		'''
		// CreateDefaultOperator «ecl.name»
		public static «ecl.name» create«ecl.name.toFirstUpper()»(«injop.javaClassAttributes(mapping, ecl)»
		«FOR p: parameters SEPARATOR ","»«typeOfParameter(mapping, p)» _«p.name»«ENDFOR») {
			«ecl.name» o = «EPackage.name»Factory create«ecl.name.toFirstUpper()»();
			«FOR attribute: ecl.EAllAttributes»
				«structureFeatureSetter(attribute)»
			«ENDFOR»
		«FOR param: parameters»
			«structureFeatureSetter(param)»
		«ENDFOR»
		return o;
		}
		'''
	}
	
	
	def structureFeatureSetter(EStructuralFeature esf) {
		if(esf.many) {
			'''
			for(int i=0; i<_«esf.name».size(); i++) {
				o.get«name.toFirstUpper()»().add(«featureAccess(esf)».get(i));
			}
			'''
		} else {
			'''
			o.set«ecl.name.toFirstUpper()»(«featureAccess(esf)»);
			'''
		}
	}
	
	
	def featureAccess(EStructuralFeature esf) {
		'''
		«IF esf.EType.instanceTypeName == null»
			(«esf.EType.name»)
			«ENDIF»
			_«esf.name»
			'''
	}
	
	
	def typeOfParameter(Mapping mapping, EStructuralFeature esf) {}
	
	def dispatch typeOfParameter(Mapping mapping, EReference eref) {terminalTypeName(mapping, eref.many, eref.EType);}
	
	def dispatch typeOfParameter(Mapping mapping, EEnum enu) {enu.name;}
	
	def typeOfParameters(Mapping mapping, EAttribute eat) {injpa.primitiveType(eat.EAttributeType);}
	
	
	def dispatch terminalTypeName(Mapping mapping, boolean many, EClassifier ecl) {
		'''«IF ecl.many»List<«ENDIF»«ecl.name»«IF ecl.many»>«ENDIF»'''
	}
	
	def dispatch terminalTypeName(Mapping mapping, boolean many, EClass ecl) {
		'''«IF ecl.many»List<«ENDIF»«mapping.getTerminal(ecl,false).class_.name»«IF ecl.many»>«ENDIF»'''
	}


	def javaClassAttributes(Mapping mapping, EClass ecl) {
		'''
		«FOR att: ecl.EAllAttributes SEPARATOR ","»
			«typeOfParameter(mapping, att)» _«att.name»
		«ENDFOR»
		«IF ecl.EAllAttribute.size > 0 && ecl.getDefaultParameters(mapping).size > 0»,«ENDIF»
		'''
	}
	
}