/*
 * generated by Xtext
 */
package tom.mapping.dsl.scoping;

import java.util.ArrayList;
import java.util.Collection;

import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EEnumLiteral;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.scoping.impl.SimpleScope;

import tom.mapping.model.ClassOperator;
import tom.mapping.model.Mapping;
import tom.mapping.model.SettedFeatureParameter;
import tom.mapping.model.Terminal;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 * 
 */
public class TomMappingScopeProvider extends AbstractDeclarativeScopeProvider {

	static boolean verbose=true;

	public IScope scope_FeatureParameter_feature(ClassOperator op,EReference ref) {
		Collection<IEObjectDescription> result = new ArrayList<IEObjectDescription>();
		IScope scope = SimpleScope.NULLSCOPE;
		if(op.getClass_().getName().contains("GScopIntExpressionInstr")) {
			verbose=true;
			System.out.println("Feature Scope for "+op.getName()+ ":"+op.getClass_().getName()+"\n");
		}
		for (EStructuralFeature feature : op.getClass_().getEAllStructuralFeatures()) {
			boolean selected = false;
			if (feature instanceof EAttribute) {
				selected = true;
			} else {
				selected = isSelectedFeature(feature,op);
			}
			if (selected) {
				System.out.println("\t- feature "+feature.getName());
				result.add(EObjectDescription.create(feature.getName(), feature,null));
			}
		}
		// Collection<IEObjectDescription> result =
		// descriptionService.featureCall_getElements(adapter, ref);

		return (result.isEmpty()) ? scope : new SimpleScope(result);
	}
	
	public IScope scope_EEnumLiteral(SettedFeatureParameter op,
			EReference ref) {
		EStructuralFeature feature = op.getFeature();
		Collection<IEObjectDescription> result = new ArrayList<IEObjectDescription>();
	
		if(feature.getEType() instanceof EEnum){
			EEnum enumeration = (EEnum) feature.getEType();
			for(EEnumLiteral literal:enumeration.getELiterals()){
				result.add(EObjectDescription.create(literal.getName(), literal, null));
			}
		}
		return (result.isEmpty()) ?  SimpleScope.NULLSCOPE : new SimpleScope(result);
	}

	public static Mapping getMapping(EObject o) {
		if (o instanceof Mapping)
			return (Mapping) o;
		if (o.eContainer() != null) {
			return getMapping(o.eContainer());
		} else
			return null;
	}


	public static boolean isSelectedFeature(EStructuralFeature feature,ClassOperator op) {
		boolean selected = false;
		if (feature instanceof EAttribute) {
			selected = true;
		} else {
			EReference reference = (EReference) feature;
			Mapping mapping = getMapping(op);
			boolean selectedReference = isSelectedReference(reference);
			if(selectedReference) {
				EClass eReferenceType = reference.getEReferenceType();
				Terminal terminal = mapping.getTerminal(eReferenceType,false);
				if(terminal==null) {
					System.out.println("\tNo Terminal found for class "+eReferenceType.getName());
				} else {
					selected=true;
				}
			}
		}
		return selected;
	}

	

	private static boolean isSelectedReference(EReference reference) {
		return !reference.isDerived() && !reference.isVolatile() && (reference.isContainment() || reference.getEOpposite() == null);
	}

}
