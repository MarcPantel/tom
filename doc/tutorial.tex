%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Tutorial}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Tutorial and examples}
\cutname{tutorial.html}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

On top of \TOM\ directory, you can find the tutorial directory where
all examples presented here can be found and ran.
The difficulties encountered in this tutorial is increasing with each
section and subsection. Most of the examples are based on Java and the
corresponding ATerm library for terms representation.
Each example can be ran using this default suite of commands:
\begin{verbatim}
  > jtom Example.t
  > javac Example.java
  > java Example
\end{verbatim}

Extra commands are explain when necessary.

\section{Introduction to the ATerm library for Java}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

ATerm is an abstract data type designed for tree-like data structures
representations.
More information on the C version is available at: 
\ahref{\atermpage}{http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/ATermLibrary}.

\section{Peano integer}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The Peano integer formalism aims to represent integer as Zero or as the
successor of an integer Suc(int).

\subsection{Simple examples}
\paragraph{Terms definition}
\TOM\ allows to define such algebraic specifications. First, we define
the sort \textsf{peano} and define the 2 operators: \textsf{zero} and \textsf{suc}.

\typeterm\ peano \{\\
\begin{quote}
 \implement           \{ ATerm \}\\
 \getfs(t)      \{ (((ATermAppl)t).getAFun()) \}\\
 \cmpfs(t1,t2)  \{ t1 == t2 \}\\
 \getsub(t, n)   \{ (((ATermAppl)t).getArgument(n)) \}\\
\end{quote}
\}\\
\\
\op\ peano zero \{\\
\begin{quote}
\fsym \{ fzero /*factory.makeAFun("zero",0,false*/\}\\
\end{quote}
\}\\
\\
\op\ peano suc(term) \{\\
\begin{quote}
  \fsym \{ fsuc /*fsuc  = factory.makeAFun("suc",1,false)*/\}\\
\end{quote}
\}\\

This is the minimal material given to TOM to compile pattern matching
constructs on peano sort. In particular, the sort is map to ATerm java class
(see \implement). \TOM\ now knows the functional symbol of zero and
suc, how to get and compare them;

Here is the code generated by \TOM:
\\ \textcolor{green}{public} \textcolor{magenta}{Object} \textsf{tom\_get\_fun\_sym\_peano}(\textcolor{magenta}{ATerm} t) \{ return  (((ATermAppl)t).getAFun()) ; \}
\\ \textcolor{green}{public} \textcolor{magenta}{Boolean} \textsf{tom\_cmp\_fun\_sym\_peano}(\textcolor{magenta}{Object} t1, \textcolor{magenta}{Object} t2) \{ return  t1 == t2 ; \}
\\ \textcolor{green}{public} \textcolor{magenta}{Object} \textsf{tom\_get\_subterm\_peano}(\textcolor{magenta}{ATerm} t, int n) \{ return
   (((ATermAppl)t).getArgument(n)) ; \}

\paragraph{Using match structure to make pattern matching}
Once the operators are defined, let us consider a simple symbolic
computation (addition) defined on Peano integers.

public ATerm plus(ATerm t1, ATerm t2) \{\\
\begin{quote}
 \match\ (peano t1, peano t2) \{\\
\begin{quote}
  x,zero   \textbf{->} \{ return x; \}\\
  x,suc(y) \textbf{->} \{ return suc(plus(x,y)); \}\\
\end{quote}
  \}\\
  return null;\\
\end{quote}
\}\\

Note: We can easily see that this match program is complete (We match
all possibilities) but we need to add a last return statement else
Java compiler will complain.
\paragraph{How to run the example}
By running the command:
\\> jtom Peano1;javac Peano1.java;java Peano1
\\We get the result:
\\plus(10,10) = suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(zero))))))))))))))))))))

\paragraph{How does this work}
The peano integer 10 is created by hand using the instruction
\textsf{for(int i=0 ; i<n ; i++) \{ N = suc(N);\}}and the defined java
suc function.
The match construct signature takes 2 peano terms. The first pattern
{x, zero} will be transformed in first a substitution then in a
ifthenelse construct. Indeed, x represents a variable because it is
not zero nor suc. So, x will be substitued by t1. Then, the
compilation will make a test on t2 being a zero or not. The second
pattern will be processed the them.
Here you can see the result of the compilation in the target language,
ie Java:

\textcolor{green}{public} \textcolor{magenta}{ATerm} plus(\textcolor{magenta}{ATerm} \textcolor{blue}{t1}, \textcolor{magenta}{ATerm} \textcolor{blue}{t2}) \{\\
\begin{quote}
  \textcolor{magenta}{ATerm} \textcolor{blue}{tom\_match1\_1} = null; \\
  \textcolor{magenta}{ATerm} \textcolor{blue}{tom\_match1\_2} = null; \\
  \textcolor{blue}{tom\_match1\_1} = (\textcolor{magenta}{ATerm}) t1; \\
  \textcolor{blue}{tom\_match1\_2} = (\textcolor{magenta}{ATerm}) t2; \\
  \textcolor{green}{matchlab\_match1\_pattern1:} \{\\ 
  \textcolor{magenta}{ATerm} x = null; x =
  (\textcolor{magenta}{ATerm}) \textcolor{blue}{tom\_match1\_1};
  \textcolor{red}{$\backslash$*=>substitution of x*$\backslash$}\\
  if(tom\_cmp\_fun\_sym\_peano(tom\_get\_fun\_sym\_peano(\textcolor{blue}{tom\_match1\_2}) ,
  fzero)) \textcolor{red}{$\backslash$*=>compilation of first pattern*$\backslash$}\{\\
  \begin{quote}
    return x;  \textcolor{red}{$\backslash$* =>Action associated to the
      first pattern *$\backslash$}
  \end{quote}
  \}\\
  \textcolor{green}{matchlab\_match1\_pattern2:} \{\\ 
  \textcolor{magenta}{ATerm} y = null; \textcolor{magenta}{ATerm} x = null; 
  x = (\textcolor{magenta}{ATerm}) \textcolor{blue}{tom\_match1\_1}; \\
  if(tom\_cmp\_fun\_sym\_peano(tom\_get\_fun\_sym\_peano(\textcolor{blue}{tom\_match1\_2}) ,
  fsuc)) \textcolor{red}{$\backslash$*=>compilation of second pattern*$\backslash$}\{\\
  \begin{quote}
    \textcolor{magenta}{ATerm} \textcolor{blue}{tom\_match1\_2\_1} = null; \textcolor{blue}{tom\_match1\_2\_1} = (\textcolor{magenta}{ATerm})
    tom\_get\_subterm\_peano(\textcolor{blue}{tom\_match1\_2, 0}); \\ 
    y = (\textcolor{magenta}{ATerm}) \textcolor{blue}{tom\_match1\_2\_1};\\
    return suc(plus(x,y));\\
  \end{quote}
  \}\\
  \}\\
\end{quote}
return null;\\
\}\\


The Peano2 examples shows how to map an algebraic sprcification to
another representation in the target language. So, in this second
example, you see that terms are \textsf{implemented} by \textbf{ATermAppl} instead
of \textbf{ATerm}. This implementation choice will simplify the way
\implement, \getfs, \cmpfs\ and \getsub\ are implemented (No more cast
needed).

\subsection{What about with C language}
A corresponding example to Peano1 can be found: cpeano.t.
To compile and run it, use:
\\ >jtom -c cexample.t
\\ > gcc cexample.c

One of the major drawbcak in this example is the complexity of
defining terms in regard to previous examples using ATerm for Java. A
second example, cpeanofib, gives a more complex implementaion of
terms.
Of course, this is still simple in regard to the low complexity of
represented terms.

\subsection{Using Bacquote construct}
The Peano3 examples illustrates the way the backquote construct can be
used to simplify term creation. This is realized by adding a
\textsf{make} function to each defined operator. This way, the Java suc
function is no more usefull and is directly replace by the
corresponding \make\ in suc operator definition. 

\op\ term zero \{\\
\begin{quote}
  \fsym \{ factory.makeAFun("zero",0,false) \}\\
  \make \{ factory.makeAppl(factory.makeAFun("zero",0,false))\}\\
\end{quote}
\}\\
  
\op\ term suc(term) \{\\
\begin{quote}
 \fsym    { factory.makeAFun("suc",1,false) }\\
 \make(t) { factory.makeAppl(factory.makeAFun("suc",1,false),t) }\\
\end{quote}
\}\\

Then, the creation of the term representing the integer N become easy:\\
ATermAppl N = \backquote zero();
for(int i=0 ; i<n ; i++) \{\\
  N = \backquote suc(N);\\
\}\\

But, the Backquote construct is more powerfull. Indeed, it is
translated in a function call. This allows to write in the macth
construct:

x,suc(y) -> { return \backquote suc(plus(x,y)); }

The plus function we be called and its result will be passed to create
the successor term; Of course, this is correct because plus returns a
term expected by the successor operator: suc. Running \TOM\ on this
example leeds for a warning message saying that it can not inferate
type-checking for this construct, because it has no knowledge on plus
function. To avoid the warning messages, please use:
\\> jtom -W Peano3

\subsection{Advanced examples and more powerfull operators}
As we see in previous examples, the operator definition can be
developped to simplify the use of \TOM\ main construct. We can also
supply others functions to specialized their default behavior defined
in the corresponding term definition.

The Peano1 example shows this point:

\typeterm term \{\\
\begin{quote}
  \implement           \{ ATermAppl \}\\
  \getfs(t)      \{ null \}\\
  \cmpfs(t1,t2)  \{ false \}\\
  \getsub(t, n)   \{ null \}\\
\end{quote}
\}\\

\op term zero \{\\
\begin{quote}
  \fsym       \{ \textsf{/* empty */} \}\\
  \isfs(t) \{ t.getAFun() == factory.makeAFun("zero",0,false) \}\\
  \make       \{ factory.makeAppl(factory.makeAFun("zero",0,false)) \}\\
\end{quote}
\}\\
  
\op term suc(pred:term) \{\\
\begin{quote}
  \fsym             \{ \textsf{/* empty */} \}\\
  \isfs(t)       \{ t.getAFun() == factory.makeAFun("suc",1,false) \}\\
  \getslot(pred,t) \{ (ATermAppl)t.getArgument(0) \}\\
  \make(t)          \{ factory.makeAppl(factory.makeAFun("suc",1,false),t) \}\\
\end{quote}
\}\\
\\
In the Peano2 example, we can see the facilities offered to extract
slot from match construct but also from term using defined slot names
or \@ facilities.

public ATermAppl fib(ATermAppl t) \{\\
\begin{quote}
  \match(term t) \{\\
\begin{quote}
    \textsf{y@}zero             -> \{ return `suc( \textsf{y}); \}\\
    \textsf{y@}suc(zero)        -> \{ return \textsf{y}; \}\\
    suc\textsf{[pred=y@}suc(\textsf{x})\textsf{]} -> \{ return `plus(fib(\textsf{x}),fib(\textsf{y})); \}\\
\end{quote}
  \}\\
  return null;\\
\end{quote}
\}\\

\section{Integer and Fibonacci}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
As seen in previous examples, all results leed to expression of the
result in Peano paradigm. \TOM\ offers a way to directly works with
integer.

public class Jint \{\\
\begin{quote}
  \typeint\\
  public final static void main(String[] args) \{\\
    Jint test = new Jint();\\
    int res = test.fib(10);\\
    System.out.println("res = " + res);\\
  \}\\
  public int fib(int t) \{\\
\begin{quote}
    \match(\textsf{int t}) \{\\
      \textsf{0} -> \{ return 1; \}\\
      \textsf{1} -> \{ return 1; \}\\
      \textsf{n} -> \{ return fib(n-1) + fib(n-2); \}\\
    \}\\
\end{quote}
  \}\\
\end{quote}
\}\\

\section{List}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\TOM\ allows to work on list representation of terms.
2 examples are available to show how to use either \typelist\ either \typearray\ and their
associated creator operator: \oplist\ and \oparray.

\subsection{Defining List}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typelist TomList \{\\
\begin{quote}
    \implement \{ ATermList \}\\
    \getfs(t) \{ ((t instanceof ATermList)?factory.makeAFun("conc", 1, false):null) \}\\
    \cmpfs(t1,t2) \{ t1 == t2 \}\\
    \equals(l1,l2) \{ l1==l2 \}\\
    \geth(l)   \{ l.getFirst() \}\\
    \gett(l)   \{ l.getNext() \}\\
    \isempty(l)   \{ l.isEmpty() \}\\
\end{quote}
  \}\\

\oplist TomList conc( TomTerm* ) \{\\
\begin{quote}
 \fsym \{ factory.makeAFun("conc", 1, false) \}\\
 \emptyl()  \{ factory.makeList() \}\\
 \minsert(e,l) \{ l.insert(e) \}\\
\end{quote}
\}\\

\subsection{Defining Array}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typearray TomArray \{\\
 \implement \{ ArrayList \}\\
\begin{quote}
 \getfs(t)   \{ ((t instanceof ArrayList)?factory.makeAFun("conc", 1, false):null) \}\\
 \cmpfs(t1,t2) \{ t1 == t2 \}\\
 \equals(l1,l2)      \{ l1.equals(l2) \}\\
 \getel(l,n)   \{ l.get(n) \}\\
 \getsize(l)        \{ l.size() \}\\
\end{quote}
\}\\
\oparray TomArray conc( TomTerm* ) \{\\
\begin{quote}
 \fsym            \{ factory.makeAFun("conc", 1, false) \}\\
 \emptya(n)   \{ myEmpty(n) \}\\
 \mappend(e,l) \{ myAdd(e,(ArrayList)l) \}\\
\end{quote}
\}\\

\subsection{Swapsort and the power of \TOM}
The 2 examples are very similar and allow to define 2 functions:
swapSort and removeDouble ina very efficient way.
\\Have a look to swapSort function definition in List2.t (with array):

public ArrayList swapSort(ArrayList l) \{\\
  \match(TomList l) \{\\
\begin{quote}
   \textsf{conc(X1*,x,X2*,y,X3*)} -> \{\\
   \begin{quote}
   String xname = x.getName();String yname = y.getName();\\
   \textsf{if(xname.compareTo(yname) > 0)\ \  return `swapSort(conc(X1*,y,X2*,x,X3*));}\\
   \end{quote}      
\}\\
\end{quote}      
\}\\

The compilation of the Match construct allows to generate all
combinations on the list parameter until it found the entered pattern.
Using a Backquote construct allows to naturally recursively call the
defined function!!!!!

\section{Apigen and the automatic generation of term representation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
One of the more difficult stuff in writting \TOM\ program is to write
all stuff concerning term definitions. To help developpers, a usefull
tools called Apigen is available at \ahref{\packagebase}{CWI package
  base Page} and use by \TOM\ developpers.
This tools take an abstract data type file called ADT file and
generate C or Java data-types that hide the ATerm library behind a
typed API.
For \TOM, it generates more than 300 java files to defining all used
\TOM\ structures.
For installing Apigen, see the \ahrefloc{developpers}{developpers sections
  on install manual}.

Both Java and C examples have an associated README file where you can
found compilation instructions.

\subsection{Description of Apigen}
Full documentation on Apigen can be found at \ahref{\apigenpage}{http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/ApiGen}.
\subsection{Java example}
All generated file


\subsection{C example}


\section{\TOM\ runtime and Mathematical expression}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This last example combines all previous items in a single problem:
Derivation and simplification of mathematical expressions. But, it
also introduces the way the runtime library can be used.


\section{Debugging \TOM}
