<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD><TITLE>Tom Language Reference</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.06">
</HEAD>
<BODY TEXT=black BGCOLOR=white>
<!--HEVEA command line is: hevea -o manual1.html manual.hva manual.tex -->
<!--HTMLHEAD-->
<!--ENDHTML-->
<!--PREFIX <ARG ></ARG>-->
<!--CUT DEF chapter 1 -->

<DIV ALIGN=center><TABLE CELLPADDING=10>
<TR><TD BGCOLOR="#0f75ff"><DIV ALIGN=center>
<FONT SIZE=8><B>
 <FONT COLOR=navy>Tom</FONT> Language Reference</B></FONT><BR>
<BR>
<FONT SIZE=5><B>
 Pierre-Etienne Moreau<BR>
(with Julien Guyon and Christophe Ringeissen)</B></FONT><BR>
<FONT SIZE=5><B>
 September 29, 2003</B></FONT></DIV></TD>
</TR></TABLE></DIV><BR>
<BR>
<BR>
<BR>

<BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV>
This manual also exists in <A HREF="http://tom.loria.fr/doc/manual/manual.ps">Postscript</A> or <A HREF="http://tom.loria.fr/doc/manual/manual.pdf">pdf</A>.
<DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
<B>Abstract:</B>&nbsp;TOM is a Pattern Matching Preprocessor that can be used to
intregrate term rewriting facilities in an imperative language such as
<FONT COLOR=purple>C</FONT> and <FONT COLOR=purple>Java</FONT>.<BR>
<BR>
Information on TOM is available the TOM web page&nbsp;<A HREF="http://tom.loria.fr">tom.loria.fr</A>.<BR>
<BR>
<!--TOC chapter Table of Contents-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0f75ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=6>Table of Contents</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<UL><LI>
<A HREF="#htoc1">Part&nbsp;I&nbsp;&nbsp;Installing and using the system</A>
<UL><LI>
<A HREF="#htoc2">Chapter&nbsp;1&nbsp;&nbsp;Installing and using the system</A>
<UL><LI>
<A HREF="#htoc3">1.1&nbsp;&nbsp;Simple installation procedure</A>
<LI><A HREF="#htoc4">1.2&nbsp;&nbsp;Requirements and download</A>
<LI><A HREF="#htoc5">1.3&nbsp;&nbsp;Installation</A>
<LI><A HREF="#htoc6">1.4&nbsp;&nbsp;Command line Arguments</A>
<LI><A HREF="#htoc7">1.5&nbsp;&nbsp;For developpers</A>
</UL>
</UL>
<LI><A HREF="#htoc8">Part&nbsp;II&nbsp;&nbsp;The system</A>
<UL><LI>
<A HREF="#htoc9">Chapter&nbsp;2&nbsp;&nbsp;<FONT COLOR=navy>Tom</FONT> core</A>
<UL><LI>
<A HREF="#htoc10">2.1&nbsp;&nbsp;Introduction</A>
<LI><A HREF="#htoc11">2.2&nbsp;&nbsp;The front-end</A>
<LI><A HREF="#htoc12">2.3&nbsp;&nbsp;The compiler</A>
<LI><A HREF="#htoc13">2.4&nbsp;&nbsp;The back-end</A>
</UL>
</UL>
<LI><A HREF="#htoc14">Part&nbsp;III&nbsp;&nbsp;The language</A>
<UL><LI>
<A HREF="#htoc15">Chapter&nbsp;3&nbsp;&nbsp;The core language</A>
<UL><LI>
<A HREF="#htoc16">3.1&nbsp;&nbsp;Notations</A>
<LI><A HREF="#htoc17">3.2&nbsp;&nbsp;Lexical conventions</A>
<LI><A HREF="#htoc18">3.3&nbsp;&nbsp;Names</A>
<LI><A HREF="#htoc19">3.4&nbsp;&nbsp;<FONT COLOR=navy>Tom</FONT> syntax</A>
<LI><A HREF="#htoc20">3.5&nbsp;&nbsp;<FONT COLOR=navy>Tom</FONT> semantic</A>
</UL>
</UL>
<LI><A HREF="#htoc21">Part&nbsp;IV&nbsp;&nbsp;Libraries</A>
<UL><LI>
<A HREF="#htoc22">Chapter&nbsp;4&nbsp;&nbsp;Runtime libraries</A>
<UL><LI>
<A HREF="#htoc23">4.1&nbsp;&nbsp;Runtime and traversal functions</A>
<LI><A HREF="#htoc24">4.2&nbsp;&nbsp;Debug</A>
</UL>
</UL>
<LI><A HREF="#htoc25">Part&nbsp;V&nbsp;&nbsp;Tutorial</A>
<UL><LI>
<A HREF="#htoc26">Chapter&nbsp;5&nbsp;&nbsp;Tutorial and examples</A>
<UL><LI>
<A HREF="#htoc27">5.1&nbsp;&nbsp;Introduction to the ATerm library for Java</A>
<LI><A HREF="#htoc28">5.2&nbsp;&nbsp;Peano integer</A>
<LI><A HREF="#htoc29">5.3&nbsp;&nbsp;Integer and Fibonacci</A>
<LI><A HREF="#htoc30">5.4&nbsp;&nbsp;List</A>
<LI><A HREF="#htoc31">5.5&nbsp;&nbsp;Apigen and the automatic generation of term representation</A>
<LI><A HREF="#htoc32">5.6&nbsp;&nbsp;<FONT COLOR=navy>Tom</FONT> runtime and Mathematical expression</A>
<LI><A HREF="#htoc33">5.7&nbsp;&nbsp;Debugging <FONT COLOR=navy>Tom</FONT></A>
</UL>
</UL>
</UL>

<!--TOC part Installing and using the system-->
<DIV ALIGN=center><TABLE CELLPADDING=10>
<TR><TD BGCOLOR="#0f75ff"><DIV ALIGN=center><A NAME="htoc1"><FONT SIZE=6><B>Part&nbsp;I</B></FONT></A><FONT SIZE=6><B><BR>
Installing and using the system</B></FONT></DIV></TD>
</TR></TABLE></DIV><!--SEC END -->

<!--TOC chapter Installing and using the system-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0f75ff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc2"><B><FONT SIZE=6>Chapter&nbsp;1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6>Installing and using the system</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<!--NAME install.html-->

This part of the manual gives basic information to get and install the
system.<BR>
<BR>
<!--TOC section Simple installation procedure-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc3"><B><FONT SIZE=5>1.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Simple installation procedure</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

In order to quickly install the last version of <FONT COLOR=navy>Tom</FONT>, the best thing
to do is the following:
<UL><LI><B>
</B><B>install the eclipse plugin
</B></UL><B>
</B>
or
<UL><LI><B>
</B><B>browse the <FONT COLOR=navy>Tom</FONT></B><B> web page&nbsp;</B><A HREF="http://tom.loria.fr"><B>tom.loria.fr</B></A><B>
</B><LI><B>get the last jtom-bundle-version.jar distribution
</B><LI><B>get the associated scripts
</B><LI><B>customize your CLASSPATH and PATH
</B><LI><B>this should be sufficient
</B></UL><B>
</B>
<!--TOC section Requirements and download-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc4"><B><FONT SIZE=5>1.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Requirements and download</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

The current version of <FONT COLOR=navy>Tom</FONT> is available from the
<A HREF="http://tom.loria.fr">TOM web page</A>.
In this page, you will find two kinds of releases:
<UL><LI>
The stable distribution corresponds to major releases of <FONT COLOR=navy>Tom</FONT>;
<LI>The ``Cutting Edge'' distribution corresponds to the last
 releases of <FONT COLOR=navy>Tom</FONT>. This is a way for keeping your system in sync with
 the latest developments. Be warned--the cutting edge is not for
 everyone! 
</UL>
Depending on the distribution, <FONT COLOR=navy>Tom</FONT> is avaible in different formats:
<UL><LI>
Releases: is a way to get a major release as a software package;
<LI>Bundles: is a way to get a major release of <FONT COLOR=navy>Tom</FONT>, including all
 needed dependencies;
<LI>Jar distributions: corresponds to compiled stable versions of <FONT COLOR=navy>Tom</FONT>;
<LI>Jar devel distributions: corresponds to compiled development versions of <FONT COLOR=navy>Tom</FONT>;
<LI>Daily distribution: is a snapshot of the source control
 system. This is a way to get the last version of a package for which
 all the regression tests succeed;<BR>
<BR>
<LI>CVS distribution: is a way to get the last source version of the
 system.
</UL>
<!--TOC paragraph Compiling and runtime tools-->

<H5>Compiling and runtime tools</H5><!--SEC END -->

<FONT COLOR=navy>Tom</FONT> is written in Java and <FONT COLOR=navy>Tom</FONT> itself. You will need a Java
compiler and interpreter to compile and run <FONT COLOR=navy>Tom</FONT>. 
<BR>
We actually use Sun JDK 1.4.x tools for development and runtime execution.
<BR>
Some tests have already been realized with gcj
and Jikes without any particular issues.<BR>
<BR>
<!--TOC paragraph Package dependencies-->

<H5>Package dependencies</H5><!--SEC END -->

<FONT COLOR=navy>Tom</FONT> software depends on others packages:
<UL><LI>
shared-objects
<LI>JJTraveler
<LI>aterm-java
<LI>apigen
</UL>
The following figure shows the dependencies order:<BR>
<BR>
<IMG SRC="depgraph-jtom.gif"><BR>
<BR>
Such packages are available from:
<UL><LI>
<FONT COLOR=navy>Tom</FONT> web page:&nbsp;<A HREF="http://tom.loria.fr">tom.loria.fr</A>
<LI>CWI package base Page:&nbsp;<A HREF="http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/PackageBase">www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/PackageBase</A>
</UL> 
<!--TOC section Installation-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc5"><B><FONT SIZE=5>1.3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Installation</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

Depending on the <FONT COLOR=navy>Tom</FONT> package you download, here are the installation
instructions.<BR>
<BR>
<!--TOC subsection Installing the bundle package-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>1.3.1</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Installing the bundle package</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

This is the simplest way to have quickly <FONT COLOR=navy>Tom</FONT> running on your
computer.
<UL><LI>
Untar the package:
<PRE>
  &gt; tar xzf jtom-bundle-VERSION.tar.gz
</PRE><LI>Download and unpack the required packages:
<PRE>
  &gt; ./collect.sh
</PRE><LI>Configure, build and install:
<PRE>
  &gt; ./configure --help gives a complete list of available configuration parameters.
  &gt; ./configure &lt;&lt;configuration parameters&gt;&gt;
  &gt; gmake
</PRE></UL>
Once all is done, you are ready using <FONT COLOR=navy>Tom</FONT> using jtom command.<BR>
<BR>
<!--TOC subsection Installing <FONT COLOR=navy>Tom</FONT> package-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>1.3.2</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Installing <FONT COLOR=navy>Tom</FONT></FONT></B><B><FONT SIZE=4> package</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<!--TOC paragraph Installation process-->

<H5>Installation process</H5><!--SEC END -->

<OL type=1><LI>
Get and install the shared-objects package
<PRE>
 a. Type `./configure --prefix=&lt;SHARED-DIR&gt;'
 b. Type `make'
 c. Type `make install'
</PRE><LI>Get and install the JJTraveler package
<PRE>
 a. Type `./configure --prefix=&lt;JJT-DIR&gt;'
 b. Type `make'
 c. Type `make install'
</PRE><LI>Get and install the aterm-java package
<PRE>
 a. Type `./configure --prefix=&lt;ATERM-DIR&gt;
                      --with-JJTraveler=&lt;JJT-DIR&gt; 
                      --with-shared-objects=&lt;SHARED-DIR&gt;' 
 b. Type `make'
 c. Type `make install'
</PRE><LI>Configure and install <FONT COLOR=navy>Tom</FONT> package:
<PRE>
 a. `./configure --prefix=&lt;INSTALLDIR&gt;
                 --with-shared-objects=&lt;SHARED-DIR&gt; 
                 --with-aterm-java=&lt;ATERM-DIR&gt;'
 b. Type `make' to compile the package.
 c. Type `make install' to install the package.
</PRE></OL>
<!--TOC section Command line Arguments-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc6"><B><FONT SIZE=5>1.4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Command line Arguments</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<!--TOC subsection NAME-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>1.4.1</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>NAME</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

 jtom - compile <FONT COLOR=navy>Tom</FONT> file (.t) into specified target languages<BR>
<BR>
<!--TOC subsection SYNOPSIS-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>1.4.2</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>SYNOPSIS</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<CODE>        jtom [-hceVvioDCfWldpsO] [-I path] filename[.t]</CODE><BR>
<BR>
<!--TOC subsection DESCRIPTION-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>1.4.3</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>DESCRIPTION</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=left NOWRAP><CODE>--help | -h</CODE></TD>
<TD ALIGN=left NOWRAP>Show the help</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--cCode | -c</CODE></TD>
<TD ALIGN=left NOWRAP>Generate C code (default is Java)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--eCode | -e</CODE></TD>
<TD ALIGN=left NOWRAP>Generate Eiffel code (default is Java)</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--version | -V</CODE></TD>
<TD ALIGN=left NOWRAP>Print the version of TOM</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--verbose | -v</CODE></TD>
<TD ALIGN=left NOWRAP>Set verbose mode on: give duration
 information on each compilation passes</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--intermediate | -i</CODE></TD>
<TD ALIGN=left NOWRAP>Generate intermediate files</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--noOutput | -o</CODE></TD>
<TD ALIGN=left NOWRAP>Do not generate code</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--noDeclaration | -D</CODE></TD>
<TD ALIGN=left NOWRAP>Do not generate code for declarations</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--doCompile | -C</CODE></TD>
<TD ALIGN=left NOWRAP>Start after type-checking (used after a
 compilation process with --intermediate option</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--noCheck | -f</CODE></TD>
<TD ALIGN=left NOWRAP>Do not realize checking phases</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--Wall</CODE></TD>
<TD ALIGN=left NOWRAP>Print all warnings</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--noWarning</CODE></TD>
<TD ALIGN=left NOWRAP>Do not print warning</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--lazyType | -l</CODE></TD>
<TD ALIGN=left NOWRAP>Use universal type</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--import &lt;path&gt; | -I</CODE></TD>
<TD ALIGN=left NOWRAP>Path for %include construct to find included files</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--pretty | -p</CODE></TD>
<TD ALIGN=left NOWRAP>Generate readable code with indentation</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--atermStat | -s</CODE></TD>
<TD ALIGN=left NOWRAP>Print internal ATerm statistics</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--optimize | -O</CODE></TD>
<TD ALIGN=left NOWRAP>Optimized generated code</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--static</CODE></TD>
<TD ALIGN=left NOWRAP>Generate static functions</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--debug</CODE></TD>
<TD ALIGN=left NOWRAP>Generate debug primitives</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><CODE>--memory</CODE></TD>
<TD ALIGN=left NOWRAP>Add memory management while debugging (not active with list matching)</TD>
</TR></TABLE><BR>
<!--TOC section For developpers-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc7"><B><FONT SIZE=5>1.5</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>For developpers</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<A NAME="developpers"></A>
<!--TOC paragraph CVS repository-->

<H5>CVS repository</H5><!--SEC END -->

The latest developments of <FONT COLOR=navy>Tom</FONT> are available from anonymous cvs at:
<BR>
cvs -d :pserver:cvs@cvs-sop.inria.fr:/CVS/aircube checkout jtom
<!--TOC paragraph <FONT COLOR=navy>Tom</FONT> Architecture-->

<H5><FONT COLOR=navy>Tom</FONT> Architecture</H5><!--SEC END -->

In <FONT COLOR=navy>Tom</FONT> directory architecture, two main branches can be underlined:
`stable' and `src'...
The `stable' branch contains the stable material to build a running
<FONT COLOR=navy>Tom</FONT> compiler. The `src' branch is used to make new developments.
Once in `src' directory, you can modify the sources. then, 
<OL type=1><LI>
Type `make' to build a new system and use jtom.src to use and
 test the new system.
<LI>At `src' directory level, type `make bootstrap' to bootstrap and
 install a new system.
 If something goes wrong, re-install the stable version:
 `cd ../../stable'; `make install'
 Then, correct the `src' directory
<LI>If you are happy from the result, type `make bootinstall' to
 make the current version become the stable one. 
 <B>Be aware that this action may be dangerous and cause serious
 problems to your <FONT COLOR=navy>Tom</FONT></B><B> installation!</B>
</OL>
Please send a mail to <A HREF="mailto:Pierre-Etienne.Moreau@loria.fr">Pierre-Etienne.Moreau@loria.fr</A> to propose your
suggestions.<BR>
<BR>
<!--TOC paragraph Additional tools for developments-->

<H5>Additional tools for developments</H5><!--SEC END -->

To simplify <FONT COLOR=navy>Tom</FONT> development, an extra package called Apigen 
(available at <A HREF="http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/PackageBase">CWI package base Page</A>) 
is used to generate data structures used by <FONT COLOR=navy>Tom</FONT>. All generated files
can be found in `jtom/adt' directory.
<BR>
<BR>
<!--TOC part The system-->
<DIV ALIGN=center><TABLE CELLPADDING=10>
<TR><TD BGCOLOR="#0f75ff"><DIV ALIGN=center><A NAME="htoc8"><FONT SIZE=6><B>Part&nbsp;II</B></FONT></A><FONT SIZE=6><B><BR>
The system</B></FONT></DIV></TD>
</TR></TABLE></DIV><!--SEC END -->

<!--TOC chapter <FONT COLOR=navy>Tom</FONT> core-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0f75ff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc9"><B><FONT SIZE=6>Chapter&nbsp;2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6><FONT COLOR=navy>Tom</FONT></FONT></B><B><FONT SIZE=6> core</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<!--NAME system.html-->

This part of the manual gives basic information on <FONT COLOR=navy>Tom</FONT> internals.<BR>
<BR>
<!--TOC section Introduction-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc10"><B><FONT SIZE=5>2.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Introduction</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

The current version of <FONT COLOR=navy>Tom</FONT> is written in
<FONT COLOR=purple>Java</FONT>+<FONT COLOR=navy>Tom</FONT> itself. 
It reads the program to be compiled and builds an abstract syntax tree
(AST) to represent the program.
The compiler is made up of stages, each of which can be seen as a
process that transforms the AST into a new one. After the last transformation,
the AST reprents a program closed to an imperative program.
The last stage of the compiler is a generation phase that transform
the AST into a concrete program written in <FONT COLOR=purple>C</FONT> or <FONT COLOR=purple>Java</FONT>, depending 
on the chosen target language.<BR>
<BR>
<!--TOC section The front-end-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc11"><B><FONT SIZE=5>2.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>The front-end</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

The front-end is the part of the system that reads the input program
and builds the associated abstract syntax tree.
This parts contains three components:
<UL><LI>
a parser: this stage reads a concrete program written in the
 target language embedded with some <FONT COLOR=navy>Tom</FONT> constructs, and build a
 first AST.
<LI>an expander: this stage performs some very simple
 transformations such as macro expansion.
<LI>a type checker: this stage add some type information to the AST
 (all untyped vaiables become a typed variable for example).
</UL>
Because <FONT COLOR=navy>Tom</FONT> is language independant, parsing a <FONT COLOR=navy>Tom</FONT> program is not
so easy. A solution could consists in implementing a specialized
parser for each supported target language (one for <FONT COLOR=purple>C</FONT>+<FONT COLOR=navy>Tom</FONT>, and
another one for <FONT COLOR=purple>Java</FONT>+<FONT COLOR=navy>Tom</FONT>), but for simplicity, and to keep the <FONT COLOR=navy>Tom</FONT>
system as simple as possible, we decided to implement a common parser,
slightly specialised for each considered target language. 
When considering <FONT COLOR=purple>C</FONT> and <FONT COLOR=purple>Java</FONT>, we noticed that it is only needed to
know how to recognize a string, a comment and a block to be able to
make the difference between a target language construct and a <FONT COLOR=navy>Tom</FONT>construct.<BR>
<BR>
The main idea consists in synchronising the parser on several
characters such as `<TT>%</TT>',`<TT>"</TT>', `<TT>{</TT>' and
`<TT>}</TT>'. For this purpose we decided to use <FONT COLOR=purple>Javacc</FONT> and
the lexical-mode facilities. Basically, the parser can be in two
differents modes: <TT>TomConstruct</TT> mode and
<TT>TargetLanguage</TT> mode.
When being in the <TT>TargetLanguage</TT> mode, the parser reads
everything unless a <FONT COLOR=navy>Tom</FONT> construct (beginning with a `<TT>%</TT>'
character) is recognized. Of course, this construct should not be in a
target language string or comment. This explain why it is needed to be
able to recognized such target language constructs.
Once a <FONT COLOR=navy>Tom</FONT> construct is recognized, the parser is switched to the
<TT>TomConstruct</TT> mode, and the considered construct can be
easilly parsed. 
We should notice that a <FONT COLOR=navy>Tom</FONT> construct can also contains a target
language part (always between `<TT>{</TT>' and `<TT>}</TT>').
When parsing such a part, the parser first reads a `<TT>{</TT>', and
then is looking for a corresponding `<TT>}</TT>': for each
encountered&nbsp;`<TT>}</TT>', it has to know if the read expression is
well parenthesed or not. This explains why it is needed to be able to
recognize and count the target language open and close block
commands. <BR>
<BR>
<!--TOC section The compiler-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc12"><B><FONT SIZE=5>2.3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>The compiler</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

The compiler receives as input an AST that merely corresponds to the 
input <FONT COLOR=navy>Tom</FONT> program (this is roughly a list of interleaved target
language constructs and <FONT COLOR=navy>Tom</FONT> constructs).
The goal of the compiler consists in transforming this AST into a
``simpler one'': an AST that can be easilly translated into an
imperative program (a <FONT COLOR=purple>C</FONT> or a <FONT COLOR=purple>Java</FONT> program for example).<BR>
<BR>
The kernel of the compiler contains a procedure that transforms a set
of patterns into a automaton that implements a matching algorithm
corresponding to the considered set of patterns. 
This automaton is then compiled into abstract instructions of the
form: <TT>IfThenElse</TT>, <TT>Assign</TT>, <TT>ExitAction</TT>, 
<TT>ExecuteAction</TT>, etc. 
With such an approach, the most complex part of the compilation process
is completly independ from the chosen target language, and can easily
be reused.<BR>
<BR>
<!--TOC section The back-end-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc13"><B><FONT SIZE=5>2.4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>The back-end</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

The back-end takes the last form of AST as input and generates a
concrete program written in the target language. This stage consists
in translating abstract instructions (like <TT>IfThenElse</TT>) into
concrete instructions (like <TT>if(cond) { instList }</TT>) in <FONT COLOR=purple>C</FONT>
or <FONT COLOR=purple>Java</FONT>. 
With such an approach, allows us to easily add a new back-end for any 
new supported target language.<BR>
<BR>
<!--TOC part The language-->
<DIV ALIGN=center><TABLE CELLPADDING=10>
<TR><TD BGCOLOR="#0f75ff"><DIV ALIGN=center><A NAME="htoc14"><FONT SIZE=6><B>Part&nbsp;III</B></FONT></A><FONT SIZE=6><B><BR>
The language</B></FONT></DIV></TD>
</TR></TABLE></DIV><!--SEC END -->

<!--TOC chapter The core language-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0f75ff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc15"><B><FONT SIZE=6>Chapter&nbsp;3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6>The core language</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<!--NAME language.html-->

This document is intended as a reference manual for the <FONT COLOR=navy>Tom</FONT>
language. It lists the language constructs, and gives their precise
syntax and informal semantics. It is by no means a tutorial
introduction to the language: there is not a single example.<BR>
<BR>
<!--TOC section Notations-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc16"><B><FONT SIZE=5>3.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Notations</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<BR>
The syntax of the language is given in BNF-like notation. Terminal
symbols are set in typewriter font (<FONT COLOR="#0000ff"><TT>like this</TT></FONT>). Non-terminal
symbols are set in italic font (<FONT COLOR="#ff00ff"><I>like that</I></FONT>). Square brackets
[...] denote optional components. Parentheses with a trailing
star sign (...)* denotes zero, one or several repetitions of the
enclosed components. Parentheses with a trailing 
plus sign (...)+ denote one or several repetitions of the enclosed
components. Parentheses (...) denote grouping. <BR>
<BR>
<!--TOC section Lexical conventions-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc17"><B><FONT SIZE=5>3.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Lexical conventions</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<DIV ALIGN=center>
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Identifier</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Letter</I></FONT> ( <FONT COLOR="#ff00ff"><I>Letter</I></FONT> |<FONT COLOR="#ff00ff"><I>Digit</I></FONT>
 |<FONT COLOR="#0000ff"><TT>_</TT></FONT> |<FONT COLOR="#0000ff"><TT>-</TT></FONT> )*</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Integer</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Digit</I></FONT> ( <FONT COLOR="#ff00ff"><I>Digit</I></FONT> )*</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Letter</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>A</TT></FONT> ... <FONT COLOR="#0000ff"><TT>Z</TT></FONT> |<FONT COLOR="#0000ff"><TT>a</TT></FONT> ... <FONT COLOR="#0000ff"><TT>z</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Digit</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>0</TT></FONT> ... <FONT COLOR="#0000ff"><TT>9</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Other</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>a character</TD>
</TR></TABLE>
</DIV><BR>
<!--TOC section Names-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc18"><B><FONT SIZE=5>3.3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Names</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<DIV ALIGN=center>
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>SubjectName</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Identifier</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Type</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Identifier</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>SlotName</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Identifier</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>HeadSymbol</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Identifier</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Integer</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Double</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>String</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>VariableName</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Identifier</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>AnnotedName</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Identifier</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>FileName</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Identifier</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Name</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Identifier</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>AttributeName</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Identifier</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>XMLName</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Identifier</I></FONT></TD>
</TR></TABLE>
</DIV><BR>
<!--TOC section <FONT COLOR=navy>Tom</FONT> syntax-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc19"><B><FONT SIZE=5>3.4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5><FONT COLOR=navy>Tom</FONT></FONT></B><B><FONT SIZE=5> syntax</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

A <FONT COLOR=navy>Tom</FONT> program is a target language program (namely <FONT COLOR=purple>C</FONT> or <FONT COLOR=purple>Java</FONT>)
embedded with some new preprocessor constructs such as
<FONT COLOR="#0000ff"><TT>%typeterm</TT></FONT>, <FONT COLOR="#0000ff"><TT>%op</TT></FONT>, <FONT COLOR="#0000ff"><TT>%rule</TT></FONT> and <FONT COLOR="#0000ff"><TT>%match</TT></FONT>.
<FONT COLOR=navy>Tom</FONT> is a multi-languages preprocessor, so, its syntax depends from 
the target language syntax. But for simplicity, we will only present
the syntax of its constructs and explain how they can be integrated
into the target language.
Basically, a <FONT COLOR=navy>Tom</FONT> program is list of blocks, where each block is
either a <FONT COLOR=navy>Tom</FONT> construct, either a sequence of characters.
The idea is that that after transformation, the sequence of characters
merged with the compiled <FONT COLOR=navy>Tom</FONT> constructs should be a valid target
language program.
So we have:<BR>
<DIV ALIGN=center>
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Tom</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>BlockList</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>BlockList</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>(</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>MatchConstruct</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>RuleConstruct</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>BackQuoteTerm</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>IncludeConstruct</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>LocalVariableConstruct</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Operator</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>OperatorList</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>OperatorArray</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>TypeTerm</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>TypeInt</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>TypeDouble</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>TypeString</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>TypeList</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>TypeArray</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>{</TT></FONT> <FONT COLOR="#ff00ff"><I>BlockList</I></FONT> <FONT COLOR="#0000ff"><TT>}</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Other</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>)*</TD>
</TR></TABLE>
</DIV>
<UL><LI>
a <FONT COLOR="#ff00ff"><I>MatchConstruct</I></FONT> is translated into a list of
 instructions. This constructs may appear anywhere a list of
 instructions is valid in the target language.<BR>
<BR>
<LI>a <FONT COLOR="#ff00ff"><I>RuleConstruct</I></FONT> is translated into a function
 definition. This constructs may appear anywhere function declaration
 is valid in the target language. <BR>
<BR>
<LI><A NAME="backquote"></A> a <FONT COLOR="#ff00ff"><I>BackQuoteTerm</I></FONT> is translated into a function call.<BR>
<BR>
<LI>a <FONT COLOR="#ff00ff"><I>IncludeConstruct</I></FONT> is replaced by the content of the
 file referenced by the construct.<BR>
<BR>
<LI>a <FONT COLOR="#ff00ff"><I>LocalVariableConstruct</I></FONT> is replaced by variable declarations.<BR>
<BR>
<LI><FONT COLOR="#ff00ff"><I>Operator</I></FONT>, <FONT COLOR="#ff00ff"><I>OperatorList</I></FONT> and <FONT COLOR="#ff00ff"><I>OperatorArray</I></FONT> are
 replaced by some functions definitions. <BR>
<BR>
<LI><FONT COLOR="#ff00ff"><I>TypeTerm</I></FONT>, <FONT COLOR="#ff00ff"><I>TypeInt</I></FONT>, <FONT COLOR="#ff00ff"><I>TypeDouble</I></FONT>, <FONT COLOR="#ff00ff"><I>TypeString</I></FONT>,
 <FONT COLOR="#ff00ff"><I>TypeList</I></FONT> and <FONT COLOR="#ff00ff"><I>TypeArray</I></FONT> are also replaced by some functions
 definitions. 
</UL>
A <FONT COLOR="#0000ff"><TT>%match</TT></FONT> construct contains two parts:<A NAME="match"></A>
<UL><LI>
a list of target language variables. These variables should
 contains the object on which patterns are matched<BR>
<BR>
<LI>a list of rules: a pattern and a semantic action (written in the
 target language)
</UL>
The construct is defined as follow:<BR>
<DIV ALIGN=center>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>MatchConstruct</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>%match</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT>
 <FONT COLOR="#ff00ff"><I>MatchArguments</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT> <FONT COLOR="#0000ff"><TT>{</TT></FONT>
 ( <FONT COLOR="#ff00ff"><I>PatternAction</I></FONT> )* 
 <FONT COLOR="#0000ff"><TT>}</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>MatchArguments</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Type</I></FONT> <FONT COLOR="#ff00ff"><I>SubjectName</I></FONT> ( <FONT COLOR="#0000ff"><TT>,</TT></FONT> <FONT COLOR="#ff00ff"><I>Type</I></FONT> <FONT COLOR="#ff00ff"><I>SubjectName</I></FONT> )*</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>PatternAction</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>MatchPatterns</I></FONT> <FONT COLOR="#0000ff"><TT>-&gt;</TT></FONT>
 <FONT COLOR="#0000ff"><TT>{</TT></FONT> <FONT COLOR="#ff00ff"><I>BlockList</I></FONT> <FONT COLOR="#0000ff"><TT>}</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>MatchPatterns</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Term</I></FONT> ( <FONT COLOR="#0000ff"><TT>,</TT></FONT> <FONT COLOR="#ff00ff"><I>Term</I></FONT> )*</TD>
</TR></TABLE>
</DIV><BR>
A term has the following syntax:
<DIV ALIGN=center>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Term</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP>[ <FONT COLOR="#ff00ff"><I>AnnotedName</I></FONT> <FONT COLOR="#0000ff"><TT>@</TT></FONT> ] <FONT COLOR="#ff00ff"><I>PlainTerm</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>PlainTerm</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>XMLTerm</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>VariableName</I></FONT> <FONT COLOR="#0000ff"><TT>*</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>HeadSymbolList</I></FONT> [ <FONT COLOR="#ff00ff"><I>ExplicitTermList</I></FONT> | <FONT COLOR="#ff00ff"><I>ImplicitPairList</I></FONT> ]</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>ExplicitTermList</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>_</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>_*</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>HeadSymbolList</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>HeadSymbol</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>HeadSymbol</I></FONT> ( <FONT COLOR="#0000ff"><TT></TT>|</FONT> <FONT COLOR="#ff00ff"><I>HeadSymbol</I></FONT> )+ <FONT COLOR="#0000ff"><TT>)</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>ExplicitTermList</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Term</I></FONT> ( <FONT COLOR="#0000ff"><TT>,</TT></FONT> <FONT COLOR="#ff00ff"><I>Term</I></FONT> )* <FONT COLOR="#0000ff"><TT>)</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>ImplicitPairList</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>[</TT></FONT> <FONT COLOR="#ff00ff"><I>PairTerm</I></FONT> ( <FONT COLOR="#0000ff"><TT>,</TT></FONT> <FONT COLOR="#ff00ff"><I>PairTerm</I></FONT> )* <FONT COLOR="#0000ff"><TT>]</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>PairTerm</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>[</TT></FONT> <FONT COLOR="#ff00ff"><I>SlotName</I></FONT> <FONT COLOR="#0000ff"><TT>=</TT></FONT> <FONT COLOR="#ff00ff"><I>Term</I></FONT> <FONT COLOR="#0000ff"><TT>]</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>XMLTerm</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>&lt;</TT></FONT> <FONT COLOR="#ff00ff"><I>XMLNameList</I></FONT> <FONT COLOR="#ff00ff"><I>XMLAttributeList</I></FONT> <FONT COLOR="#0000ff"><TT>/&gt;</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>&lt;</TT></FONT> <FONT COLOR="#ff00ff"><I>XMLNameList</I></FONT> <FONT COLOR="#ff00ff"><I>XMLAttributeList</I></FONT> <FONT COLOR="#0000ff"><TT>&gt;</TT></FONT>
 <FONT COLOR="#ff00ff"><I>XMLChilds</I></FONT> <FONT COLOR="#0000ff"><TT>&lt;/</TT></FONT> <FONT COLOR="#ff00ff"><I>XMLNameList</I></FONT> <FONT COLOR="#0000ff"><TT>&gt;</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>#TEXT</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Identifier</I></FONT> | <FONT COLOR="#ff00ff"><I>String</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>#COMMENT</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Identifier</I></FONT> | <FONT COLOR="#ff00ff"><I>String</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>#PROCESSING-INSTRUCTION</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT>
 (<FONT COLOR="#ff00ff"><I>Identifier</I></FONT> | <FONT COLOR="#ff00ff"><I>String</I></FONT>) <FONT COLOR="#0000ff"><TT>,</TT></FONT> (<FONT COLOR="#ff00ff"><I>Identifier</I></FONT> | <FONT COLOR="#ff00ff"><I>String</I></FONT>) <FONT COLOR="#0000ff"><TT>)</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>XMLNameList</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>XMLName</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>XMLName</I></FONT> ( <FONT COLOR="#0000ff"><TT></TT>|</FONT> <FONT COLOR="#ff00ff"><I>XMLName</I></FONT> )* <FONT COLOR="#0000ff"><TT>)</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>XMLAttributeList</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>[</TT></FONT> [ <FONT COLOR="#ff00ff"><I>XMLAttribute</I></FONT> (<FONT COLOR="#0000ff"><TT>,</TT></FONT>
 <FONT COLOR="#ff00ff"><I>XMLAttribute</I></FONT>)* ] <FONT COLOR="#0000ff"><TT>]</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>(</TT></FONT> [ <FONT COLOR="#ff00ff"><I>XMLAttribute</I></FONT> (<FONT COLOR="#0000ff"><TT>,</TT></FONT> <FONT COLOR="#ff00ff"><I>XMLAttribute</I></FONT>)* ] <FONT COLOR="#0000ff"><TT>)</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP>[ <FONT COLOR="#ff00ff"><I>XMLAttribute</I></FONT> ( <FONT COLOR="#ff00ff"><I>XMLAttribute</I></FONT>)* ]</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>XMLAttribute</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>AttributeName</I></FONT> <FONT COLOR="#0000ff"><TT>=</TT></FONT> <FONT COLOR="#ff00ff"><I>Term</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>_*</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>VariableName</I></FONT> <FONT COLOR="#0000ff"><TT>*</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP>[<FONT COLOR="#ff00ff"><I>AnnotedName</I></FONT>] <FONT COLOR="#0000ff"><TT>@</TT></FONT>] <FONT COLOR="#0000ff"><TT>_</TT></FONT> <FONT COLOR="#0000ff"><TT>=</TT></FONT> <FONT COLOR="#ff00ff"><I>Term</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>XMLChilds</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>ImplicitTermList</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP>( <FONT COLOR="#ff00ff"><I>Term</I></FONT> )*</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>ImplicitTermList</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>[</TT></FONT> <FONT COLOR="#ff00ff"><I>Term</I></FONT> ( <FONT COLOR="#0000ff"><TT>,</TT></FONT> <FONT COLOR="#ff00ff"><I>Term</I></FONT> )* <FONT COLOR="#0000ff"><TT>]</TT></FONT></TD>
</TR></TABLE>
</DIV><BR>
In <FONT COLOR=navy>Tom</FONT>, we can also define a set of rewrite rules. All the
left-handsides should begin with the same root symbol:<BR>
<DIV ALIGN=center>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>RuleConstruct</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>%rule</TT></FONT> <FONT COLOR="#0000ff"><TT>{</TT></FONT> ( <FONT COLOR="#ff00ff"><I>Rule</I></FONT> )* <FONT COLOR="#0000ff"><TT>}</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Rule</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>RuleBody</I></FONT> ( <FONT COLOR="#ff00ff"><I>RuleCondition</I></FONT> )*</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>RuleBody</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Term</I></FONT> <FONT COLOR="#0000ff"><TT>-&gt;</TT></FONT> <FONT COLOR="#ff00ff"><I>Term</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>RuleCondition</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>where</TT></FONT> <FONT COLOR="#ff00ff"><I>Term</I></FONT> <FONT COLOR="#0000ff"><TT>:=</TT></FONT> <FONT COLOR="#ff00ff"><I>Term</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>|</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>if</TT></FONT> <FONT COLOR="#ff00ff"><I>Term</I></FONT> <FONT COLOR="#0000ff"><TT>=</TT></FONT> <FONT COLOR="#ff00ff"><I>Term</I></FONT></TD>
</TR></TABLE>
</DIV><BR>
<DIV ALIGN=center>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>IncludeConstruct</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>%include</TT></FONT> <FONT COLOR="#0000ff"><TT>{</TT></FONT> <FONT COLOR="#ff00ff"><I>FileName</I></FONT> <FONT COLOR="#0000ff"><TT>}</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>Operator</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>%op</TT></FONT> <FONT COLOR="#ff00ff"><I>Type</I></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT>
 [ <FONT COLOR="#0000ff"><TT>(</TT></FONT> [ <FONT COLOR="#ff00ff"><I>SlotName</I></FONT> <FONT COLOR="#0000ff"><TT>:</TT></FONT> ] <FONT COLOR="#ff00ff"><I>Type</I></FONT> ( <FONT COLOR="#0000ff"><TT>,</TT></FONT> [
 <FONT COLOR="#ff00ff"><I>SlotName</I></FONT> <FONT COLOR="#0000ff"><TT>:</TT></FONT> ] <FONT COLOR="#ff00ff"><I>Type</I></FONT> )* <FONT COLOR="#0000ff"><TT>)</TT></FONT> ]</TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>{</TT></FONT> <FONT COLOR="#ff00ff"><I>KeywordFsym</I></FONT> ( <FONT COLOR="#ff00ff"><I>KeywordMake</I></FONT> |<FONT COLOR="#ff00ff"><I>KeywordGetSlot</I></FONT> |<FONT COLOR="#ff00ff"><I>KeywordIsFsym</I></FONT>)* <FONT COLOR="#0000ff"><TT>}</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>OperatorList</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>%oplist</TT></FONT> <FONT COLOR="#ff00ff"><I>Type</I></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Type</I></FONT> <FONT COLOR="#0000ff"><TT>*</TT></FONT>
 <FONT COLOR="#0000ff"><TT>)</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>{</TT></FONT> <FONT COLOR="#ff00ff"><I>KeywordFsym</I></FONT> ( <FONT COLOR="#ff00ff"><I>KeywordMakeEmptyList</I></FONT> |<FONT COLOR="#ff00ff"><I>KeywordMakeInsert</I></FONT> )* <FONT COLOR="#0000ff"><TT>}</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>OperatorArray</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>%oparray</TT></FONT> <FONT COLOR="#ff00ff"><I>Type</I></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Type</I></FONT> <FONT COLOR="#0000ff"><TT>*</TT></FONT>
 <FONT COLOR="#0000ff"><TT>)</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>{</TT></FONT> <FONT COLOR="#ff00ff"><I>KeywordFsym</I></FONT> ( <FONT COLOR="#ff00ff"><I>KeywordMakeEmptyArray</I></FONT> |<FONT COLOR="#ff00ff"><I>KeywordMakeAppend</I></FONT> )* <FONT COLOR="#0000ff"><TT>}</TT></FONT></TD>
</TR></TABLE>
</DIV><BR>
<DIV ALIGN=center>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>TypeTerm</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>%type</TT></FONT> <FONT COLOR="#ff00ff"><I>Type</I></FONT> <FONT COLOR="#0000ff"><TT>{</TT></FONT>
 <FONT COLOR="#ff00ff"><I>KeywordImplement</I></FONT>
 ( 
 <FONT COLOR="#ff00ff"><I>KeywordGetFunSym</I></FONT> 
 |<FONT COLOR="#ff00ff"><I>KeywordGetSubterm</I></FONT> 
 |<FONT COLOR="#ff00ff"><I>KeywordCmpFunSym</I></FONT> 
 |<FONT COLOR="#ff00ff"><I>KeywordEquals</I></FONT> 
 )*
 <FONT COLOR="#0000ff"><TT>}</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>TypeList</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>%typelist</TT></FONT> <FONT COLOR="#ff00ff"><I>Type</I></FONT> <FONT COLOR="#0000ff"><TT>{</TT></FONT>
 <FONT COLOR="#ff00ff"><I>KeywordImplement</I></FONT>
 [<FONT COLOR="#ff00ff"><I>KeywordGetFunSym</I></FONT>]
 [<FONT COLOR="#ff00ff"><I>KeywordGetSubterm</I></FONT>]
 [<FONT COLOR="#ff00ff"><I>KeywordCmpFunSym</I></FONT>]
 [<FONT COLOR="#ff00ff"><I>KeywordEquals</I></FONT>]
 [<FONT COLOR="#ff00ff"><I>KeywordGetHead</I></FONT>]
 [<FONT COLOR="#ff00ff"><I>KeywordGetTail</I></FONT>]
 [<FONT COLOR="#ff00ff"><I>KeywordIsEmpty</I></FONT>]
 <FONT COLOR="#0000ff"><TT>}</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>TypeArray</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>%typearray</TT></FONT> <FONT COLOR="#ff00ff"><I>Type</I></FONT> <FONT COLOR="#0000ff"><TT>{</TT></FONT>
 <FONT COLOR="#ff00ff"><I>KeywordImplement</I></FONT>
 ( 
 <FONT COLOR="#ff00ff"><I>KeywordGetFunSym</I></FONT>
 |<FONT COLOR="#ff00ff"><I>KeywordGetSubterm</I></FONT>
 |<FONT COLOR="#ff00ff"><I>KeywordCmpFunSym</I></FONT>
 |<FONT COLOR="#ff00ff"><I>KeywordEquals</I></FONT>
 |<FONT COLOR="#ff00ff"><I>KeywordGetElement</I></FONT>
 |<FONT COLOR="#ff00ff"><I>KeywordGetSize</I></FONT>
 )*
 <FONT COLOR="#0000ff"><TT>}</TT></FONT></TD>
</TR></TABLE>
</DIV><BR>
<DIV ALIGN=center>
 <TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>{</TT></FONT> <FONT COLOR="#ff00ff"><I>BlockList</I></FONT> <FONT COLOR="#0000ff"><TT>}</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordImplement</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>implement</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordGetFunSym</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>get_fun_sym</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordGetSubterm</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>get_subterm</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>,</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordCmpFunSym</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>cmp_fun_sym</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>,</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordEquals</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>equals</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>,</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordGetHead</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>get_head</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordGetTail</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>get_tail</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordIsEmpty</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>is_empty</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordGetElement</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>get_element</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>,</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordGetSize</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>get_size</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordFsym</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>fsym</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordMake</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>make</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> ( <FONT COLOR="#0000ff"><TT>,</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> )* <FONT COLOR="#0000ff"><TT>)</TT></FONT>
 <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordIsFsym</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>is_fsym</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> )* <FONT COLOR="#0000ff"><TT>)</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordGetSlot</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>get_slot</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>,</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordMakeEmptyList</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>make_empty</TT></FONT> [ <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT> ] <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordMakeInsert</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>make_insert</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>,</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordMakeEmptyArray</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>make_empty</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR="#ff00ff"><I>KeywordMakeAppend</I></FONT></TD>
<TD ALIGN=center NOWRAP>::=</TD>
<TD ALIGN=left NOWRAP><FONT COLOR="#0000ff"><TT>make_append</TT></FONT> <FONT COLOR="#0000ff"><TT>(</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>,</TT></FONT> <FONT COLOR="#ff00ff"><I>Name</I></FONT> <FONT COLOR="#0000ff"><TT>)</TT></FONT> <FONT COLOR="#ff00ff"><I>GoalLanguageBlock</I></FONT></TD>
</TR></TABLE>
</DIV><BR>
<!--TOC section <FONT COLOR=navy>Tom</FONT> semantic-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc20"><B><FONT SIZE=5>3.5</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5><FONT COLOR=navy>Tom</FONT></FONT></B><B><FONT SIZE=5> semantic</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<BR>
<!--TOC subsection Type definition-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>3.5.1</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Type definition</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<A NAME="typedef"></A><BR>
When defining a new type with the <FONT COLOR="#0000ff"><TT>%typeterm</TT></FONT> constructs,
several access functions have to be defined:
<UL><LI>
<A NAME="implement"></A> the <FONT COLOR="#0000ff"><TT>implement</TT></FONT> construct describes how the new type is 
 implemented. The target language part written between braces
 (<FONT COLOR="#0000ff"><TT>'{'</TT></FONT> and <FONT COLOR="#0000ff"><TT>'}'</TT></FONT>) is never parsed. It is used by
 the compiler to declare some functions and variables.<BR>
<BR>
<LI><A NAME="getfs"></A> the <FONT COLOR="#0000ff"><TT>get_fun_sym(t)</TT></FONT> construct corresponds to a
 function (parametrised by a term variable) that should return the
 root symbol of a given term (the term referenced by the term
 variable <TT>t</TT> in this example). <BR>
<BR>
<LI><A NAME="cmpfs"></A> the <FONT COLOR="#0000ff"><TT>cmp_fun_sym(s1,s2)</TT></FONT> construct corresponds to a
 predicate (parametrised by two symbol variables).
 This predicate should return <TT>true</TT> if the symbols are
 ``equal''. The <TT>true</TT> value should correspond to the 
 builtin <TT>true</TT> value of the considered target language.
 (<TT>true</TT> in <FONT COLOR=purple>Java</FONT>, and something different from <TT>0</TT> in
 <FONT COLOR=purple>C</FONT> for example). <BR>
<BR>
<LI><A NAME="getsub"></A> the <FONT COLOR="#0000ff"><TT>get_subterm(t,n)</TT></FONT> construct corresponds to a
 function (parametrised by a term variable and an integer).
 This function should return the <TT>n-th</TT> subterm of the
 term&nbsp;<TT>t</TT>. This never called with and integer paramter that
 does not correspond to the arity of the root symbol of the
 considered term (i.e. we alway have 0 &lt;= <I>n</I> &lt; <I>arity</I>).<BR>
<BR>
<LI><A NAME="equals"></A> the <FONT COLOR="#0000ff"><TT>equals(t1,t2)</TT></FONT> construct corresponds to a
 predicate (parametrised by two term variables).
 This predicate should return <TT>true</TT> if the terms are
 ``equal''. The <TT>true</TT> value should correspond to the 
 builtin <TT>true</TT> value of the considered target language.
 This last optional predicate is only used to compile non-linear 
 left-handsides. It is not needed, if the specification does not
 contain such patterns.
</UL>
<A NAME="listdef"></A>
When defining a new type with the <FONT COLOR="#0000ff"><TT>%typelist</TT></FONT> construct,
several other access functions have to be defined:
<UL><LI>
<A NAME="geth"></A> the <FONT COLOR="#0000ff"><TT>get_head(l)</TT></FONT> function is parametrised by a list
 variable and should return the first element of the considered list.<BR>
<BR>
<LI><A NAME="gett"></A> the <FONT COLOR="#0000ff"><TT>get_tail(l)</TT></FONT> function is parametrised by a list
 variable and should return the tail of the considered list.<BR>
<BR>
<LI><A NAME="isempty"></A> the <FONT COLOR="#0000ff"><TT>is_empty(l)</TT></FONT> constructs corresponds to a
 predicate parametrised by a list variable.
 This predicate should return <TT>true</TT> if the considered list
 contains no element.
</UL>
<A NAME="arraydef"></A>
When defining a new type with the <FONT COLOR="#0000ff"><TT>%typearray</TT></FONT> construct,
the two different access functions have to be defined:
<UL><LI>
<A NAME="gete"></A> the <FONT COLOR="#0000ff"><TT>get_element(l,n)</TT></FONT> construct is parametrised by a list
 variable and an integer. This should correspond to a function that
 return the <TT>n-th</TT> element of the considered list&nbsp;<TT>l</TT>.<BR>
<BR>
<LI><A NAME="getsize"></A> the <FONT COLOR="#0000ff"><TT>get_size(l)</TT></FONT> constructs corresponds to a function
 that returns the size of the considered list.
 By convention, an empty list contains <TT>0</TT> element.
</UL>
<A NAME="int"></A>
When introducing integer type with the <FONT COLOR="#0000ff"><TT>%typeint</TT></FONT> construct, then
the int type can be directly used as a term.<BR>
<BR>
<!--TOC subsection Operator definition-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>3.5.2</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Operator definition</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<A NAME="opdef"></A><BR>
When defining a new symbol with the <FONT COLOR="#0000ff"><TT>%op</TT></FONT>&nbsp;<I>s</I> construct, the user
should specify how the symbol&nbsp;<I>s</I> is implemented. This is done by the
<FONT COLOR="#0000ff"><TT>fsym</TT></FONT> <FONT COLOR="#0000ff"><TT>{</TT></FONT> implementation_of_s <FONT COLOR="#0000ff"><TT>}</TT></FONT> construct.<A NAME="fsym"></A>
The expression between braces should correspond (modulo the
<FONT COLOR="#0000ff"><TT>cmp_fun_sym</TT></FONT> predicate) to the expression returned by the
function <FONT COLOR="#0000ff"><TT>get_fun_sym</TT></FONT> applied to a term rooted by the
considered symbol (<I>s</I> in this case). <BR>
<BR>
<A NAME="isfsym"></A> 
The <FONT COLOR="#0000ff"><TT>isfysm(t)</TT></FONT> <FONT COLOR="#0000ff"><TT>{</TT></FONT> predicate(t) <FONT COLOR="#0000ff"><TT>}</TT></FONT> construct can be
used to specialize this mechanism. When <FONT COLOR="#0000ff"><TT>isfsym</TT></FONT> is defined, the
predicate (given between braces) is used to check if a term <I>t</I> is
rooted by the considered symbol (<I>s</I> in this example). This replaces
the use of <FONT COLOR="#0000ff"><TT>get_fun_sym</TT></FONT> and <FONT COLOR="#0000ff"><TT>cmp_fun_sym</TT></FONT>.<BR>
<BR>
<A NAME="make"></A>When defining a symbol, is it also possible to specify a
<FONT COLOR="#0000ff"><TT>make</TT></FONT> construct. This function is parametrised by several 
term variables (i.e. that should correspond to the arity of the
symbol). A call to this <FONT COLOR="#0000ff"><TT>make</TT></FONT> function should return a term
rooted by the considered symbol, where each subterm correspond to the
terms given in arguments to the function.<BR>
<BR>
As mentioned in the syntax definition, it is also possible to name
each field of a constructor symbol by using the
<TT>Type f(name1:Type, name2:Type2)</TT> syntax. 
Adopting this programming style has two main advantages:
<UL><LI>
when writing a pattern, this allows you write <TT>f[name2=a]</TT>
 instead of <TT>f(_,a)</TT>. One benefit is that you can modify the
 signature (adding a field for example) without necessary having to
 modify every pattern that occurs in the program.<BR>
<BR>
<LI><A NAME="getslot"></A> you may also specialize the <FONT COLOR="#0000ff"><TT>get_subterm</TT></FONT> access
function for a given constructor. This can be done with the
<FONT COLOR="#0000ff"><TT>get_slot</TT></FONT> construct.
</UL>
<BR>
<A NAME="oplistdef"></A>
When defining a new symbol with the <FONT COLOR="#0000ff"><TT>%oplist</TT></FONT> construct,
the user has to specify how the symbol is implemented. 
The user has also to specify how a list can be built (this is no
longer optional as in the <FONT COLOR="#0000ff"><TT>%op</TT></FONT> construct):
<UL><LI>
<A NAME="emptylist"></A> the <FONT COLOR="#0000ff"><TT>make_empty()</TT></FONT> construct should return an empty
 list.<BR>
<BR>
<LI><A NAME="insert"></A> the <FONT COLOR="#0000ff"><TT>make_insert(e,l)</TT></FONT> construct corresponds to a function
 parametrised by a list variable and a term variable. This function
 should return a new list&nbsp;<TT>l'</TT> where the element&nbsp;<TT>e</TT>
 has been inserted at the head of the list&nbsp;<TT>l</TT>
 (i.e. <FONT COLOR="#0000ff"><TT>equals(get_head(l'),e)</TT></FONT> and
 <FONT COLOR="#0000ff"><TT>equals(get_tail(l'),l)</TT></FONT> should be <TT>true</TT>).
</UL>
<A NAME="oparraydef"></A>
When defining a new symbol with the <FONT COLOR="#0000ff"><TT>%oparray</TT></FONT> construct,
the user has to specify how the symbol is implemented. 
The user has also to specify how a list can be built (this is no 
longer optional as in the <FONT COLOR="#0000ff"><TT>%op</TT></FONT> construct):
<UL><LI>
<A NAME="emptyarray"></A> the <FONT COLOR="#0000ff"><TT>make_empty(n)</TT></FONT> construct should return a list of
 size&nbsp;<TT>n</TT>. <BR>
<BR>
<LI><A NAME="append"></A> the <FONT COLOR="#0000ff"><TT>make_append(e,l)</TT></FONT> construct corresponds to a
 function parametrised by a list variable and a term variable. <BR>
<BR>
<B>Warning: </B>
This function should return a list&nbsp;<TT>l'</TT> such that
 the element&nbsp;<TT>e</TT> is at the <TT>n-th</TT> position.
</UL>
<!--TOC subsection Match definition-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>3.5.3</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Match definition</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
In order to match patterns against a list of subjects, <FONT COLOR=navy>Tom</FONT> provides
the <FONT COLOR="#0000ff"><TT>%match</TT></FONT> construct.
This constructs contains two parts:
<UL><LI>
a <FONT COLOR="#ff00ff"><I>MatchArguments</I></FONT>: this is a list of (target
 language) variables that reference the terms to be matched.
<LI>a list of <FONT COLOR="#ff00ff"><I>PatternAction</I></FONT>: this is a list of pairs
 (pattern,action), where an action is a set of target language
 instructions. 
</UL>
The <FONT COLOR="#0000ff"><TT>%match</TT></FONT> construct is evaluated in the following way:
<UL><LI>
given a list of ground terms (referenced by the list of target
 language variables), the execution control is transfered to the
 first <FONT COLOR="#ff00ff"><I>PatternAction</I></FONT> whose patterns match the list of ground
 terms.
<LI>given a <FONT COLOR="#ff00ff"><I>PatternAction</I></FONT>, the list of free variables is
 instantiated and the associated semantic action is executed.
 If the execution control is transfered outside the
 <FONT COLOR="#0000ff"><TT>%match</TT></FONT> instruction (by a <TT>goto</TT>, <TT>break</TT> or
 <TT>return</TT> for example), the matching process is finished.
 Otherwise, it is continued as follows:
 <UL><LI>
 if the considered matching theory may return several matches
 (list-matching for instance), for each match, the list of free
 variables is instantiated and the associated semantic action is
 executed.
 <LI>when all matches have been computed (there is at most one match
 in the syntactic theory), the execution control is transfered to
 the next <FONT COLOR="#ff00ff"><I>PatternAction</I></FONT> whose patterns match the list of
 ground terms. 
 </UL><BR>
<BR>
<LI>when there is no more <FONT COLOR="#ff00ff"><I>PatternAction</I></FONT> whose patterns
 match the list of ground terms, the <FONT COLOR="#0000ff"><TT>%match</TT></FONT> instruction is
 finished, and the execution control is transfered to the next
 instruction. 
</UL>
<B>Note:</B> the behaviour is not determined if a semantic action
modifies a target language variable which is an argument of a
<FONT COLOR="#0000ff"><TT>%match</TT></FONT> instruction under evaluation.<BR>
<BR>
<!--TOC subsection Rule definition-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>3.5.4</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Rule definition</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
The <FONT COLOR="#0000ff"><TT>%rule</TT></FONT> construct is composed of a list of conditional
rewrite rules (the left-hand side is a term and the right-hand side is
a term). All these rules should begin with the same root symbol. The
<FONT COLOR=navy>Tom</FONT> compiler should generate a function (with one argument) whose
name correspond to the name of this unique root symbol.
Given a ground term, applying this function returns the instanciated
right-hand side of the first rule whose pattern matches the considered 
subject and whose conditions are satisfied.
When no rule can be applied (i.e. no pattern matches the subject, or
no condition is satisfied), the given ground term, rooted by the root
symbol of the rewrite system is returned.<BR>
<BR>
In Tom, we consider two kinds of conditions:
<UL><LI>
an equality condition (<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> = <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB>) is a pair of ground terms that
 belong to the same type.
 The condition is satisfied when the normal forms of the two terms
 (<I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> and <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB>) are equal modulo the <FONT COLOR="#0000ff"><TT>equals</TT></FONT> predicate defined in
 the definition of the type associated to <I>t</I><SUB><FONT SIZE=2>1</FONT></SUB> and <I>t</I><SUB><FONT SIZE=2>2</FONT></SUB>.
<LI>a matching condition (<I>p</I> := <I>t</I>) is a pair of terms where p may
 contains free variable. The conditon is satisfied if the pattern&nbsp;<I>p</I>
 can be matched against the normal form of&nbsp;<I>t</I>. In this case, the
 free variables of&nbsp;<I>p</I> are instantited and can be used in other
 conditions or the right-hand side of the rule.
</UL>
<!--TOC part Libraries-->
<DIV ALIGN=center><TABLE CELLPADDING=10>
<TR><TD BGCOLOR="#0f75ff"><DIV ALIGN=center><A NAME="htoc21"><FONT SIZE=6><B>Part&nbsp;IV</B></FONT></A><FONT SIZE=6><B><BR>
Libraries</B></FONT></DIV></TD>
</TR></TABLE></DIV><!--SEC END -->
 
<!--TOC chapter Runtime libraries-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0f75ff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc22"><B><FONT SIZE=6>Chapter&nbsp;4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6>Runtime libraries</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<!--NAME lib.html-->

<!--TOC section Runtime and traversal functions-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc23"><B><FONT SIZE=5>4.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Runtime and traversal functions</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<!--TOC section Debug-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc24"><B><FONT SIZE=5>4.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Debug</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<BR>
<!--TOC part Tutorial-->
<DIV ALIGN=center><TABLE CELLPADDING=10>
<TR><TD BGCOLOR="#0f75ff"><DIV ALIGN=center><A NAME="htoc25"><FONT SIZE=6><B>Part&nbsp;V</B></FONT></A><FONT SIZE=6><B><BR>
Tutorial</B></FONT></DIV></TD>
</TR></TABLE></DIV><!--SEC END -->

<!--TOC chapter Tutorial and examples-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0f75ff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc26"><B><FONT SIZE=6>Chapter&nbsp;5</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6>Tutorial and examples</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<!--NAME tutorial.html-->

<BR>
<BR>
On top of <FONT COLOR=navy>Tom</FONT> directory, you can find the tutorial directory where
all examples presented here can be found and ran.
The difficulties encountered in this tutorial is increasing with each
section and subsection. Most of the examples are based on Java and the
corresponding ATerm library for terms representation.
Each example can be ran using this default suite of commands:
<PRE>
  &gt; jtom Example.t
  &gt; javac Example.java
  &gt; java Example
</PRE>
Extra commands are explain when necessary.<BR>
<BR>
<!--TOC section Introduction to the ATerm library for Java-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc27"><B><FONT SIZE=5>5.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Introduction to the ATerm library for Java</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<BR>
ATerm is an abstract data type designed for tree-like data structures
representations.
More information on the C version is available at: 
<A HREF="http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/ATermLibrary">http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/ATermLibrary</A>.<BR>
<BR>
<!--TOC section Peano integer-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc28"><B><FONT SIZE=5>5.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Peano integer</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<BR>
The Peano integer formalism aims to represent integer as Zero or as the
successor of an integer Suc(int).<BR>
<BR>
<!--TOC subsection Simple examples-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.2.1</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Simple examples</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<!--TOC paragraph Terms definition-->

<H5>Terms definition</H5><!--SEC END -->

<FONT COLOR=navy>Tom</FONT> allows to define such algebraic specifications. First, we define
the sort <FONT COLOR=purple>peano</FONT> and define the 2 operators: <FONT COLOR=purple>zero</FONT> and <FONT COLOR=purple>suc</FONT>.<BR>
<BR>
<A HREF="#typedef"><FONT COLOR="#0000ff"><TT><B>%typeterm</B></TT></FONT></A> peano {<BR>
<BLOCKQUOTE>
 <A HREF="#implement"><FONT COLOR="#0000ff"><TT>implement</TT></FONT></A>{ ATerm }<BR>
<A HREF="#getfs"><FONT COLOR="#0000ff"><TT>get_fun_sym</TT></FONT></A>(t) { (((ATermAppl)t).getAFun()) }<BR>
<A HREF="#cmpfs"><FONT COLOR="#0000ff"><TT>cmp_fun_sym</TT></FONT></A>(t1,t2) { t1 == t2 }<BR>
<A HREF="#getsub"><FONT COLOR="#0000ff"><TT>get_subterm</TT></FONT></A>(t, n) { (((ATermAppl)t).getArgument(n)) }<BR>
</BLOCKQUOTE>
}<BR>
<BR>
<A HREF="#opdef"><FONT COLOR="#0000ff"><TT><B>%op</B></TT></FONT></A> peano zero {<BR>
<BLOCKQUOTE>
<A HREF="#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A>{ fzero /*factory.makeAFun("zero",0,false*/}<BR>
</BLOCKQUOTE>
}<BR>
<BR>
<A HREF="#opdef"><FONT COLOR="#0000ff"><TT><B>%op</B></TT></FONT></A> peano suc(term) {<BR>
<BLOCKQUOTE>
 <A HREF="#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A>{ fsuc /*fsuc = factory.makeAFun("suc",1,false)*/}<BR>
</BLOCKQUOTE>
}<BR>
This is the minimal material given to TOM to compile pattern matching
constructs on peano sort. In particular, the sort is map to ATerm java class
(see <A HREF="#implement"><FONT COLOR="#0000ff"><TT>implement</TT></FONT></A>). <FONT COLOR=navy>Tom</FONT> now knows the functional symbol of zero and
suc, how to get and compare them;<BR>
<BR>
Here is the code generated by <FONT COLOR=navy>Tom</FONT>:
<BR>
<FONT COLOR="#00ff00">public</FONT> <FONT COLOR="#ff00ff">Object</FONT> <FONT COLOR=purple>tom_get_fun_sym_peano</FONT>(<FONT COLOR="#ff00ff">ATerm</FONT> t) { return (((ATermAppl)t).getAFun()) ; }
<BR>
<FONT COLOR="#00ff00">public</FONT> <FONT COLOR="#ff00ff">Boolean</FONT> <FONT COLOR=purple>tom_cmp_fun_sym_peano</FONT>(<FONT COLOR="#ff00ff">Object</FONT> t1, <FONT COLOR="#ff00ff">Object</FONT> t2) { return t1 == t2 ; }
<BR>
<FONT COLOR="#00ff00">public</FONT> <FONT COLOR="#ff00ff">Object</FONT> <FONT COLOR=purple>tom_get_subterm_peano</FONT>(<FONT COLOR="#ff00ff">ATerm</FONT> t, int n) { return
 (((ATermAppl)t).getArgument(n)) ; }<BR>
<BR>
<!--TOC paragraph Using match structure to make pattern matching-->

<H5>Using match structure to make pattern matching</H5><!--SEC END -->

Once the operators are defined, let us consider a simple symbolic
computation (addition) defined on Peano integers.<BR>
<BR>
public ATerm plus(ATerm t1, ATerm t2) {<BR>
<BLOCKQUOTE>
 <A HREF="#match"><FONT COLOR="#0000ff"><TT><B>%match</B></TT></FONT></A> (peano t1, peano t2) {<BR>
<BLOCKQUOTE>
 x,zero <B>-&gt;</B> { return x; }<BR>
x,suc(y) <B>-&gt;</B> { return suc(plus(x,y)); }<BR>
</BLOCKQUOTE>
 }<BR>
return null;<BR>
</BLOCKQUOTE>
}<BR>
Note: We can easily see that this match program is complete (We match
all possibilities) but we need to add a last return statement else
Java compiler will complain.
<!--TOC paragraph How to run the example-->

<H5>How to run the example</H5><!--SEC END -->

By running the command:
<BR>
&gt; jtom Peano1;javac Peano1.java;java Peano1
<BR>
We get the result:
<BR>
plus(10,10) = suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(zero))))))))))))))))))))<BR>
<BR>
<!--TOC paragraph How does this work-->

<H5>How does this work</H5><!--SEC END -->

The peano integer 10 is created by hand using the instruction
<FONT COLOR=purple>for(int i=0 ; i&lt;n ; i++) { N = suc(N);}</FONT>and the defined java
suc function.
The match construct signature takes 2 peano terms. The first pattern
x, zero will be transformed in first a substitution then in a
ifthenelse construct. Indeed, x represents a variable because it is
not zero nor suc. So, x will be substitued by t1. Then, the
compilation will make a test on t2 being a zero or not. The second
pattern will be processed the them.
Here you can see the result of the compilation in the target language,
ie Java:<BR>
<BR>
<FONT COLOR="#00ff00">public</FONT> <FONT COLOR="#ff00ff">ATerm</FONT> plus(<FONT COLOR="#ff00ff">ATerm</FONT> <FONT COLOR="#0000ff">t1</FONT>, <FONT COLOR="#ff00ff">ATerm</FONT> <FONT COLOR="#0000ff">t2</FONT>) {<BR>
<BLOCKQUOTE>
 <FONT COLOR="#ff00ff">ATerm</FONT> <FONT COLOR="#0000ff">tom_match1_1</FONT> = null;<BR>
<FONT COLOR="#ff00ff">ATerm</FONT> <FONT COLOR="#0000ff">tom_match1_2</FONT> = null;<BR>
<FONT COLOR="#0000ff">tom_match1_1</FONT> = (<FONT COLOR="#ff00ff">ATerm</FONT>) t1;<BR>
<FONT COLOR="#0000ff">tom_match1_2</FONT> = (<FONT COLOR="#ff00ff">ATerm</FONT>) t2;<BR>
<FONT COLOR="#00ff00">matchlab_match1_pattern1:</FONT> {<BR>
<FONT COLOR="#ff00ff">ATerm</FONT> x = null; x =
 (<FONT COLOR="#ff00ff">ATerm</FONT>) <FONT COLOR="#0000ff">tom_match1_1</FONT>;
 <FONT COLOR="#ff0000">\*=&gt;substitution of x*\</FONT><BR>
if(tom_cmp_fun_sym_peano(tom_get_fun_sym_peano(<FONT COLOR="#0000ff">tom_match1_2</FONT>) ,
 fzero)) <FONT COLOR="#ff0000">\*=&gt;compilation of first pattern*\</FONT>{<BR>
<BLOCKQUOTE>
 return x; <FONT COLOR="#ff0000">\* =&gt;Action associated to the
 first pattern *\</FONT>
 </BLOCKQUOTE>
 }<BR>
<FONT COLOR="#00ff00">matchlab_match1_pattern2:</FONT> {<BR>
<FONT COLOR="#ff00ff">ATerm</FONT> y = null; <FONT COLOR="#ff00ff">ATerm</FONT> x = null; 
 x = (<FONT COLOR="#ff00ff">ATerm</FONT>) <FONT COLOR="#0000ff">tom_match1_1</FONT>;<BR>
if(tom_cmp_fun_sym_peano(tom_get_fun_sym_peano(<FONT COLOR="#0000ff">tom_match1_2</FONT>) ,
 fsuc)) <FONT COLOR="#ff0000">\*=&gt;compilation of second pattern*\</FONT>{<BR>
<BLOCKQUOTE>
 <FONT COLOR="#ff00ff">ATerm</FONT> <FONT COLOR="#0000ff">tom_match1_2_1</FONT> = null; <FONT COLOR="#0000ff">tom_match1_2_1</FONT> = (<FONT COLOR="#ff00ff">ATerm</FONT>)
 tom_get_subterm_peano(<FONT COLOR="#0000ff">tom_match1_2, 0</FONT>);<BR>
y = (<FONT COLOR="#ff00ff">ATerm</FONT>) <FONT COLOR="#0000ff">tom_match1_2_1</FONT>;<BR>
return suc(plus(x,y));<BR>
</BLOCKQUOTE>
 }<BR>
}<BR>
</BLOCKQUOTE>
return null;<BR>
}<BR>
The Peano2 examples shows how to map an algebraic sprcification to
another representation in the target language. So, in this second
example, you see that terms are <FONT COLOR=purple>implemented</FONT> by <B>ATermAppl</B> instead
of <B>ATerm</B>. This implementation choice will simplify the way
<A HREF="#implement"><FONT COLOR="#0000ff"><TT>implement</TT></FONT></A>, <A HREF="#getfs"><FONT COLOR="#0000ff"><TT>get_fun_sym</TT></FONT></A>, <A HREF="#cmpfs"><FONT COLOR="#0000ff"><TT>cmp_fun_sym</TT></FONT></A> and <A HREF="#getsub"><FONT COLOR="#0000ff"><TT>get_subterm</TT></FONT></A> are implemented (No more cast
needed).<BR>
<BR>
<!--TOC subsection What about with C language-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.2.2</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>What about with C language</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

A corresponding example to Peano1 can be found: cpeano.t.
To compile and run it, use:
<BR>
&gt;jtom -c cexample.t
<BR>
&gt; gcc cexample.c<BR>
<BR>
One of the major drawbcak in this example is the complexity of
defining terms in regard to previous examples using ATerm for Java. A
second example, cpeanofib, gives a more complex implementaion of
terms.
Of course, this is still simple in regard to the low complexity of
represented terms.<BR>
<BR>
<!--TOC subsection Using Bacquote construct-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.2.3</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Using Bacquote construct</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

The Peano3 examples illustrates the way the backquote construct can be
used to simplify term creation. This is realized by adding a
<FONT COLOR=purple>make</FONT> function to each defined operator. This way, the Java suc
function is no more usefull and is directly replace by the
corresponding <A HREF="#make"><FONT COLOR="#0000ff"><TT>make</TT></FONT></A> in suc operator definition. <BR>
<BR>
<A HREF="#opdef"><FONT COLOR="#0000ff"><TT><B>%op</B></TT></FONT></A> term zero {<BR>
<BLOCKQUOTE>
 <A HREF="#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A>{ factory.makeAFun("zero",0,false) }<BR>
<A HREF="#make"><FONT COLOR="#0000ff"><TT>make</TT></FONT></A>{ factory.makeAppl(factory.makeAFun("zero",0,false))}<BR>
</BLOCKQUOTE>
}<BR>
<A HREF="#opdef"><FONT COLOR="#0000ff"><TT><B>%op</B></TT></FONT></A> term suc(term) {<BR>
<BLOCKQUOTE>
 <A HREF="#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A> factory.makeAFun("suc",1,false)<BR>
<A HREF="#make"><FONT COLOR="#0000ff"><TT>make</TT></FONT></A>(t)  factory.makeAppl(factory.makeAFun("suc",1,false),t)<BR>
</BLOCKQUOTE>
}<BR>
Then, the creation of the term representing the integer N become easy:<BR>
ATermAppl N = <A HREF="#backquote"><FONT COLOR="#0000ff"><TT><B>`</B></TT></FONT></A>zero();
for(int i=0 ; i&lt;n ; i++) {<BR>
N = <A HREF="#backquote"><FONT COLOR="#0000ff"><TT><B>`</B></TT></FONT></A>suc(N);<BR>
}<BR>
But, the Backquote construct is more powerfull. Indeed, it is
translated in a function call. This allows to write in the macth
construct:<BR>
<BR>
x,suc(y) -&gt;  return <A HREF="#backquote"><FONT COLOR="#0000ff"><TT><B>`</B></TT></FONT></A>suc(plus(x,y)); <BR>
<BR>
The plus function we be called and its result will be passed to create
the successor term; Of course, this is correct because plus returns a
term expected by the successor operator: suc. Running <FONT COLOR=navy>Tom</FONT> on this
example leeds for a warning message saying that it can not inferate
type-checking for this construct, because it has no knowledge on plus
function. To avoid the warning messages, please use:
<BR>
&gt; jtom -W Peano3<BR>
<BR>
<!--TOC subsection Advanced examples and more powerfull operators-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.2.4</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Advanced examples and more powerfull operators</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

As we see in previous examples, the operator definition can be
developped to simplify the use of <FONT COLOR=navy>Tom</FONT> main construct. We can also
supply others functions to specialized their default behavior defined
in the corresponding term definition.<BR>
<BR>
The Peano1 example shows this point:<BR>
<BR>
<A HREF="#typedef"><FONT COLOR="#0000ff"><TT><B>%typeterm</B></TT></FONT></A>term {<BR>
<BLOCKQUOTE>
 <A HREF="#implement"><FONT COLOR="#0000ff"><TT>implement</TT></FONT></A>{ ATermAppl }<BR>
<A HREF="#getfs"><FONT COLOR="#0000ff"><TT>get_fun_sym</TT></FONT></A>(t) { null }<BR>
<A HREF="#cmpfs"><FONT COLOR="#0000ff"><TT>cmp_fun_sym</TT></FONT></A>(t1,t2) { false }<BR>
<A HREF="#getsub"><FONT COLOR="#0000ff"><TT>get_subterm</TT></FONT></A>(t, n) { null }<BR>
</BLOCKQUOTE>
}<BR>
<A HREF="#opdef"><FONT COLOR="#0000ff"><TT><B>%op</B></TT></FONT></A>term zero {<BR>
<BLOCKQUOTE>
 <A HREF="#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A>{ <FONT COLOR=purple>/* empty */</FONT> }<BR>
<A HREF="#isfsym"><FONT COLOR="#0000ff"><TT>is_fsym</TT></FONT></A>(t) { t.getAFun() == factory.makeAFun("zero",0,false) }<BR>
<A HREF="#make"><FONT COLOR="#0000ff"><TT>make</TT></FONT></A>{ factory.makeAppl(factory.makeAFun("zero",0,false)) }<BR>
</BLOCKQUOTE>
}<BR>
<A HREF="#opdef"><FONT COLOR="#0000ff"><TT><B>%op</B></TT></FONT></A>term suc(pred:term) {<BR>
<BLOCKQUOTE>
 <A HREF="#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A>{ <FONT COLOR=purple>/* empty */</FONT> }<BR>
<A HREF="#isfsym"><FONT COLOR="#0000ff"><TT>is_fsym</TT></FONT></A>(t) { t.getAFun() == factory.makeAFun("suc",1,false) }<BR>
<A HREF="#getslot"><FONT COLOR="#0000ff"><TT>get_slot</TT></FONT></A>(pred,t) { (ATermAppl)t.getArgument(0) }<BR>
<A HREF="#make"><FONT COLOR="#0000ff"><TT>make</TT></FONT></A>(t) { factory.makeAppl(factory.makeAFun("suc",1,false),t) }<BR>
</BLOCKQUOTE>
}<BR>
<BR>
In the Peano2 example, we can see the facilities offered to extract
slot from match construct but also from term using defined slot names
or  facilities.<BR>
<BR>
public ATermAppl fib(ATermAppl t) {<BR>
<BLOCKQUOTE>
 <A HREF="#match"><FONT COLOR="#0000ff"><TT><B>%match</B></TT></FONT></A>(term t) {<BR>
<BLOCKQUOTE>
 <FONT COLOR=purple>y@</FONT>zero -&gt; { return `suc( <FONT COLOR=purple>y</FONT>); }<BR>
<FONT COLOR=purple>y@</FONT>suc(zero) -&gt; { return <FONT COLOR=purple>y</FONT>; }<BR>
suc<FONT COLOR=purple>[pred=y@</FONT>suc(<FONT COLOR=purple>x</FONT>)<FONT COLOR=purple>]</FONT> -&gt; { return `plus(fib(<FONT COLOR=purple>x</FONT>),fib(<FONT COLOR=purple>y</FONT>)); }<BR>
</BLOCKQUOTE>
 }<BR>
return null;<BR>
</BLOCKQUOTE>
}<BR>
<!--TOC section Integer and Fibonacci-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc29"><B><FONT SIZE=5>5.3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Integer and Fibonacci</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

As seen in previous examples, all results leed to expression of the
result in Peano paradigm. <FONT COLOR=navy>Tom</FONT> offers a way to directly works with
integer.<BR>
<BR>
public class Jint {<BR>
<BLOCKQUOTE>
 <A HREF="#int"><FONT COLOR="#0000ff"><TT><B>%typeint</B></TT></FONT></A><BR>
public final static void main(String[] args) {<BR>
Jint test = new Jint();<BR>
int res = test.fib(10);<BR>
System.out.println("res = " + res);<BR>
}<BR>
public int fib(int t) {<BR>
<BLOCKQUOTE>
 <A HREF="#match"><FONT COLOR="#0000ff"><TT><B>%match</B></TT></FONT></A>(<FONT COLOR=purple>int t</FONT>) {<BR>
<FONT COLOR=purple>0</FONT> -&gt; { return 1; }<BR>
<FONT COLOR=purple>1</FONT> -&gt; { return 1; }<BR>
<FONT COLOR=purple>n</FONT> -&gt; { return fib(n-1) + fib(n-2); }<BR>
}<BR>
</BLOCKQUOTE>
 }<BR>
</BLOCKQUOTE>
}<BR>
<!--TOC section List-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc30"><B><FONT SIZE=5>5.4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>List</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<BR>
<FONT COLOR=navy>Tom</FONT> allows to work on list representation of terms.
2 examples are available to show how to use either <A HREF="#listdef"><FONT COLOR="#0000ff"><TT><B>%typelist</B></TT></FONT></A> either <A HREF="#arraydef"><FONT COLOR="#0000ff"><TT><B>%typearray</B></TT></FONT></A> and their
associated creator operator: <A HREF="#oplistdef"><FONT COLOR="#0000ff"><TT><B>%oplist</B></TT></FONT></A> and <A HREF="#oparraydef"><FONT COLOR="#0000ff"><TT><B>%oparray</B></TT></FONT></A>.<BR>
<BR>
<!--TOC subsection Defining List-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.4.1</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Defining List</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<BR>
<A HREF="#listdef"><FONT COLOR="#0000ff"><TT><B>%typelist</B></TT></FONT></A>TomList {<BR>
<BLOCKQUOTE>
 <A HREF="#implement"><FONT COLOR="#0000ff"><TT>implement</TT></FONT></A>{ ATermList }<BR>
<A HREF="#getfs"><FONT COLOR="#0000ff"><TT>get_fun_sym</TT></FONT></A>(t) { ((t instanceof ATermList)?factory.makeAFun("conc", 1, false):null) }<BR>
<A HREF="#cmpfs"><FONT COLOR="#0000ff"><TT>cmp_fun_sym</TT></FONT></A>(t1,t2) { t1 == t2 }<BR>
<A HREF="#equals"><FONT COLOR="#0000ff"><TT>equals</TT></FONT></A>(l1,l2) { l1==l2 }<BR>
<A HREF="#geth"><FONT COLOR="#0000ff"><TT>get_head</TT></FONT></A>(l) { l.getFirst() }<BR>
<A HREF="#gett"><FONT COLOR="#0000ff"><TT>get_tail</TT></FONT></A>(l) { l.getNext() }<BR>
<A HREF="#isempty"><FONT COLOR="#0000ff"><TT>is_empty</TT></FONT></A>(l) { l.isEmpty() }<BR>
</BLOCKQUOTE>
 }<BR>
<A HREF="#oplistdef"><FONT COLOR="#0000ff"><TT><B>%oplist</B></TT></FONT></A>TomList conc( TomTerm* ) {<BR>
<BLOCKQUOTE>
 <A HREF="#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A>{ factory.makeAFun("conc", 1, false) }<BR>
<A HREF="#emptylist"><FONT COLOR="#0000ff"><TT>make_empty</TT></FONT></A>() { factory.makeList() }<BR>
<A HREF="#insert"><FONT COLOR="#0000ff"><TT>make_insert</TT></FONT></A>(e,l) { l.insert(e) }<BR>
</BLOCKQUOTE>
}<BR>
<!--TOC subsection Defining Array-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.4.2</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Defining Array</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<BR>
<A HREF="#arraydef"><FONT COLOR="#0000ff"><TT><B>%typearray</B></TT></FONT></A>TomArray {<BR>
<A HREF="#implement"><FONT COLOR="#0000ff"><TT>implement</TT></FONT></A>{ ArrayList }<BR>
<BLOCKQUOTE>
 <A HREF="#getfs"><FONT COLOR="#0000ff"><TT>get_fun_sym</TT></FONT></A>(t) { ((t instanceof ArrayList)?factory.makeAFun("conc", 1, false):null) }<BR>
<A HREF="#cmpfs"><FONT COLOR="#0000ff"><TT>cmp_fun_sym</TT></FONT></A>(t1,t2) { t1 == t2 }<BR>
<A HREF="#equals"><FONT COLOR="#0000ff"><TT>equals</TT></FONT></A>(l1,l2) { l1.equals(l2) }<BR>
<A HREF="#gete"><FONT COLOR="#0000ff"><TT>get_element</TT></FONT></A>(l,n) { l.get(n) }<BR>
<A HREF="#getsize"><FONT COLOR="#0000ff"><TT>get_size</TT></FONT></A>(l) { l.size() }<BR>
</BLOCKQUOTE>
}<BR>
<A HREF="#oparraydef"><FONT COLOR="#0000ff"><TT><B>%oparray</B></TT></FONT></A>TomArray conc( TomTerm* ) {<BR>
<BLOCKQUOTE>
 <A HREF="#fsym"><FONT COLOR="#0000ff"><TT>fsym</TT></FONT></A>{ factory.makeAFun("conc", 1, false) }<BR>
<A HREF="#emptyarray"><FONT COLOR="#0000ff"><TT>make_empty</TT></FONT></A>(n) { myEmpty(n) }<BR>
<A HREF="#append"><FONT COLOR="#0000ff"><TT>make_append</TT></FONT></A>(e,l) { myAdd(e,(ArrayList)l) }<BR>
</BLOCKQUOTE>
}<BR>
<!--TOC subsection Swapsort and the power of <FONT COLOR=navy>Tom</FONT>-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.4.3</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Swapsort and the power of <FONT COLOR=navy>Tom</FONT></FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

The 2 examples are very similar and allow to define 2 functions:
swapSort and removeDouble ina very efficient way.
<BR>
Have a look to swapSort function definition in List2.t (with array):<BR>
<BR>
public ArrayList swapSort(ArrayList l) {<BR>
<A HREF="#match"><FONT COLOR="#0000ff"><TT><B>%match</B></TT></FONT></A>(TomList l) {<BR>
<BLOCKQUOTE>
 <FONT COLOR=purple>conc(X1*,x,X2*,y,X3*)</FONT> -&gt; {<BR>
<BLOCKQUOTE>
 String xname = x.getName();String yname = y.getName();<BR>
<FONT COLOR=purple>if(xname.compareTo(yname) &gt; 0)   return `swapSort(conc(X1*,y,X2*,x,X3*));</FONT><BR>
</BLOCKQUOTE> 
}<BR>
</BLOCKQUOTE> 
}<BR>
The compilation of the Match construct allows to generate all
combinations on the list parameter until it found the entered pattern.
Using a Backquote construct allows to naturally recursively call the
defined function!!!!!<BR>
<BR>
<!--TOC section Apigen and the automatic generation of term representation-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc31"><B><FONT SIZE=5>5.5</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Apigen and the automatic generation of term representation</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

One of the more difficult stuff in writting <FONT COLOR=navy>Tom</FONT> program is to write
all stuff concerning term definitions. To help developpers, a usefull
tools called Apigen is available at <A HREF="http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/PackageBase">CWI package
 base Page</A> and use by <FONT COLOR=navy>Tom</FONT> developpers.
This tools take an abstract data type file called ADT file and
generate C or Java data-types that hide the ATerm library behind a
typed API.
For <FONT COLOR=navy>Tom</FONT>, it generates more than 300 java files to defining all used
<FONT COLOR=navy>Tom</FONT> structures.
For installing Apigen, see the <A HREF="#developpers">developpers sections
 on install manual</A>.<BR>
<BR>
Both Java and C examples have an associated README file where you can
found compilation instructions.<BR>
<BR>
<!--TOC subsection Description of Apigen-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.5.1</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Description of Apigen</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

Full documentation on Apigen can be found at <A HREF="http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/ApiGen">http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/ApiGen</A>.
<!--TOC subsection Java example-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.5.2</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>Java example</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

All generated file<BR>
<BR>
<!--TOC subsection C example-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0000ff"><DIV ALIGN=center><TABLE>
<TR><TD><B><FONT SIZE=4>5.5.3</FONT></B></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=4>C example</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->
<BR>
<!--TOC section <FONT COLOR=navy>Tom</FONT> runtime and Mathematical expression-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc32"><B><FONT SIZE=5>5.6</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5><FONT COLOR=navy>Tom</FONT></FONT></B><B><FONT SIZE=5> runtime and Mathematical expression</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

This last example combines all previous items in a single problem:
Derivation and simplification of mathematical expressions. But, it
also introduces the way the runtime library can be used.<BR>
<BR>
<!--TOC section Debugging <FONT COLOR=navy>Tom</FONT>-->
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc33"><B><FONT SIZE=5>5.7</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Debugging <FONT COLOR=navy>Tom</FONT></FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE><!--SEC END -->

<BR>
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2>
<BLOCKQUOTE><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://pauillac.inria.fr/~maranget/hevea/index.html"><EM>H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</EM></A><EM>.
</EM></BLOCKQUOTE>
</BODY>
</HTML>
