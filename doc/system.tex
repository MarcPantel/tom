%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{The system}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{\TOM\ core}
\cutname{system.html}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This part of the manual gives basic information on \TOM\ internals.


\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The current version of \TOM\ is written in
\Java+\TOM\ itself. 
It reads the program to be compiled and builds an abstract syntax tree
(AST) to represent the program.
The compiler is made up of stages, each of which can be seen as a
process that transforms the AST into a new one. After the last transformation,
the AST reprents a program closed to an imperative program.
The last stage of the compiler is a generation phase that transform
the AST into a concrete program written in \Clang\ or \Java, depending 
on the chosen target language.


\section{The front-end}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The front-end is the part of the system that reads the input program
and builds the associated abstract syntax tree.
This parts contains three components:
\begin{itemize}
\item a parser: this stage reads a concrete program written in the
  target language embedded with some \TOM\ constructs, and build a
  first AST.
\item an expander: this stage performs some very simple
  transformations such as macro expansion.
\item a type checker: this stage add some type information to the AST
  (all untyped vaiables become a typed variable for example).
\end{itemize}

Because \TOM\ is language independant, parsing a \TOM\ program is not
so easy. A solution could consists in implementing a specialized
parser for each supported target language (one for \Clang+\TOM, and
another one for \Java+\TOM), but for simplicity, and to keep the \TOM\
system as simple as possible, we decided to implement a common parser,
slightly specialised for each considered target language. 
When considering \Clang\ and \Java, we noticed that it is only needed to
know how to recognize a string, a comment and a block to be able to
make the difference between a target language construct and a \TOM
construct.

The main idea consists in synchronising the parser on several
characters such as `\texttt{\%}',`\texttt{"}', `\texttt{\{}' and
`\texttt{\}}'. For this purpose we decided to use \textsf{Javacc} and
the lexical-mode facilities. Basically, the parser can be in two
differents modes: \texttt{TomConstruct} mode and
\texttt{TargetLanguage} mode.
When being in the \texttt{TargetLanguage} mode, the parser reads
everything unless a \TOM\ construct (beginning with a `\texttt{\%}'
character) is recognized. Of course, this construct should not be in a
target language string or comment. This explain why it is needed to be
able to recognized such target language constructs.
Once a \TOM\ construct is recognized, the parser is switched to the
\texttt{TomConstruct} mode, and the considered construct can be
easilly parsed. 
We should notice that a \TOM\ construct can also contains a target
language part (always between `\texttt{\{}' and `\texttt{\}}').
When parsing such a part, the parser first reads a `\texttt{\{}', and
then is looking for a corresponding `\texttt{\}}': for each
encountered~`\texttt{\}}', it has to know if the read expression is
well parenthesed or not. This explains why it is needed to be able to
recognize and count the target language open and close block
commands. 

\section{The compiler}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The compiler receives as input an AST that merely corresponds to the 
input \TOM\ program (this is roughly a list of interleaved target
language constructs and \TOM\ constructs).
The goal of the compiler consists in transforming this AST into a
``simpler one'': an AST that can be easilly translated into an
imperative program (a \Clang\ or a \Java\ program for example).

The kernel of the compiler contains a procedure that transforms a set
of patterns into a automaton that implements a matching algorithm
corresponding to the considered set of patterns. 
This automaton is then compiled into abstract instructions of the
form: \texttt{IfThenElse}, \texttt{Assign}, \texttt{ExitAction}, 
\texttt{ExecuteAction}, etc. 
With such an approach, the most complex part of the compilation process
is completly independ from the chosen target language, and can easily
be reused.


\section{The back-end}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The back-end takes the last form of AST as input and generates a
concrete program written in the target language. This stage consists
in translating abstract instructions (like \texttt{IfThenElse}) into
concrete instructions (like \texttt{if(cond) \{ instList \}}) in \Clang\
or \Java.  
With such an approach, allows us to easily add a new back-end for any 
new supported target language.


