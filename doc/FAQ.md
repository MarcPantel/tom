# FAQ

## General

### Under which license is Tom available?

Tom is [open source](http://www.opensource.org/docs/definition.html) software, and the license is such that it is possible to redistribute all code generated by with no restrictions. Any user of is allowed to distribute the files generated by under the license he prefers. However, the core of the compiler itself is distributed under the [GNU General Public License](http://www.opensource.org/licenses/gpl-2.0.php).

The general licensing scheme is described [here](Licensing_conditions.md).

### How can I install Tom ?

Everything is explained in the [installation guide](tools/Installation.md).

### Can I distribute an application written in ?

Yes, the generated code and the runtime library is free. See [Licensing_conditions](Licensing_conditions.md) for more details.

### What runtime is needed to run an application written in ?

To make things simple, we provide a `tom-runtime-full.jar` library that contains everything that could be needed. If you do not care about the size of the runtime library, just distribute your application with this library.

If you want, you can also have a finer control by selecting only the parts of the runtime library that are needed by your application:

-   there are some situations where no runtime is needed, in particular when using in C mode, or when only pattern matching is used (on user defined data-structures),
-   when using more advanced features, such as strategies, `tom-runtime.jar` is needed,
-   when using , `aterm.jar`, `jjtraveler.jar`, and `shared-objects.jar` are needed,
-   when using syntax in , `xercesImpl.jar` and `xml-apis.jar` become needed,
-   when using graphical visualization of terms, `grappa1_2.jar` is needed.

The following instructions may help you to build a more tailored classpath:

```sh
(sh)
  TOM_LIB_RUNTIME=`echo ${TOM_HOME}/lib/runtime/*.jar | tr ' ' ':'`
  TOM_LIB_TOOLS=`echo ${TOM_HOME}/lib/tools/*.jar | tr ' ' ':'`
  export CLASSPATH=.:$TOM_LIB_RUNTIME:$TOM_LIB_TOOLS:$CLASSPATH
```
```sh  
(bash)
 for i in "${TOM_HOME}"/lib/runtime/*.jar
 do
   TOM_LIB_RUNTIME="$TOM_LIB_RUNTIME:$i"
 done
 for i in "${TOM_HOME}"/lib/tools/*.jar
 do
   TOM_LIB_TOOLS="$TOM_LIB_TOOLS:$i"
 done
 export CLASSPATH=.:${TOM_LIB_TOOLS}:${TOM_LIB_TOOLS}${CLASSPATH}
```
```sh
(csh)
  set TOM_LIB_RUNTIME=`echo ${TOM_HOME}/lib/runtime/*.jar | tr ' ' ':'`
  set TOM_LIB_TOOLS=`echo ${TOM_HOME}/lib/tools/*.jar | tr ' ' ':'`
  setenv CLASSPATH .:$TOM_LIB_RUNTIME:$TOM_LIB_TOOLS:$CLASSPATH
```

### Can I use the latest cutting edge version?

Yes, but you have to [compile the compiler](tools/Compiling_trunk.md) yourself.

### How can I complain about Tom ?

You can submit a bug report on the [forge](http://gforge.inria.fr/tracker/?group_id=78), or drop a mail on the [tom-users](http://websympa.loria.fr/wwsympa/subrequest/tom-users) mailing list.

The Tom language
------------

### Is associative-commutative (AC) matching supported?

Yes Tom supports AC matching since the version 2.8. To use Tom AC, you have to activate it in your gom code.

### How to model sorts and subsorts?

We are currently designing and implementing an extension that supports subsorts. see [Sorts and subsorts](reference/Tom.md) for more details.

Technical
---------

### How to visualize a term?

In addition to the standard textual representation there is a [library](/Documentation:Runtime_Library#Term_viewer "wikilink"). Just call

-   `tom.library.utils.Viewer.toDot(term)` ([DOT](http://www.graphviz.org/) representation)
-   `tom.library.utils.Viewer.toTree(term)` (tree-based ascii representation)
-   `tom.library.utils.Viewer.display(term)` (direct graphical visualization in a JFrame).

It can be used with terms and term-graphs (terms with pointers).

![](images/TermVisualization1.jpg)
![](images/TermVisualization2.jpg)

### Can I add Java code to generated  classes?

Yes, using the [`:block {}` hook](reference/Gom.md#hooks-to-alter-the-generated-api).

### How to share a strategy between different files?

Be sure to use a recent version of Tom such that generated creation functions are `public` instead of `private`.

Assume you define a strategy `R()`:

```java
import term.types.*;
class Test {
  %include { term/Term.tom}
  %include { sl.tom }
  %strategy R() extends Fail() {
    visit Term {
      a() -> b()
    }
  }
}
```

If you want to use `R()` in another file, you just have to create a simple mapping:

```java
%op Strategy R() {
  make() { new Test.R() }
}
```

Then, you can use `` `R() `` as usual (don't forget to import sl: `%include { sl.tom }`):

```java
import term.types.*;
import tom.library.sl.*;
public class Main {
  %include { term/Term.tom }
  %include { sl.tom }
  %op Strategy R() {
    make() { new Test.R() }
  }
  public final static void main(String[] args) {
    Term t = `a();
    try {
      System.out.println(`R().visit(t));
    } catch(VisitFailure e) {
      System.out.println("failure");
    }
  }
}
```

### How to use constants in a pattern?

A solution is to pass the constant as another parameter in the `%match` construct, and use non-linear patterns to check the constant.

```java
%match(t, `Constant()) {
  f(x,y), x -> { System.out.println("Constant found as first child"); }
  f(x,y), y -> { System.out.println("Constant found as second child"); }
}
```

Which is equivalent to the following constraint-based version.

```java
%match(t) {
  f(x,y) && x << `Constant() -> { System.out.println("Constant found as first child"); }
  f(x,y) && y << `Constant() -> { System.out.println("Constant found as second child"); }
}
```

This of course extends to java variables.

```java
public void findName(String name, StringList l) {
  %match(l) {
    SList(_*,n,_*) && n << name -> { System.out.println(name + " found"); }
  }
}
```

### Why does my backquote construct not compile?

explain the use of functions in AU operators (%op needed to declare the function)

### Can I call a strategy in a strategy itself?

There exist different situations:

-   you can always call a sub-strategy in the part of a construct: you just have to call `visitLight` or `visit` on another subject:

```java
`OuterStrat.visit(t1); // or visitLight

%strategy OuterStrat() {
  ... -> { `InnerStrat().visit(t2); } // or visitLight
}
```

-   if you want to apply another strategy on the current subject (and you want to maintain the position information), then you have to use the `visit` method in the following way:

```java
`TopDown(OuterStrat).visit(t1);

%strategy OuterStrat() {
  ... -> {
    // apply InnerStrat on t1 at the current position
    `InnerStrat().visit(getEnvironment());
  }
}
```

Since an environment is maintained, you have to apply the sub-strategy on the current environment, using `visit(getEnvironment())`.

### How can I make a strategy fail?

This is simple: just apply the startegy `Fail()` to any object.

```java
`Fail().visitLight(...);
```

### How to use a congruence strategy operator?

1.  when using %gom (see [Using Gom with Tom](reference/Gom.md#using-gom-with-tom)):
    you have to use the `--withCongruenceStrategies` option: `%gom(--withCongruenceStrategies) { ... }`
2.  when including a mapping generated by (see [Using Gom with Tom](reference/Gom.md#using-gom-with-tom)):
    just add an at the beginning of the included file: `%include{ .../_term.tom }` for instance.
3.  when generating an introspector (see [Introspector](reference/Strategies.md#applying-a-strategy-on-a-user-defined-data-structures)):
    this is not possible. At present, congruence strategies can only be used when Gom is used to generate the data-structure.

Not yet answered questions
--------------------------

### How efficient is the code generated by Tom?

### What happens if the data-structure is modified during matching?

### How does Tom depend on the Api's and semantics of Gom generated structures?

1.  On the maximal sharing
2.  On the 'setters'
3.  On 'compareTo()'
4.  On 'compareToLPO()'
5.  On 'equivalent(shared.SharedObject obj)'
6.  On 'public shared.SharedObject duplicate()'

(i.e. the compiler) does not depend on the Api of generated structures (i.e. nothing is known by the compiler).

However, when generating code, also generates a mapping. This one depends and exploits the particularity of the generated code.

1.  It uses `==` to compare terms in constant time, thanks to maximal sharing
2.  It does not use the 'setters'. They are generated to allow a programmer to use the data-structure directly, in a convenient way
3.  It does not use the 'compareTo()' nor 'compareToLPO()'. These methods are just there to help comparing terms
4.  It does not use 'equivalent' nor 'duplicate'. These methods are used internally, by the shared-object-factory to build terms with maximal sharing

When compiling `%strategy` constructs, the data-structure is supposed to implement `tom.library.sl.Visitable`.

### How could “grammar inheritance” become supported in Tom?

See <http://www.antlr2.org/doc/inheritance.html>.

Would like to have a Java grammar (Class, Method, etc) and then to define another grammar for Struts, for example, to have ActionClass and ActionMethod. Then when matching Class to also find ActionClass.