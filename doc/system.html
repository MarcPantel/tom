<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.06">
<TITLE>
 Tom core
</TITLE>
</HEAD>
<BODY TEXT=black BGCOLOR=white>
<A HREF="install.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="manual.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="language.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#0f75ff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc8"><B><FONT SIZE=6>Chapter&nbsp;2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=6><FONT COLOR=navy>Tom</FONT></FONT></B><B><FONT SIZE=6> core</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>

This part of the manual gives basic information on <FONT COLOR=navy>Tom</FONT> internals.<BR>
<BR>
<A NAME="toc5"></A><TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc9"><B><FONT SIZE=5>2.1</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>Introduction</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
The current version of <FONT COLOR=navy>Tom</FONT> is written in
<FONT COLOR=purple>Java</FONT>+<FONT COLOR=navy>Tom</FONT> itself. 
It reads the program to be compiled and builds an abstract syntax tree
(AST) to represent the program.
The compiler is made up of stages, each of which can be seen as a
process that transforms the AST into a new one. After the last transformation,
the AST reprents a program closed to an imperative program.
The last stage of the compiler is a generation phase that transform
the AST into a concrete program written in <FONT COLOR=purple>C</FONT> or <FONT COLOR=purple>Java</FONT>, depending 
on the chosen target language.<BR>
<BR>
<A NAME="toc6"></A><TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc10"><B><FONT SIZE=5>2.2</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>The front-end</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
The front-end is the part of the system that reads the input program
and builds the associated abstract syntax tree.
This parts contains three components:
<UL><LI>
a parser: this stage reads a concrete program written in the
 target language embedded with some <FONT COLOR=navy>Tom</FONT> constructs, and build a
 first AST.
<LI>an expander: this stage performs some very simple
 transformations such as macro expansion.
<LI>a type checker: this stage add some type information to the AST
 (all untyped vaiables become a typed variable for example).
</UL>
Because <FONT COLOR=navy>Tom</FONT> is language independant, parsing a <FONT COLOR=navy>Tom</FONT> program is not
so easy. A solution could consists in implementing a specialized
parser for each supported target language (one for <FONT COLOR=purple>C</FONT>+<FONT COLOR=navy>Tom</FONT>, and
another one for <FONT COLOR=purple>Java</FONT>+<FONT COLOR=navy>Tom</FONT>), but for simplicity, and to keep the <FONT COLOR=navy>Tom</FONT>
system as simple as possible, we decided to implement a common parser,
slightly specialised for each considered target language. 
When considering <FONT COLOR=purple>C</FONT> and <FONT COLOR=purple>Java</FONT>, we noticed that it is only needed to
know how to recognize a string, a comment and a block to be able to
make the difference between a target language construct and a <FONT COLOR=navy>Tom</FONT>construct.<BR>
<BR>
The main idea consists in synchronising the parser on several
characters such as `<TT>%</TT>',`<TT>"</TT>', `<TT>{</TT>' and
`<TT>}</TT>'. For this purpose we decided to use <FONT COLOR=purple>Javacc</FONT> and
the lexical-mode facilities. Basically, the parser can be in two
differents modes: <TT>TomConstruct</TT> mode and
<TT>TargetLanguage</TT> mode.
When being in the <TT>TargetLanguage</TT> mode, the parser reads
everything unless a <FONT COLOR=navy>Tom</FONT> construct (beginning with a `<TT>%</TT>'
character) is recognized. Of course, this construct should not be in a
target language string or comment. This explain why it is needed to be
able to recognized such target language constructs.
Once a <FONT COLOR=navy>Tom</FONT> construct is recognized, the parser is switched to the
<TT>TomConstruct</TT> mode, and the considered construct can be
easilly parsed. 
We should notice that a <FONT COLOR=navy>Tom</FONT> construct can also contains a target
language part (always between `<TT>{</TT>' and `<TT>}</TT>').
When parsing such a part, the parser first reads a `<TT>{</TT>', and
then is looking for a corresponding `<TT>}</TT>': for each
encountered&nbsp;`<TT>}</TT>', it has to know if the read expression is
well parenthesed or not. This explains why it is needed to be able to
recognize and count the target language open and close block
commands. <BR>
<BR>
<A NAME="toc7"></A><TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc11"><B><FONT SIZE=5>2.3</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>The compiler</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
The compiler receives as input an AST that merely corresponds to the 
input <FONT COLOR=navy>Tom</FONT> program (this is roughly a list of interleaved target
language constructs and <FONT COLOR=navy>Tom</FONT> constructs).
The goal of the compiler consists in transforming this AST into a
``simpler one'': an AST that can be easilly translated into an
imperative program (a <FONT COLOR=purple>C</FONT> or a <FONT COLOR=purple>Java</FONT> program for example).<BR>
<BR>
The kernel of the compiler contains a procedure that transforms a set
of patterns into a automaton that implements a matching algorithm
corresponding to the considered set of patterns. 
This automaton is then compiled into abstract instructions of the
form: <TT>IfThenElse</TT>, <TT>Assign</TT>, <TT>ExitAction</TT>, 
<TT>ExecuteAction</TT>, etc. 
With such an approach, the most complex part of the compilation process
is completly independ from the chosen target language, and can easily
be reused.<BR>
<BR>
<A NAME="toc8"></A><TABLE CELLPADDING=0 CELLSPACING=0 WIDTH="100%">
<TR><TD BGCOLOR="#007fff"><DIV ALIGN=center><TABLE>
<TR><TD><A NAME="htoc12"><B><FONT SIZE=5>2.4</FONT></B></A></TD>
<TD WIDTH="100%" ALIGN=center><B><FONT SIZE=5>The back-end</FONT></B></TD>
</TR></TABLE></DIV></TD>
</TR></TABLE>
The back-end takes the last form of AST as input and generates a
concrete program written in the target language. This stage consists
in translating abstract instructions (like <TT>IfThenElse</TT>) into
concrete instructions (like <TT>if(cond) { instList }</TT>) in <FONT COLOR=purple>C</FONT>
or <FONT COLOR=purple>Java</FONT>. 
With such an approach, allows us to easily add a new back-end for any 
new supported target language.<BR>
<BR>
<HR>
<A HREF="install.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="manual.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="language.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
