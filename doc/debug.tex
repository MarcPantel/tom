\documentclass[a4paper]{article}
\usepackage{fullpage}
\usepackage{verbatim}

\newcommand{\TOM}{\textsf{TOM}}
\newcommand{\JTOM}{\textsf{JTOM}}
\newcommand{\C}{\textsf{C}}
\newcommand{\Java}{\textsf{Java}}
\newcommand{\Eiffel}{\textsf{Eiffel}}

\newenvironment{grammar}%
{\endgraf\verbatim}%
{\endverbatim}

\def\programboxed#1{\begingroup
  \def\verbatim@processline{%
    {\setbox0=\hbox{\the\verbatim@line}%
      \hsize=\wd0
      \the\verbatim@line\par}}%
  \setbox0=\vbox{\parskip=0pt\topsep=0pt\partopsep=0pt
    \verbatiminput{#1}}%
  \begin{center}\fbox{\box0}\end{center}%
  \endgroup}

\makeatletter

\newwrite\verbatim@out

\newenvironment{verbatimwrite}[1]%
 {\@bsphack
  \immediate\openout \verbatim@out #1
  \let\do\@makeother\dospecials\catcode`\^^M\active
  \def\verbatim@processline{%
    \immediate\write\verbatim@out{\the\verbatim@line}}%
  \verbatim@start}%
 {\immediate\closeout\verbatim@out\@esphack}

\makeatother

\author{J.~Guyon \and P.E.~Moreau}
\title{Debugging \TOM}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduction}
\TOM\ is a pattern matching compiler for multiple target languages.It
allows to intregrate term (tree) rewriting facilities in programming
languages such as \C, \Java\ or \Eiffel\ (called the target
languages).\TOM\ is both a language independant extension of the taget
languages and a
compiler.Indeed, \TOM\ takes a target language source code enriched by \TOM\
constructs and translate only the \TOM\ extension into the underlaying
target language. The resulting code needs to be compiled as classical
source code. Note that \TOM\ never use any semantic information of
the target language part of the source code and that it only parses in
details the recognized \TOM\ constructs.

This document aims to discuss the needs and benefits of a debugger for
such tool.Indeed, the result of \TOM\ compilation is a new source code
with compiled pattern matching code. But what debugging this new source code means?

In a first section we remind the main \TOM\ constructs.Then, we
discuss about the needs associated to debugging the generated code. At
the end, we discuss some approches and implementation alternatives.

\section{Main \TOM\ construct}
In this section, we give a short presentation of each key \TOM\
constructs as a reminder.

\subsection{Algebraic sorts and constructors}
\subsubsection{Defining the algebraic abstract data type}
In \TOM, terms, variables and patterns are many-sorted. Their sorts
have to be introduced by the ``\%typeterm'' primitive. It allows to
define the mapping between algebraic sort and its concrete sort in the
target language but
also to give the materials necessary for pattern matching implementation.
\begin{verbatimwrite}{program.txt}
  %typeterm Nat {
    implement { Term }
    get_fun_sym(t)      { t.getAFun()    }
    cmp_fun_sym(s1, s2) { t1 == t2       }
    get_subterm(t, n)   { t.getArg(n)    }
    equals(t1, t2)      { t1.isEqual(t2) } 
  }
\end{verbatimwrite}
\programboxed{program.txt}
\begin{description}
\item[implement:] describes how the algebraic type is
implemented.
\item[get-fun-sym(t):] denotes a function that returns the root
  symbol of the parameter.
\item[cmp-fun-sym(t1, t2)] denotes a predicate that returns ``true'' if the
  symbol parameters are ``equal''.
\item[get-subterm(t, n):] denotes a function that returns the n-th
  subterm of parameter t;
\item[equals(t1, t2):] denotes a predicate that returns ``true'' if the
  term parameters are ``equal''. (used in case of non-linear pattern)
\end{description}

\subsubsection{Many-sorted signature of operators}
In \TOM, the definition of a new operator is done via the ``\%op''
primitive. The many-sorted signature of operator is given in a prefix
notation. Let us consider the peano integer concept. Here is its \TOM\
definition where an integer is either zero either a successor of a integer:
\begin{verbatimwrite}{program2.txt}
  %op Nat suc(Nat) {
    fsym { f_suc }
    make(t) { factory.makeAppl(fsuc) }
    is_fsym(t) { ((((ATermAppl)t).getAFun()) == fsuc)  }
  }
  %op Nat zero {
    fsym { f_zero }
    make(t) { factory.makeAppl(fzero) }
    is_fsym(t) { ((((ATermAppl)t).getAFun()) == fzero)  }
  }
\end{verbatimwrite}
\programboxed{program2.txt}
\begin{description}
\item[fsym:] defines the concrete representation of the constructor.
\item[make(...):] 
\item[is-fsym(t):] 
\end{description}

\subsubsection{List sorts}
\TOM\ allows the use of list sorts by defining their corresponding
construct:
\begin{itemize}
\item \%typelist or \%typearray
\item \%oplist or \%oparray
\end{itemize}
\subsection{The ''MATCH`` construct}
The MATCH construct is the first core element of \TOM . Given a multisorted
signature, a list of pattern-actions allows to create a rewritting program.
\begin{verbatimwrite}{program3.txt}
  %typeterm Nat
  %op Nat zero
  %op Nat suc(Nat)
  %op Nat plus(Nat,Nat)

  Term plus(Term t1, Term t2) {
    %match (Nat t1, Nat t2){
      x, zero   -> { return x; }
      x, suc(y) -> { return suc(plus(x,y)) }
    }
  }
\end{verbatimwrite}
\programboxed{program3.txt}
\subsection{The ''BACKQUOTE`` construct}
The BACQUOTE construct is the second core element of \TOM. Given a
natural definition of a term, it allows to construct the corresponding
term. It also allows the use of \TOM\ operator and targuet languages
function called to be combined. See the example of the RULE construct.
\subsection{The ''RULE`` construct}
\begin{verbatimwrite}{program3.txt}
  %op Nat zero
  %op Nat suc(Nat)
  %op Nat fib(Nat)
  %op Nat plus(Nat,Nat)
  %rule {
    fib(zero)        -> suc(zero)
    fib(suc(zero))   -> suc(zero)
    fib(suc(suc(x))) -> `plus1(fib1(x),fib1(suc(x)))
  }
\end{verbatimwrite}
\programboxed{program3.txt}
The ``\%rule'' construct is nothing else that a shortcut for defining
a function using only pattern matching. This construct will be
converted during compilation in Match and Backquote constructs as the
similarity with following program show it.
\begin{verbatimwrite}{program4.txt}
  %op Nat zero
  %op Nat suc(Nat)
  %op Nat fib(Nat)
  %op Nat plus(Nat,Nat)
  Term fib(Term t) {
    %match (Nat t) {
    zero        ->  { return `suc(zero);    }
    suc(zero)   ->  { return `suc(zero);    }
    suc(suc(x)) ->  { return `plus(fib1(x),fib1(suc(x))) }
  }
\end{verbatimwrite}
\programboxed{program4.txt}

\newpage

\section{Needs link to debugging \TOM}
The questions resulting from term rewritting are often the same. These
concern the reason of a failure in rewritting a term. Is the subject
or the program (rewritting rules) in cause? Let suppose we have an
ideal debugger... What services could be expected from such a debugger?

\subsection{Using the existing debugger of the target language}
Once \TOM\ has generated the final source code, a first natural
solution of debugging could be to use a debugger associated with the
used target language. Indeed, all the actual managed languages like
\C, \Java\ or \Eiffel\ have their own debugger. They all
offer breakpoints and stack analyses support, but, one of the major drawback of such
method is a very low level of abstraction. Another one is the needs
for the user to understand matching algorithm compiled code:
this may be first not easy, nor wanted by the user. The user may like
to debug at the original \TOM\ source code level that is much better structured for pattern
matching algorithm analyses.

For example, a natural way of debugging a match construct could be to
put a breakpoint on a patter-action and not somewhere in the if-then-else
compiled code.This also supposes that the generated code is not buggy
and that the errors come from the way \TOM\ is used to make pattern matching.
So, the target language debugger could be used to debug comppiled code
by \TOM\ developers but it appears to be inefficient for debugging
\TOM\ code.

\subsection{Rewriting rule step by step}
Given a term (called subject) and a list a pairs pattern-action, the
match primitive selects a pattern that matches the subject and
performs the associated action.
The \TOM\ debugger shall assist the user in a step by step manner to
figure out what pattern succeeds or not.

The debugger shall allow the user to define what match constructs are
going to be analysed.

The debugger shall allow the user to define what specific patterns in
these match constructs are going to be analysed.

The debugger shall warn the user each time a match/pattern structure
is going to be evaluated, stop the evaluation and offer new services like:
\begin{itemize}
\item Showing the current subject with a pretty printer or with a
  graphical tools
\item Displaying the list of already done substitutions
\end{itemize}
\subsection{Follow the construction of specific terms}
The backquote construct can be used to easily create a term.

The debugger shall allow the user to define specific terms using the
user defined algebraic specification and be warned in case of such a
subject is created. 

Indeed, the users  often expect their programs will generate specific
terms and they may be interested to ensure that such terms are
created. In the other hand, when the result is not the expected one,
the user may want to understand when and why the result term has been
partly construct.

\subsection{Graphical pretty printer}
One of the main difficulties in term rewritting is the vizualization
of a term. Indeed, terms become easily huge and basic textual pretty printer
could easily generates hundred of line for a unique term, what is no
very pretty.

A graphical tools for vizualizing any term could become an advantage
for people not able to decode output of classical pretty printer.

\newpage

\section{How to debug \TOM\ program}

\subsection{Developping a new debugger}
As we see in the previous section, the debugging of \TOM\ code drive
us to specify our own debugger. The next subsections shows the
complexity of such a difficult way. 

\subsubsection{Code instrumentation and multiple
  target languages issues}

As the control about generated code is limited to compiling \TOM\
constructs, then our control on general and debugging control is
limited to this part.One solution is to enriched the generated code so
that it contains more debugging information, for example the origin
source code line in evaluation, but also it could be enriched but debugging
primitives... 

The notion of debugging primitives could be either direct call to a
debugger objet either the generation of events/indirect call that will
be catched by a debugger. This 2 solution leeds to 2 different approch:
\begin{itemize}
\item The first approch made the debugger part of the program as an
  internal component and this mean that we will have to create a
  debugger for each managed languages.
\item The second one leeds to a external independant debugger
  in an environment where we have communication facilities (to catch
  the event.). This way we can develop only one debugger and just
  develop wrappers for each languages. 
\end{itemize}
The first approch leeds to an important issue is the sens that in this
solution we will need to have a debugger instance for each target
language. So, this approch seems to be impossible if we want to extend
jtom to more languages. The second approch is the component view using
a communication facilities that could hide the implementation of the debugger.

\subsubsection{Initialization of the debugging session}

One of the first issue is link to the fact that \TOM\ does not control
all the final code. This means that for example in the main function
of the program, the user will have to do some work to initialize the
debugger. This intrusion in the user code has to be as ligth as possible.

For example. in \Java, this could be done by importing the debugging
library and in the main function the initialization of a dubugger
object.
In \C, there is a need for including a debug.h file, and maybe to link
by hand with the library.
 
As each language has its specificity (\C\ allows conditional compiler
directives), there is some crucial choice to made this initialization
as simple.


\subsubsection{User interface}
For the user interface point of view, a textual interface could be
sufficient if the debugger offers all necessary services. A graphical user
interface as TIDE does could be a nice to have but must be seen has a
new layer uppon the core debugger.

So, the idea is to have a powerfull debugger without graphical
interface. This could be a finalization of the debugger.

\subsection{Debugging mechanism implementation}
We can simplify the interaction between the program and the debugger
into 2 categories:
\begin{itemize}
\item Pure event for flow control without specific parameter. For
  exemple, ``ENTERINGPATTERN(pattern number)''...
\item Complex event with some user define term: ``TERMCREATION(term)''
\end{itemize}
This last point implies that we are able at the debugger level to
managed (understand, compare) all user define term definition. A
solution could to impose ATerm library so that each term is a ATerm
but this way we loose one of the most important benefits of \TOM: the
reuse of user definition. This means that as \TOM\ does, the debugger
has to be able to manipulate user defined term. This also means that
we have a generic way of sending/receiving such terms.
\subsubsection{Interaction with the debugger}
\subsubsection{Debugging match and rule construct}

\subsubsection{Watching terms}
This could be easily done by tracking the result of backquote construct call.

\end{document}
