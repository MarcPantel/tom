module TomInstruction
imports TomSignature
abstract syntax
Instruction = 
  | TomTermToInstruction(Tom:TomTerm)
  | TargetLanguageToInstruction(Tl:TargetLanguage)
  | If(Condition:Expression,SuccesInst:Instruction,FailureInst:Instruction)
  | DoWhile(DoInst:Instruction,Condition:Expression)
  | WhileDo(Condition:Expression,DoInst:Instruction)
  | Assign(Variable:TomTerm,Source:Expression)
            
  /**
   * <code>Let</code> declares and instanciates a variable surrounded by curlys - functional way
   * <code>LetRef</code> as above, but not functional
   * <code>LetAssign</code> instanciates a variable
   *
   * @param Variable a variable
   * @param Source the value to give to the variable
   * @param AstInstruction next instruction
   */
  | Let(Variable:TomTerm,Source:Expression,AstInstruction:Instruction)
  | LetRef(Variable:TomTerm,Source:Expression,AstInstruction:Instruction)
  | LetAssign(Variable:TomTerm,Source:Expression,AstInstruction:Instruction)
  /**/
  | Return(Kid1:TomTerm)
  | Nop()
  /*
   * AbstrackBlock: conversion from InstructionList to Instruction
   */
  | AbstractBlock(InstList:InstructionList)
  | UnamedBlock(InstList:InstructionList)
  | NamedBlock(BlockName:String,InstList:InstructionList)
  /**
   * <code>Match</code> a match instruction
   *
   * @param ConstraintInstructionList a list of (list of constraints and an action)
   */
  | Match(ConstraintInstruction:ConstraintInstruction, Option:OptionList)
  | CompiledMatch(AutomataInst:Instruction,Option:OptionList)
  | CompiledPattern(PatternList:TomList,AutomataInst:Instruction)
  /*
   * a RawAction is an action that comes from the original program 
   */
  | RawAction(AstInstruction:Instruction)

  /*
   * a TypeAction knows the constraints to which it is attached (PositivePattern),
   * and also the list of previously tried patterns, which are called negativePattern
   * This information is used to perform extra verification/certification
   */

  | TypedAction(AstInstruction:Instruction,PositivePattern:ConstraintList,NegativePatternList:ConstraintList)
  | AndInstruction(Instruction*)
  | OrInstruction(Instruction*)
  
/**
 * <code>ConstraintInstruction</code> a line in a match instruction - a touple (Constraint,Action)
 *
 * @param Constraint a constraint (can be a OR or an AND)
 * @param Action the action to execute if the constraints are evaluated to true
 */  
ConstraintInstruction = ConstraintInstruction(Constraint:Constraint, Action:Instruction, Option:OptionList)  
ConstraintInstructionList = concConstraintInstruction(ConstraintInstruction*)    
  
AndInstruction:AU() { }
OrInstruction:AU() { }  

InstructionList = concInstruction(Instruction*)
concInstruction:make_insert(e,l) {
  %match(e) {
    AbstractBlock(l1) -> { return `concInstruction(l1*,l*); }
  }
}
