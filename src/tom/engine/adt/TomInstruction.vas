module TomInstruction
imports TomSignature 

public
sorts InstructionList Instruction 

abstract syntax

TomTermToInstruction(tom:TomTerm) -> Instruction
TargetLanguageToInstruction(tl:TargetLanguage) -> Instruction
If(condition:Expression,succesInst:Instruction,failureInst:Instruction) -> Instruction
DoWhile(doInst:Instruction,condition:Expression) -> Instruction
WhileDo(condition:Expression,doInst:Instruction) -> Instruction
Assign(variable:TomTerm,source:Expression) -> Instruction
Let(variable:TomTerm,source:Expression,astInstruction:Instruction) -> Instruction
LetRef(variable:TomTerm,source:Expression,astInstruction:Instruction) -> Instruction
LetAssign(variable:TomTerm,source:Expression,astInstruction:Instruction) -> Instruction
AssignMatchSubject(kid1:TomTerm,source:Expression) -> Instruction
Return(kid1:TomTerm) -> Instruction
Nop() -> Instruction
AbstractBlock(instList:InstructionList) -> Instruction
UnamedBlock(instList:InstructionList) -> Instruction
NamedBlock(blockName:String,instList:InstructionList) -> Instruction
RuleSet(ruleList:TomRuleList,orgTrack:Option) -> Instruction
Match(subjectList:TomTerm,astPatternInstructionList:PatternInstructionList,option:OptionList) -> Instruction
CompiledMatch(automataInst:Instruction,option:OptionList) -> Instruction
CompiledPattern(patternList:TomList,automataInst:Instruction) -> Instruction
MatchingCondition(lhs:TomTerm,rhs:TomTerm) -> Instruction
TypedEqualityCondition(tomType:TomType,lhs:TomTerm,rhs:TomTerm) -> Instruction
EqualityCondition(lhs:TomTerm,rhs:TomTerm) -> Instruction
MakeFunctionBegin(astName:TomName,subjectListAST:TomTerm) -> Instruction
MakeFunctionEnd() -> Instruction
FunctionDef(astName:TomName,argumentList:TomList,codomain:TomType,throwsType:TomType,instruction:Instruction) -> Instruction
CheckStamp(variable:TomTerm) -> Instruction
concInstruction(Instruction*) -> InstructionList

/*
 * In Java only: check that source is an instance of astType, and then execute inst
 * Otherwise: perform inst 
 */
CheckInstance(astType:TomType,source:Expression,instruction:Instruction) -> Instruction

/*
 * a RawAction is an action that comes from the original program 
 */
RawAction(astInstruction:Instruction) -> Instruction

/*
 * a TypeAction knows the pattern to which it is attached (positivePattern),
 * and also the list a previously tried patterns, which are called negativePattern
 * This information is used to perform extra verification/certification
 */
TypedAction(astInstruction:Instruction,positivePattern:Pattern,negativePatternList:PatternList) -> Instruction
