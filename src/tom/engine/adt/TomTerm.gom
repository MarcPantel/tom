module TomTerm
imports TomSignature TomName int
abstract syntax

TomTerm =
  /**
   * <code>TermAppl</code> application of a symbol to a list of subterms
   *
   * @param Option a list of options
   * @param NameList a list of head symbol names (more than one in case of a disjunction)
   * @param Args a list of subterms
   * @param Slots a list of pairs (slot,subterm)
   * @param Constraints a list of constraints
   */
    | TermAppl(Option:OptionList,NameList:TomNameList,Args:TomList,Constraints:ConstraintList)
  /**
   * <code>RecordAppl</code> application of a symbol to a list of pairs (slot,subterm)
   *
   * @param Option a list of options
   * @param NameList a list of head symbol names
   * @param Args a list of subterms
   * @param Slots a list of pairs (slot,subterm)
   * @param Constraints a list of constraints
   */
    | RecordAppl(Option:OptionList,NameList:TomNameList,Slots:SlotList,Constraints:ConstraintList)
  /**
   * <code>XMLAppl</code> application of a xml-symbol to a list of attributes and a list of subterms
   *
   * @param Option a list of options
   * @param NameList a list of head symbol names
   * @param Args a list of subterms
   * @param Slots a list of pairs (slot,subterm)
   * @param Constraints a list of constraints
   */
    | XMLAppl(Option:OptionList,NameList:TomNameList,AttrList:TomList,ChildList:TomList,Constraints:ConstraintList)
  /** 
   * <code>Variable</code> a variable
   *
   * @param Option a list of options
   * @param AstName the name of the variable
   * @param AstType the type of the variable
   * @param Constraints a list of constraints
   */
    | Variable(Option:OptionList,AstName:TomName,AstType:TomType,Constraints:ConstraintList)
  /** 
   * <code>VariableStar</code> a list-variable
   *
   * @param Option a list of options
   * @param AstName the name of the variable
   * @param AstType the type of the variable
   * @param Constraints a list of constraints
   */
    | VariableStar(Option:OptionList,AstName:TomName,AstType:TomType,Constraints:ConstraintList)
  /** 
   * <code>UnamedVariable</code> a variable without name
   *
   * @param Option a list of options
   * @param AstName the name of the variable
   * @param AstType the type of the variable
   * @param Constraints a list of constraints
   */
    | UnamedVariable(Option:OptionList,AstType:TomType,Constraints:ConstraintList)
  /** 
   * <code>UnamedVariableStar</code> a list-variable without name
   *
   * @param Option a list of options
   * @param AstName the name of the variable
   * @param AstType the type of the variable
   * @param Constraints a list of constraints
   */
    | UnamedVariableStar(Option:OptionList,AstType:TomType,Constraints:ConstraintList)
  /**
   * <code>VariableHeadList</code> a head list that is variable ( starting from begining to end )
   *
   * @param Option a list of options
   * @param AstName the name of the variable
   * @param AstType the type of the variable
   * @param Constraints a list of constraints
   */
    | VariableHeadList(Opname:TomName,Begin:TomTerm,End:TomTerm)
  /**
   * <code>VariableHeadArray</code> a head array that is variable ( starting from begining to end )
   *
   * @param Option a list of options
   * @param AstName the name of the variable
   * @param AstType the type of the variable
   * @param Constraints a list of constraints
   */
    | VariableHeadArray(Opname:TomName,Subject:TomTerm,BeginIndex:TomTerm,EndIndex:TomTerm)
  /**
   * <code>TestVar</code> instead of generating an assignment, this generates an equality test
   *
   * @param Option a list of options
   * @param AstName the name of the variable
   * @param AstType the type of the variable
   * @param Constraints a list of constraints
   */
    | TestVar(Variable:TomTerm)
  /**
   * <code>ListHead</code> represents the head of a list
   *
   * @param Opname operator's name
   * @param Codomain the type of the operator
   * @param Variable the list from which to extract the head / tail
   */
	  | ListHead(Opname:TomName,Codomain:TomType,Variable:TomTerm)
  /**
   * <code>ListTail</code> the tail of a list
   *
   * @param Opname operator's name
   * @param Codomain the type of the operator
   * @param Variable the list from which to extract the head / tail
   */
  	| ListTail(Opname:TomName,Variable:TomTerm)  		   

  /**
   * <code>...ToTomTerm</code> wrappers to convert a type into TomTerm
   */
    | TargetLanguageToTomTerm(Tl:TargetLanguage)
    | TomTypeToTomTerm(AstType:TomType)
    | TomNameToTomTerm(AstName:TomName)
    | TomSymbolToTomTerm(AstSymbol:TomSymbol)
    | DeclarationToTomTerm(AstDeclaration:Declaration)
    | OptionToTomTerm(Option:OptionList)
    | ExpressionToTomTerm(AstExpression:Expression)
    | InstructionToTomTerm(AstInstruction:Instruction)

  /**
   * <code>Tom</code> main construct to embed a Tom island
   * It will be generated on a single line
   * @param Tomlist a list of TomTerm that correspond to islands or lakes
   */
    | Tom(TomList:TomList)
  /**
   * <code>TomInclude</code> like <code>Tom</code>, but corresponds to an include.
   * It will be generated on a single line
   * @param Tomlist a list of TomTerm that correspond to islands or lakes
   */
    | TomInclude(TomList:TomList)

    | BackQuoteAppl(Option:OptionList,AstName:TomName,Args:TomList)
    | Composite(Args:TomList)

    | SubjectList(TomList:TomList)
    | Term(TomTerm:TomTerm)
    | AntiTerm(TomTerm:TomTerm)
    | Subterm(AstName:TomName,SlotName:TomName,GroundTerm:TomTerm)
    | SymbolOf(GroundTerm:TomTerm)

    | Automata(Option:OptionList,Constraint:Constraint,NumberList:TomNumberList,Inst:Instruction)

    | BuildReducedTerm(TomTerm:TomTerm,AstType:TomType)
  /**
   * <code>FunctionCall</code> generates a function call
   *
   * @param AstName the name of the symbol
   * @param AstType the codomain of the function call, EmptyType if not known
   */
    | FunctionCall(AstName:TomName,AstType:TomType,Args:TomList)
    | BuildConstant(AstName:TomName)
    | BuildTerm(AstName:TomName,Args:TomList,ModuleName:String)
    | BuildEmptyList(AstName:TomName)
    | BuildConsList(AstName:TomName,HeadTerm:TomTerm,TailTerm:TomTerm)
    | BuildAppendList(AstName:TomName,HeadTerm:TomTerm,TailTerm:TomTerm)
    | BuildEmptyArray(AstName:TomName,Size:TomTerm)
    | BuildConsArray(AstName:TomName,HeadTerm:TomTerm,TailTerm:TomTerm)
    | BuildAppendArray(AstName:TomName,HeadTerm:TomTerm,TailTerm:TomTerm)

TomList = concTomTerm(TomTerm*)
