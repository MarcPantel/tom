module TomTerm
imports TomSignature TomName int
abstract syntax

TomTerm =

  /**
   * <code>TermAppl</code> application of a symbol to a list of subterms
   * <code>ListAppl</code> application of a list-symbol to a list of subterms
   * <code>RecordAppl</code> application of a symbol to a list of pairs (slot,subterm)
   * <code>XMLAppl</code> application of a xml-symbol to a list of attributes and a list of subterms
   *
   * @param Option a list of options
   * @param NameList a list of head symbol names
   * @param Args a list of subterms
   * @param Slots a list of pairs (slot,subterm)
   * @param Constraints a list of constraints
   */
    | TermAppl(Option:OptionList,NameList:TomNameList,Args:TomList,Constraints:ConstraintList)
    | RecordAppl(Option:OptionList,NameList:TomNameList,Slots:SlotList,Constraints:ConstraintList)
    | XMLAppl(Option:OptionList,NameList:TomNameList,AttrList:TomList,ChildList:TomList,Constraints:ConstraintList)

  /**
   * <code>Variable</code> a variable
   * <code>VariableStar</code> a list-variable
   * <code>UnamedVariable</code> a variable without name
   * <code>UnamedVariableStar</code> a list-variable without name
   * <code>VariableHeadList</code> a head list that is variable ( starting from begining to end )
   * <code>VariableArrayList</code> a head array that is variable ( starting from begining to end )
   * <code>TestVar</code> instead of generating an assignment, this generates an equality test
   *
   * @param Option a list of options
   * @param AstName the name of the variable
   * @param AstType the type of the variable
   * @param Constraints a list of constraints
   */
    | Variable(Option:OptionList,AstName:TomName,AstType:TomType,Constraints:ConstraintList)
    | VariableStar(Option:OptionList,AstName:TomName,AstType:TomType,Constraints:ConstraintList)
    | UnamedVariable(Option:OptionList,AstType:TomType,Constraints:ConstraintList)
    | UnamedVariableStar(Option:OptionList,AstType:TomType,Constraints:ConstraintList)
    | VariableHeadList(Opname:TomName,Begin:TomTerm,End:TomTerm)
    | VariableHeadArray(Opname:TomName,Subject:TomTerm,BeginIndex:TomTerm,EndIndex:TomTerm)
    | TestVar(Variable:TomTerm)
  /**
   * <code>ListHead</code> represents the head of a list
   * <code>ListTail</code> the tail of a list
   *
   * @param Opname operator's name
   * @param Codomain the type of the operator
   * @param Variable the list from which to extract the head / tail
   */
	| ListHead(Opname:TomName,Codomain:TomType,Variable:TomTerm)
  | ListTail(Opname:TomName,Variable:TomTerm)  		   

  /**
   * <code>...ToTomTerm</code> wrappers to convert a type into TomTerm
   */
    | TargetLanguageToTomTerm(Tl:TargetLanguage)
    | TomTypeToTomTerm(AstType:TomType)
    | TomNameToTomTerm(AstName:TomName)
    | TomSymbolToTomTerm(AstSymbol:TomSymbol)
    | DeclarationToTomTerm(AstDeclaration:Declaration)
    | OptionToTomTerm(Option:OptionList)
    | ExpressionToTomTerm(AstExpression:Expression)
    | InstructionToTomTerm(AstInstruction:Instruction)

  /**
   * <code>Tom</code> main construct to embed a Tom island
   * <code>TomInclude</code> like <code>Tom</code>, but corresponds to an include.
   * It will be generated on a single line
   * @param Tomlist a list of TomTerm that correspond to islands or lakes
   */
    | Tom(TomList:TomList)
    | TomInclude(TomList:TomList)

    | BackQuoteAppl(Option:OptionList,AstName:TomName,Args:TomList)
    | Composite(Args:TomList)

    | SubjectList(TomList:TomList)
    | Term(TomTerm:TomTerm)
    | AntiTerm(TomTerm:TomTerm)
    | Subterm(AstName:TomName,SlotName:TomName,GroundTerm:TomTerm)
    | SymbolOf(GroundTerm:TomTerm)
    | Ref(TomTerm:TomTerm)

    | Automata(Option:OptionList,PatternList:TomList,NumberList:TomNumberList,Inst:Instruction)

    | BuildReducedTerm(TomTerm:TomTerm,AstType:TomType)
  /**
   * <code>FunctionCall</code> generates a function call
   *
   * @param AstName the name of the symbol
   * @param AstType the codomain of the function call, EmptyType if not known
   */
    | FunctionCall(AstName:TomName,AstType:TomType,Args:TomList)
    | BuildConstant(AstName:TomName)
    | BuildTerm(AstName:TomName,Args:TomList,ModuleName:String)
    | BuildEmptyList(AstName:TomName)
    | BuildConsList(AstName:TomName,HeadTerm:TomTerm,TailTerm:TomTerm)
    | BuildAppendList(AstName:TomName,HeadTerm:TomTerm,TailTerm:TomTerm)
    | BuildEmptyArray(AstName:TomName,Size:int)
    | BuildConsArray(AstName:TomName,HeadTerm:TomTerm,TailTerm:TomTerm)
    | BuildAppendArray(AstName:TomName,HeadTerm:TomTerm,TailTerm:TomTerm)

  /**
   * <code>Pattern</code> a lhs of rule, composed by a list of terms with variables
   *
   * @param SubjectList the list of subjects against which the pattern is matched
   * @param TomList the list of terms 
   * @param Guards a list of constraints
   */
Pattern = Pattern(SubjectList:TomList,TomList:TomList,Guards:TomList)
  /**
   * <code>PatternInstruction</code> a tuple (Pattern,Action)
   *
   * @param Pattern the lhs
   * @param Action the instruction to be executed
   * @param Option 
   */
PatternInstruction = PatternInstruction(Pattern:Pattern,Action:Instruction,Option:OptionList)

PatternList = concPattern(Pattern*)
PatternInstructionList = concPatternInstruction(PatternInstruction*)

TomList = concTomTerm(TomTerm*)

  /*
   * Hooks
   */

  Ref:make(e) {
    %match(e) {
      ExpressionToTomTerm[] -> { return e; }
    }
  }
