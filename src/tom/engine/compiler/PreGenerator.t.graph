/*
 *
 * TOM - To One Matching Compiler
 *
 * Copyright (c) 2000-2008, INRIA
 * Nancy, France.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 *
 * Radu Kopetz e-mail: Radu.Kopetz@loria.fr
 * Pierre-Etienne Moreau  e-mail: Pierre-Etienne.Moreau@loria.fr
 *
 **/
package tom.engine.compiler;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Set;

import tom.engine.TomBase;
import tom.engine.adt.tomterm.types.*;
import tom.engine.adt.tomname.types.*;
import tom.engine.adt.tomname.types.tomname.*;
import tom.engine.adt.tominstruction.types.*;
import tom.engine.adt.tomconstraint.types.*;
import tom.engine.adt.tomconstraint.types.constraint.*;
import tom.engine.adt.tomexpression.types.*;
import tom.engine.tools.SymbolTable;
import tom.engine.tools.TomConstraintPrettyPrinter;
import tom.engine.compiler.generator.*;
import tom.engine.exception.TomRuntimeException;
import tom.engine.adt.tomsignature.types.*;
import tom.engine.adt.tomtype.types.*;
import tom.library.sl.*;
import org._3pq.jgrapht.alg.CycleDetector;
import org._3pq.jgrapht.traverse.TopologicalOrderIterator;
import org._3pq.jgrapht.graph.DefaultDirectedGraph;

import java.util.logging.Logger;
import java.util.logging.Level;
import tom.engine.TomMessage;

/**
 * This class is in charge with all the pre treatments for generation needed
 * after the propagation process
 * 1. make sure that the constraints are in the good order
 * 2. translate constraints into expressions ...
 */
public class PreGenerator {

  // ------------------------------------------------------------
  %include { ../adt/tomsignature/TomSignature.tom }
  %include { ../../library/mapping/java/sl.tom}
  // ------------------------------------------------------------

  private static Logger logger = Logger.getLogger("tom.engine.compiler.Compiler");
  private ConstraintGenerator constraintGenerator;
  private TomConstraintPrettyPrinter printer = new TomConstraintPrettyPrinter();

  public PreGenerator(ConstraintGenerator myConstraintGenerator) {
    this.constraintGenerator = myConstraintGenerator;
  } 

  public ConstraintGenerator getConstraintGenerator() {
    return this.constraintGenerator;
  }

  public Expression performPreGenerationTreatment(Constraint constraint) throws VisitFailure {
    //System.out.println(printer.prettyPrint(constraint));
    //long startChrono = System.currentTimeMillis();
    constraint = orderConstraints(constraint);
    //logger.log(Level.INFO, TomMessage.tomSchedulingPhase.getMessage(),
    //    Integer.valueOf((int)(System.currentTimeMillis()-startChrono)) );
    //System.out.println(printer.prettyPrint(constraint));
    return constraintsToExpressions(constraint);
  }

  private Constraint orderConstraints(Constraint constraint) {
    %match(constraint) {
      !AndConstraint(_*,OrConstraint(_*),_*) && AndConstraint(_*) << constraint  -> {
        return orderAndConstraint(constraint);
      }
      AndConstraint(X*,or@OrConstraint(_*),Y*) -> {
        return orderAndConstraint(`AndConstraint(X*,orderConstraints(or),Y*));
      }
      /*
      OrConstraint(andC@AndConstraint(_*)) -> {
        return `OrConstraint(orderConstraints(andC));
      }
      or@OrConstraint(!AndConstraint(_*)) -> {
        return `or;
      }
      */
    }
    return constraint;
  }
  
  public Constraint orderAndConstraint(Constraint constraint) {
    CycleDetector cycleDetector;
    DefaultDirectedGraph g;
    g = new DefaultDirectedGraph();
    %match(constraint) {
      AndConstraint(_*,c,_*) -> {
        g.addVertex(`c);
      }
    }
    
    for (Object first: g.vertexSet()) {
      for (Object second: g.vertexSet()) {
        %match(first,second) {

          /*
           * SwitchSymbolOf
           *
           * z << subterm(i,g) /\ S /\ f = SymbolOf(g) -> f = SymbolOf(g) /\ S /\ z << subterm(i,g)
           *
           */
          MatchConstraint(_,SymbolOf(g)), MatchConstraint(_,Subterm[GroundTerm=g]) -> {
            g.addEdge(`first,`second);
          }

          /*
           * SwitchSymbolOf2
           *
           * A = SymbolOf(g) /\ S /\ g << B -> g << B /\ S /\ A = SymbolOf(g)
           *
           */
          MatchConstraint((Variable|VariableStar)[AstName=name,AstType=type],_), MatchConstraint(_,SymbolOf((Variable|VariableStar)[AstName=name,AstType=type])) -> {
            g.addEdge(`first,`second);
          }
          /*
           * SwitchAnti
           *
           * an antimatch should be always at the end, after the match constraints
           * ex: for f(!x,x) << t -> we should generate x << t_2 /\ !x << t_1 and
           * not !x << t_1 /\ x << t_2 because at the generation the free x should
           * be propagated and not the other one
           */
          MatchConstraint[], AntiMatchConstraint[]-> {
            g.addEdge(`first,`second);
          }

          /*
           * SwitchEmpty - lists
           *
           * EmptyList(z) /\ S /\ z << t -> z << t /\ S /\ EmptyList(z)
           * Negate(EmptyList(z)) /\ S /\ z << t -> z << t /\ S /\ Negate(EmptyList(z))
           */
          MatchConstraint(VariableStar[AstName=name,AstType=type],_),_
            && ( EmptyListConstraint[Variable=VariableStar[AstName=name,AstType=type]] << second || Negate(EmptyListConstraint[Variable=VariableStar[AstName=name,AstType=type]]) << second ) -> {
              g.addEdge(`first,`second);
            }

          /*
           * SwitchEmpty - arrays
           *
           * EmptyArray(z) /\ S /\ z << t -> z << t /\ S /\ EmptyArray(z)
           * Negate(EmptyArray(z)) /\ S /\ z << t -> z << t /\ S /\ Negate(EmptyArray(z))
           */
          MatchConstraint(v1,_),_
            && ( EmptyArrayConstraint[Index=idx,Variable=v2] << second || Negate(EmptyArrayConstraint[Index=idx,Variable=v2]) << second ) 
            && ( v1==idx || v2==v1 ) -> {
              g.addEdge(`first,`second);
            }

          /*
           * SwitchVar
           * TODO : replace with constraints when the or bugs in the optimizer are solved + the or is correctly handled for lists, i.e. with the duplication of the action
           * S1[p << Context[z]] /\ S2 /\ S3[z << t] -> S3[z << t] /\ S2 /\ S1[p << Context[z]]
           */
          MatchConstraint(v@(Variable|VariableStar)[],_),c -> {
            try {
              //`TopDown(FindMatchOrNumericConstraint(v)).visitLight(`c);
              `FindMatchOrNumericConstraint(v).visitLight(`c);
            } catch(VisitFailure ex) {
              g.addEdge(`first,`second);
            }
          }
          OrConstraintDisjunction(AndConstraint?(_*,MatchConstraint(v@(Variable|VariableStar)[],_),_*),_*),c -> {
            try {
              //`TopDown(FindMatchOrNumericConstraint(v)).visitLight(`c);
              `FindMatchOrNumericConstraint(v).visitLight(`c);
            } catch(VisitFailure ex) {
              g.addEdge(`first,`second);
            }
          }

          /*
           * p << ListHead(z) /\ S /\ Negate(Empty(z)) -> Negate(Empty(z)) /\ S /\ p << ListHead(z)
           * p << ListTail(z) /\ S /\ Negate(Empty(z)) -> Negate(Empty(z)) /\ S /\ p << ListTail(z)
           *
           * p << ListHead(z) /\ S /\ Empty(z) -> Empty(z) /\ S /\ p << ListHead(z)
           * p << ListTail(z) /\ S /\ Empty(z) -> Empty(z) /\ S /\ p << ListTail(z)
           *
           */
          _, MatchConstraint(_,(ListHead|ListTail)[Variable=VariableStar[AstName=name,AstType=type]])
            && ( Negate(EmptyListConstraint[Variable=VariableStar[AstName=name,AstType=type]]) << first || EmptyListConstraint[Variable=VariableStar[AstName=name,AstType=type]] << first ) -> {
              g.addEdge(`first,`second);
            }

          /*
           * p << GetElement(z) /\ S /\ Negate(EmptyArray(z)) -> Negate(EmptyArray(z)) /\ S /\ p << GetElement(z)
           * p << GetElement(z) /\ S /\ EmptyArray(z) -> EmptyArray(z) /\ S /\ p << GetElement(z)
           */
          _, MatchConstraint(_,ExpressionToTomTerm(GetElement[Variable=v]))
            && ( Negate(EmptyArrayConstraint[Index=v]) << first || EmptyArrayConstraint[Index=v] << first ) -> {
              g.addEdge(`first,`second);
            }

          /*
           * p << e /\ S /\ VariableHeadList(b,e) -> VariableHeadList(b,e) /\ S /\ p << e
           * p << e /\ S /\ VariableHeadArray(b,e) -> VariableHeadArray(b,e) /\ S /\ p << e
           */
          MatchConstraint(_,subjectSecond), MatchConstraint(_,v@VariableStar[])
            && (VariableHeadList[End=v] << subjectSecond || VariableHeadArray[EndIndex=v] << subjectSecond ) -> {
              g.addEdge(`first,`second);

            }

          /*
           * TODO:SwitchNumericConstraints
           *
           * an numeric constraint on a variable x should be always imediately after the
           * instantiation of the variable x, as it may improve the efficiency by abandoning the tests earlier
           * 
           * it should not go upper than the declaration of one of its variables (the last 2 conditions)
           */

          /*
           * SwitchIsSort
           *
           *  Match(_,subject) /\ IsSort(subject) -> IsSort(subject) /\ Match(_,subject)
           *
           *  IsSort(var) /\ Match(var,_) -> Match(var,_) /\ IsSort(var)
           *
           */
          IsSortConstraint[TomTerm=sub], MatchConstraint[Subject=ExpressionToTomTerm(Cast[Source=TomTermToExpression(sub)])] -> {
            g.addEdge(`first,`second);
          }

          MatchConstraint(var@(Variable|VariableStar)[AstName=name,AstType=type],_), IsSortConstraint[TomTerm=(Variable|VariableStar)[AstName=name,AstType=type]] -> {
            g.addEdge(`first,`second);
          }

          /*
           * SwitchTestVars
           *
           * tests generated by replace shoud be after the variable has been instanciated
           */
          MatchConstraint((Variable|VariableStar)[AstName=name,AstType=type],_), MatchConstraint(TestVar((Variable|VariableStar)[AstName=name,AstType=type]),_) -> {        
            g.addEdge(`first,`second);
          }

        }
      }
    }

    // Are there cycles in the dependencies.
    cycleDetector = new CycleDetector(g);
    // Cycle(s) detected.
    if (cycleDetector.detectCycles()) {
      Iterator<Constraint> iterator;
      Set<Constraint> cycleVertices;
      Set<Constraint> subCycle;
      Constraint cycle;
      System.out.println("Cycles detected.");
      // Get all vertices involved in cycles.
      cycleVertices = cycleDetector.findCycles();
      // Loop through vertices trying to find disjoint cycles.
      while (! cycleVertices.isEmpty()) {
        //System.out.println("Cycle:");
        // Get a vertex involved in a cycle.
        iterator = cycleVertices.iterator();
        cycle = (Constraint) iterator.next();

        // Get all vertices involved with this vertex.
        subCycle = cycleDetector.findCyclesContainingVertex(cycle);
        for (Constraint sub : subCycle) {
          System.out.println("   " + printer.prettyPrint(sub));
          // Remove vertex so that this cycle is not encountered
          // again.
          cycleVertices.remove(sub);
        }
      }
      throw new RuntimeException("Cycle detected!");
    }

    // No cycles.  Just output properly ordered vertices.
    else {
      TopologicalOrderIterator orderIterator;
      orderIterator =
        new TopologicalOrderIterator(g);
      Constraint c = `AndConstraint();
      while (orderIterator.hasNext()) {
        c = AndConstraint(c*,(Constraint) orderIterator.next());
      }

      /* 
       * The intialisation of the end variables for lists and arrays must be
       * declared at the same imbrication level than the corresponding
       * VariableHeadLits-Array constraint
       */

      Constraint tmp = c;
      do {
        c=tmp;
        %match(c) {
          AndConstraint(X1*,m1@MatchConstraint(v@VariableStar[],_),X2*,m2@MatchConstraint(_,(VariableHeadList|VariableHeadArray)[]),X3*,m3@MatchConstraint(_,subjectSecond),X4*)
            && (VariableHeadList[End=v] << subjectSecond || VariableHeadArray[EndIndex=v] << subjectSecond ) -> {
              tmp= `AndConstraint(X1*,X2*,m2,X3*,m1,m3,X4*);
            }
        }
      } while(c!=tmp);

      return c;
    
    }
  }

  /**
   * Checks if the term is inside
   */
  %strategy HasTerm(term:TomTerm) extends Identity() {
    visit TomTerm {
      // do not compare OptionList (because variables can appear in differents lines)
      (Variable|VariableStar)[AstName=name,AstType=(Type|TypeWithSymbol)[TomType=type]] -> {
        if (`type == term.getAstType().getTomType() && `name == term.getAstName()) {
          throw new VisitFailure();
        }
      }

      (Subterm|SymbolOf)[GroundTerm=GroundTerm] -> {
        this.visitLight(`GroundTerm);
      }
      (ListHead|ListTail|TestVar)[Variable=Variable] -> {
        this.visitLight(`Variable);
      }
      VariableHeadList[Begin=Begin,End=End] -> {
        this.visitLight(`Begin);
        this.visitLight(`End);
      }
      VariableHeadArray[Subject=Subject,BeginIndex=BeginIndex,EndIndex=EndIndex] -> {
        this.visitLight(`Subject);
        this.visitLight(`BeginIndex);
        this.visitLight(`EndIndex);
      }
      ExpressionToTomTerm(exp) -> {
        this.visitLight(`exp);
      }
      (BackQuoteAppl|Composite|FunctionCall|BuildTerm)[Args=list] -> {
        this.visitLight(`list);
      }

      TermAppl[Args=Args] -> {
        this.visitLight(`Args);
      }

      (BuildConsList| BuildAppendList| BuildConsArray| BuildAppendArray)[HeadTerm=HeadTerm,TailTerm=TailTerm] -> {
        this.visitLight(`HeadTerm);
        this.visitLight(`TailTerm);
      }

      XMLAppl[AttrList=AttrList,ChildList=ChildList] -> {
        this.visitLight(`AttrList);
        this.visitLight(`ChildList);
      }
    }

    visit TomList {
      concTomTerm(_*,t,_*) -> {
        this.visitLight(`t);
      }
    }

    visit Expression {
      (GetHead| GetTail| AddOne| GetSize)[Variable=Variable] -> {
        this.visitLight(`Variable);
      }

      GetElement[Variable=Variable,Index=Index] -> {
        this.visitLight(`Variable);
        this.visitLight(`Index);
      }
      GetSliceList[VariableBeginAST=VariableBeginAST,VariableEndAST=VariableEndAST, Tail=Tail] -> {
        this.visitLight(`VariableBeginAST);
        this.visitLight(`VariableEndAST);
        this.visitLight(`Tail);
      }
      GetSliceArray[SubjectListName=SubjectListName,VariableBeginAST=VariableBeginAST,VariableEndAST=VariableEndAST] -> {
        this.visitLight(`VariableBeginAST);
        this.visitLight(`VariableEndAST);
        this.visitLight(`SubjectListName);
      }

    }
  }

  /**
   * Checks if it is a numerical or match constraint using the argument term 
   */
  %strategy FindMatchOrNumericConstraint(term:TomTerm) extends Identity() {
    visit Constraint {
      MatchConstraint[Subject=rhs] -> {
        //`TopDown(HasTerm(term)).visitLight(`rhs);
        `HasTerm(term).visitLight(`rhs);
      }
      NumericConstraint[Pattern=lhs,Subject=rhs] -> {
        /* Try to find the term in both parts for numerical conditions */
        `HasTerm(term).visitLight(`lhs);
        //`TopDown(HasTerm(term)).visitLight(`lhs);
        `HasTerm(term).visitLight(`rhs);
        //`TopDown(HasTerm(term)).visitLight(`rhs);
      }

      (Negate|AntiMatchConstraint)[Constraint=Constraint] -> {
        this.visitLight(`Constraint);
      }

      OrConstraint(_*,c,_*) -> {
        this.visitLight(`c);
      }
      AndConstraint(_*,c,_*) -> {
        this.visitLight(`c);
      }
      OrConstraintDisjunction(_*,c,_*) -> {
        this.visitLight(`c);
      }
      //AntiMatchConstraint(Constraint:Constraint)
    }
  }

  /**
   * Translates constraints into expressions
   */
  private Expression constraintsToExpressions(Constraint constraint) {
    %match(constraint) {
      AndConstraint(m,X*) -> {
        return `And(constraintsToExpressions(m), constraintsToExpressions(X*));
      }
      /**
        SeqConstraint(m,X*) -> {
        return `And(constraintsToExpressions(m), constraintsToExpressions(X*));
        }
       */
      OrConstraint(m,X*) -> {
        return `OrConnector(constraintsToExpressions(m), constraintsToExpressions(X*));
      }
      OrConstraintDisjunction(m,X*) -> {
        return `OrExpressionDisjunction(constraintsToExpressions(m), constraintsToExpressions(X*));
      }
      m@(MatchConstraint|NumericConstraint)[] -> {
        return `ConstraintToExpression(m);
      }
      AntiMatchConstraint(constr) -> {
        return `AntiMatchExpression(constraintsToExpressions(constr));
      }
      Negate(c) -> {
        return `Negation(constraintsToExpressions(c));
      }
      EmptyListConstraint(opName,variable) -> {
        return getConstraintGenerator().genIsEmptyList(`opName,`variable);
      }
      EmptyArrayConstraint(opName,variable,index) -> {
        return `IsEmptyArray(opName,variable,index);
      }
      IsSortConstraint(type,tomTerm) -> {
        return `IsSort(type,tomTerm);
      }
    }
    throw new TomRuntimeException("PreGenerator.constraintsToExpressions - strange constraint:" + constraint);
  }
}
