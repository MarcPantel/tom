/*
 *
 * TOM - To One Matching Compiler
 * 
 * Copyright (c) 2000-2009, INRIA
 * Nancy, France.
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 * 
 * ClÃ¡udia Tavares  e-mail: Claudia.Tavares@loria.fr
 *
 **/


//TODO

package tom.engine.typer;

import java.util.ArrayList;

import tom.engine.adt.tomsignature.*;
import tom.engine.adt.tomsignature.types.*;
import tom.engine.adt.tomconstraint.types.*;
import tom.engine.adt.tomdeclaration.types.*;
import tom.engine.adt.tomexpression.types.*;
import tom.engine.adt.tominstruction.types.*;
import tom.engine.adt.tomname.types.*;
import tom.engine.adt.tomname.types.tomname.*;
import tom.engine.adt.tomoption.types.*;
import tom.engine.adt.tomslot.types.*;
import tom.engine.adt.tomtype.types.*;
import tom.engine.adt.tomtype.types.tomtypelist.concTomType;
import tom.engine.adt.tomterm.types.*;
import tom.engine.adt.tomterm.types.tomlist.concTomTerm;
import tom.engine.adt.code.types.*;

import tom.engine.adt.typeconstraints.*;
import tom.engine.adt.typeconstraints.types.*;

import tom.engine.TomBase;
import tom.engine.TomMessage;
import tom.engine.exception.TomRuntimeException;

import tom.engine.tools.SymbolTable;
import tom.engine.tools.ASTFactory;

import tom.library.sl.*;

public class NewKernelTyper {
  %include { ../../library/mapping/java/sl.tom}
  %include { ../../library/mapping/java/util/types/Collection.tom}
  %include { ../adt/tomsignature/TomSignature.tom }
//  %include { ../../library/mapping/java/util/types/HashMap.tom}

  %typeterm NewKernelTyper {
    implement { NewKernelTyper }
    is_sort(t) { ($t instanceof NewKernelTyper) }
  }

  private TypeConstraintList constraintsToTypeVariable = `concTypeConstraint();
  private SymbolTable symbolTable;
  private int freshTypeVarCounter = 0;

  public NewKernelTyper() {
    super();
  }

  public SymbolTable getSymbolTable() {
    return this.symbolTable;
  }

  public void setSymbolTable(SymbolTable symbolTable) {
    this.symbolTable = symbolTable;
  }

  protected TomSymbol getSymbolFromName(String tomName) {
    return TomBase.getSymbolFromName(tomName, getSymbolTable());
  }

  protected TomSymbol getSymbolFromType(TomType type) {
    %match(type) {
      TypeWithSymbol[TomType=tomType, TlType=tlType] -> {
        return TomBase.getSymbolFromType(`Type(tomType,tlType), getSymbolTable()); 
      }
    }
    return TomBase.getSymbolFromType(type, getSymbolTable()); 
  }

  protected TomType getFreshTypeVar() {
    return `TypeVar(freshTypeVarCounter++);
  }


//=====

  public void initGlobal(ArrayList<TomSymbol> globalVar){
    //for each element of globalVar, find it in the SymbolTable and replace its type by a freshVar
    for(TomSymbol symb:globalVar) {
      symbolTable.putType(symb.getAstName(), getFreshTypeVar());
    }
  }

  public void typeVariableList(TomSymbol symb, TomTypeList domain, TomType te, SlotList slist) {
    if(TomBase.isListOperator(`symb) || TomBase.isArrayOperator(`symb)) {
      %match(slist) {
        //concSlot(fs, s*) -> {//suppr
          //%match(fs) {//suppr
            /*VariableStar(n, t) -> {*/ concSlot(VariableStar(n, t), s*) -> {
              //inferTerm(fs, t);
              addConstraint(`Equation(t,te));
              typeVariableList(symb, domain, te, s*);
              break;
            }
            /*Variable(n, t) -> {*/ concSlot(Variable(n, t), s*) -> {
              TomType tt = getFreshTypeVar();
              //inferTerm(,);
              addConstraint(`Equation(t,tt));
              typeVariableList();
              break;
            }
            /*RecordAppl(_,concTomName(Name(tn),_*),_,_)-> {*/ concSlot(RecordAppl(_,concTomName(Name(tn),_*),_,_), s*) -> {
                fdom = getSimpleDom();
                syme = findSymblo(tn, fdom);
                if(syme!= symb) {
                tt = getFreshTypeVar();
                addConstraint(`Equation(tt, fdom));
                inferTerm(fs, tt);
                } else {
                  inferTerm(fs, te);
                }
                typeVariableList(symb, domain, te, s);
                break;
            }
          //}
        //}
      }
    } else {
      while(!domain.isEmptyconcTomType()) {
        TomType tt = getFreshTypeVar();
        addconstraint(`Equation(tt, domain.getHeadconcTomType())); //Eq(tt, fdom)
        TomTerm farg = slist.getHeadconcSlot().getAppl();
        inferTerm(farg, tt);
        domain = domain.getTailconcTomType();
        slist = slist.getTailconcSlot();
      }
    } 
  }

  public void inferNumMatch(TomTerm e1, TomTerm e2) {
    TomType t1 = getFreshTypeVar();
    TomType t2 = getFreshTypeVar();
    addConstraint(`Equation(t1,t2));
    inferTerm(e1, t1);
    inferTerm(e2, t2);
  }

  public void inferTerm(TomTerm e, TomType te) {
    %match(e) {
      (Variable|VariableStar)(_,type) -> { addConstraint(`Equation(type,te)); }
      RecordAppl(optionList, nameList=NameList(headName,_*), slotList, constraintList) -> {
        String name = null;
        TomType t;
        if(`(headName) instanceof AntiName) {
          name = ((AntiName)`headName).getName().getString();
        } else {
          name = ((TomName)`headName).getString();
        }
        TomSymbol symbol = getSymbolTable().getSymbolFromName(name);
        if(symbol!=null) {
          t = symbol.getTypesToType().getCodomain();
        } else {
          t = `EmptyType();
        }

        addConstraint(`Equation(t,te));

        concTomType tl;
        if(symbol!=null) {
          tl = symbol.getTypesToType().getDomain();
        } else {
          tl = `concTomType();
        }

        typeVariableList(symbol, tl, te, slotList);
      }
    }
  }

  public void inferCond() {}

  public void inferBlock() {
    //initGlobal()
    //collectSubjectVariables()
  }

  public void inferRule(Instruction instr, ArrayList<TomTerm> localContext) {
    //  %match(instr) {
    //   Instruction(cond, action) -> {
    //initLocal()
    //inferCond()
    //propagate()
    // }
    //  }
  }

  public void addConstraint(TypeConstraint constraint) {
    TypeConstraintList auxList = this.constraintsToTypeVariable;
    this.constraintsToTypeVariable = `concTypeConstraint(constraint,auxList*);
  }

  // cf. TomBase.collectVariable ?
  %strategy collectSubjectVariables(nkt:NewKernelTyper) extends Fail() {
    //Match(p,s,t) addConstraint()

  }

  %strategy collectPatternVariables(nkt:NewKernelTyper) extends Fail() {
    //Match(p,s,t) addConstraint()
  }

  %strategy propagate(nkt:NewKernelTyper) extends Fail() {
  }

} // NewKernelTyper
