%include { sl.tom }
%include { util/types/Map.tom }
%include { adt/bytecode/Bytecode.tom }

/**
 * This strategy fills in the `Map' m with the position 
 * corresponding to each `Anchor'.
 * Thus, we can retrieve the position from a `Label'.
 * @param m the map to be filled.
 */

%strategy BuildLabelMap(m:Map) extends Identity() {
  visit TInstructionList {
    ConsInstructionList(Anchor(l), _) -> {
      m.put(`l, getEnvironment().getPosition());
    }
  }
}


/**
 * `AllCfg' stands for AllControlFlowGraph.
 * This works as the classical `All' strategy but is
 * adapted for a ControlFlowGraph run.
 * (i.e. a `Goto' instruction has one child : the one to jump to;
 * a `IfXX' instruction has two children : the one which
 * satisfies the expression, and the other...)
 * @param s the strategy to be applied on each child.
 * @param m the label map (see the BuildLabelMap strategy).
 */

%strategy AllCfg(s:Strategy, m:Map) extends Identity() {
  visit TInstructionList {
    ConsInstructionList(ins, t) -> {
      TInstruction ins = `ins;
      %match(TInstruction ins) {
        Goto(l) -> {
          tom.library.sl.Position p = (tom.library.sl.Position) (m.get(`l));
          tom.library.sl.Position current = getEnvironment().getPosition();
          getEnvironment().followPath(p.sub(current));
          execute(s);
          getEnvironment().followPath(current.sub(p));
          //do not visit to the next instruction
          return (TInstructionList) getEnvironment().getSubject();
        }

        (Ifeq|Ifne|Iflt|Ifge|Ifgt|Ifle|
         If_icmpeq|If_icmpne|If_icmplt|If_icmpge|If_icmpgt|If_icmple|
         If_acmpeq|If_acmpne|Jsr|Ifnull|Ifnonnull)(l) -> {
          tom.library.sl.Position p = (tom.library.sl.Position) (m.get(`l));
          tom.library.sl.Position current = getEnvironment().getPosition();
          getEnvironment().followPath(current.sub(p));
          execute(s);
          getEnvironment().followPath(p.sub(current));
        }

        (Tableswitch|Lookupswitch)[dflt=dflt, labels=labels] -> {
          TLabelList labelList = `labels;
          %match(TLabelList labelList) {
            LabelList(_*, x, _*) -> {
              tom.library.sl.Position p = (tom.library.sl.Position) (m.get(`x));
              tom.library.sl.Position current = getEnvironment().getPosition();
              getEnvironment().followPath(current.sub(p));
              execute(s);
              getEnvironment().followPath(p.sub(current));
            }
          }
          tom.library.sl.Position p = (tom.library.sl.Position) (m.get(`dflt));
          tom.library.sl.Position current = getEnvironment().getPosition();
          getEnvironment().followPath(current.sub(p));
          execute(s);
          getEnvironment().followPath(p.sub(current));
        }

        // Visit the next instruction.
        _ -> {
          getEnvironment().down(2);
          execute(s);
          getEnvironment().up();
        }
      }
    }
  }

}

/**
 * Adds one to the current node mark.
 * @param map the map containing all instructions marks.
 */
%strategy Mark(map:Map) extends Identity() {
  visit TInstructionList {
    c@_ -> {
      Object o = map.get(`c);
      int value = 1;
      if(o != null)
        value = ((Integer)o).intValue() + 1;
      map.put(`c, new Integer(value));
    }
  }
}

/**
 * Substract one to the current node mark.
 * @param map the map containing all instructions marks.
 */
%strategy UnMark(map:Map) extends Identity() {
  visit TInstructionList {
    c@_ -> {
      Object o = map.get(`c);
      if (o == null) {
        getEnvironment().setStatus(tom.library.sl.Environment.FAILURE);
      }
      int value = ((Integer)o).intValue() - 1;
      map.put(`c, new Integer(value));
    }
  }
}

/**
 * Indicates if the current node is marked (>0) or not.
 * @param map the map containing all instructions marks.
 */
%strategy IsMarked(map:Map) extends Identity() {
  visit TInstructionList {
    c@_ -> {
      Object o = map.get(`c);
      if(o == null || ((Integer)o).intValue() <= 0)
        throw new jjtraveler.VisitFailure();
    }
  }
}

/**
 * This strategy opertor corresponds to temporal operator AU in CTL.
 * Identity() can be interpreted as True and Failure as False
 * It succeeds if s1 is "True" until s2 is "True".
 * @param s1 the first strategy.
 * @param s2 the second strategy.
 * @param m the label map (see the BuildLabelMap strategy).
 * @param t the complete list of instructions
 */
%op Strategy AUMap(s1:Strategy, s2:Strategy, m:Map) {
  make(s1,s2,m) { `mu(MuVar("x"),Choice(s2,Sequence(s1,AllCfg(MuVar("x"),m)))) }
}

%op Strategy AGMap(s:Strategy, m:Map) {
  make(s,m) { `mu(MuVar("x"),Sequence(s,AllCfg(MuVar("x"),m))) }
}

