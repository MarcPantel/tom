%include { mustrategy.tom }
%include { util/types/Map.tom }
%include { adt/bytecode/Bytecode.tom }

/**
 * This strategy fills in the `Map' m with the `ConsInstructionList'
 * corresponding to each `Anchor'.
 * Thus, we can retrieve the `ConsInstructionList' from a `Label'.
 * @param m the map to be filled.
 */

%strategy BuildLabelMap(m:Map) extends Identity() {
  visit TInstructionList {
    c@ConsInstructionList(Anchor(l), _) -> {
      m.put(`l, getPosition());
    }
  }
}


/**
 * `AllCfg' stands for AllControlFlowGraph.
 * This works as the classical `All' strategy but is
 * adapted for a ControlFlowGraph run.
 * (i.e. a `Goto' instruction has one child : the one to jump to;
 * a `IfXX' instruction has two children : the one which
 * satisfies the expression, and the other...)
 * @param s the strategy to be applied on each child.
 * @param m the label map (see the BuildLabelMap strategy).
 */

%strategy AllCfg(s:Strategy, m:Map, root:TInstructionList) extends Identity() {
  visit TInstructionList {

    c@ConsInstructionList(ins, t) -> {
      TInstruction ins = `ins;
      %match(TInstruction ins) {
        Goto(l) -> {
          tom.library.strategy.mutraveler.Position p = (tom.library.strategy.mutraveler.Position) (m.get(`l));
          final TInstructionList t = (TInstructionList) s.visit(p.getSubterm().visit(root));
          root = (TInstructionList) p.getReplace(t).visit(root);
          return  (TInstructionList) s.visit(getPosition().getSubterm().visit(root));
        }

        (Ifeq|Ifne|Iflt|Ifge|Ifgt|Ifle|
         If_icmpeq|If_icmpne|If_icmplt|If_icmpge|If_icmpgt|If_icmple|
         If_acmpeq|If_acmpne|Jsr|Ifnull|Ifnonnull)(l) -> {
           tom.library.strategy.mutraveler.Position p = (tom.library.strategy.mutraveler.Position) (m.get(`l));
           final TInstructionList t = (TInstructionList) s.visit(p.getSubterm().visit(root));
           root = (TInstructionList) p.getReplace(t).visit(root);
         }

        (Tableswitch|Lookupswitch)[dflt=dflt, labels=labels] -> {
          TLabelList labelList = `labels;
          %match(TLabelList labelList) {
            LabelList(_*, x, _*) -> {
              tom.library.strategy.mutraveler.Position p = (tom.library.strategy.mutraveler.Position) (m.get(`x));
              final TInstructionList t = (TInstructionList) s.visit(p.getSubterm().visit(root));
              root = (TInstructionList) p.getReplace(t).visit(root);
            }
          }
          tom.library.strategy.mutraveler.Position p = (tom.library.strategy.mutraveler.Position) (m.get(`dflt));
          final TInstructionList t = (TInstructionList) s.visit(p.getSubterm().visit(root));
          root = (TInstructionList) p.getReplace(t).visit(root);
          return  (TInstructionList) s.visit(getPosition().getSubterm().visit(root));
        }

        // Visit the next instruction.
        _ -> {
          tom.library.strategy.mutraveler.Position p = getPosition();
          p.down(2);
          root = (TInstructionList) p.getReplace(s.visit(`t)).visit(root); 
          p.up();
          return  (TInstructionList) p.getSubterm().visit(root);
        }
      }
    }
  }

}

/**
 * Adds one to the current node mark.
 * @param map the map containing all instructions marks.
 */
%strategy Mark(map:Map) extends Identity() {
  visit TInstructionList {
    c@_ -> {
      Object o = map.get(`c);
      int value = 1;
      if(o != null)
        value = ((Integer)o).intValue() + 1;
      map.put(`c, new Integer(value));
    }
  }
}

/**
 * Substract one to the current node mark.
 * @param map the map containing all instructions marks.
 */
%strategy UnMark(map:Map) extends Identity() {
  visit TInstructionList {
    c@_ -> {
      Object o = map.get(`c);
      if(o == null)
        throw new jjtraveler.VisitFailure();
      int value = ((Integer)o).intValue() - 1;
      map.put(`c, new Integer(value));
    }
  }
}

/**
 * Indicates if the current node is marked (>0) or not.
 * @param map the map containing all instructions marks.
 */
%strategy IsMarked(map:Map) extends Identity() {
  visit TInstructionList {
    c@_ -> {
      Object o = map.get(`c);
      if(o == null || ((Integer)o).intValue() <= 0)
        throw new jjtraveler.VisitFailure();
    }
  }
}

/**
 * This strategy opertor corresponds to temporal operator AU in CTL.
 * Identity() can be interpreted as True and Failure as False
 * It succeeds if s1 is "True" until s2 is "True".
 * @param s1 the first strategy.
 * @param s2 the second strategy.
 * @param m the label map (see the BuildLabelMap strategy).
 * @param t the complete list of instructions
 */
%op Strategy AUMap(s1:Strategy, s2:Strategy, m:Map, t:TInstructionList) {
  make(s1,s2,m,t) { `mu(MuVar("x"),Choice(s2,Sequence(s1,AllCfg(MuVar("x"),m,t)))) }
}

