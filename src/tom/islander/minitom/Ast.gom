module minitom.Ast

imports int String

abstract syntax

// Temporary starting point
CompilationUnit = CompilationUnit(BlockList:BlockList)

TomType = Type(TomType:String)
        | EmptyType()

//TomTypeList = TomTypeList(TomType*)

TomTerm = Variable(Name:TomName,Type:TomType)
        | VariableStar(Name:TomName,Type:TomType)
        | AntiVariable(Name:TomName,Type:TomType)
        | AntiVariableStar(Name:TomName,Type:TomType)
        | UnamedVariable() // Underscore()
        | UnamedVariableStar() // UnderscoreStar()
        | NamedTermList(Name:TomName,TomTermList:TomTermList)
        | XMLAttr(Name:TomName,Value:String,Annotation:Annotation)
        | UnamedXMLAttr(Value:String,Annotation1:Annotation, Annotation2:Annotation)
//        | AnnotedXMLAttr(Name:TomName,Value:String,Annotation1:String)

TomTermList = TomTermList(TomTerm*)
            | EmptyList() // should not exist : workarround that we should get rid of

Annotation = Annotation(Annotation:String)
           | EmptyAnnotation()

TomName = Name(String:String)
        | EmptyName()

TomNameList = TomNameList(TomName*)

/*
Option = 

OptionList = OptionList(Option*)
*/

Pattern = Pattern(Pattern:PlainPattern)
        | AnnotedPattern(Pattern:PlainPattern,Annotation:String)

PlainPattern = PlainPattern(Term:TomTerm)
             | XMLTerm(NameList:TomNameList,Attrs:TomTermList,ChildList:TomTermList) // ?
             | PPExplicitTermList(PatternList:PatternList)
             | SymbolList(Head:HeadSymbolList,Tail:TailList)
             | AntiSymbolList(Head:HeadSymbolList,Tail:TailList)

TailList = ImplicitPairList(PairPatternList:PairPatternList)
         | ExplicitTermList(PatternList:PatternList)

PairPattern = PairPattern(SlotName:String,Pattern:Pattern)

PairPatternList = PairPatternList( PairPattern* )

HeadSymbolList = HeadSymbolList(HeadSymbol*)

HeadSymbol = HeadSymbol(Name:String)
           | HeadSymbolQMark(Name:String)

PatternList = PatternList( Pattern* )

PatternAction = PatternAction(Patterns:PatternList,BlockList:BlockList)
              | LabelledPatternAction(Patterns:PatternList,BlockList:BlockList,LabelName:String)
              | EmptyPatternAction()

PatternActionList = PatternActionList(PatternAction*)

ConstraintActionList = ConstraintActionList(ConstraintAction*)

ConstraintAction = ConstraintAction(Constraint:Constraint,Blocklist:BlockList)

Constraint = AndConstraint(Left:Constraint,Right:Constraint)
           | OrConstraint(Left:Constraint,Right:Constraint)
           | MatchConstraint(p:Pattern,Subject:TomTerm)
           | OpConstraint(Pattern:TomTerm,Subject:TomTerm,Op:NumOperator)
           | ConstraintList(Constraint*)

NumOperator = NumLessOrEqualThan()
         | NumGreaterOrEqualThan()
         | NumEqual()
         | NumDifferent()
         | NumLessThan()
         | NumGreaterThan()

Operator = IsFsym(Name:TomName,Block:BlockList)
	 | GetSlot(Name1:TomName,Name2:TomName,Block:BlockList)
	 | Make(NameList:TomNameList,Block:BlockList)
	 | GetHead(Name:TomName,Block:BlockList)
	 | GetTail(Name:TomName,Block:BlockList)
	 | IsEmpty(Name:TomName,Block:BlockList)
	 | MakeEmpty(Name:TomName,Block:BlockList)
	 | MakeEmptyList(Block:BlockList)
	 | MakeInsert(Name1:TomName,Name2:TomName,Block:BlockList)
	 | GetElement(Name1:TomName,Name2:TomName,Block:BlockList)
	 | GetSize(Name:TomName,Block:BlockList)
	 | MakeEmptyArray(Name:TomName,Block:BlockList)
	 | MakeAppend(Name1:TomName,Name2:TomName,Block:BlockList)
         | Implement(Block:BlockList)
         | IsSort(Name:TomName,Block:BlockList) //temp - not a goalLanguageBlockList but a goalLanguageSortCheck, maybe different
         | Equals(Name1:TomName,Name2:TomName,Block:BlockList)

OperatorList = OperatorList(Operator*)

BlockList = MatchConstruct(MatchArguments:TomTermList,PatternActions:PatternActionList )
      	  | MatchConstructWithoutArgs(ConstraintActions:ConstraintActionList )
          | CompositeTerm(CompositeTerm:String)
          | Operator(Name:TomName,Type:TomType,Args:SlotList,Op:Operator,OperatorList:OperatorList) // Name - Type -Args - isfsym - OperatorList
          | OpList(Name:TomName,Type:TomType,Arg:TomType,Op:Operator,OperatorList:OperatorList)
          | OpArray(Name:TomName,Type:TomType,Arg:TomType,Op:Operator,OperatorList:OperatorList)
          | Strategy(Name:TomName,Extends:TomTerm,VisitList:StrategyVisitList,Arguments:TomTermList) //?
          | TypeTerm(Type:TomType,Op1:Operator,Op2:Operator,Op3:Operator)
          | Include(FileName:String)
          | BlockList( BlockList* )

SlotList = SlotList(Slot*)

Slot = Slot(SlotName:TomName,Type:TomType)

StrategyVisitList = StrategyVisitList(StrategyVisit*)

StrategyVisit = StrategyVisit(Type:TomType,ActionList:VisitActionList)

VisitAction = VisitActionBL(Patterns:PatternList,BlockList:BlockList)
            | VisitActionT(Patterns:PatternList,Term:TomTerm)
            | LabelledVisitActionBL(Patterns:PatternList,BlockList:BlockList,LabelName:String)
            | LabelledVisitActionT(Patterns:PatternList,Term:TomTerm,LabelName:String)
            | EmptyVisitAction()

VisitActionList = VisitActionList(VisitAction*)


// temporary constructors, for test purpose
/*Arg = Arg(Name:String)
ArgList = concArg(Arg*)*/

//=========================================

// grammaire matchconstruct du wiki : 
/*

MatchConstruct 	 ::= 	 '%match' '(' MatchArguments ')' '{' ( PatternAction )* '}'
	∣ 	'%match' '{' ( ConstraintAction )* '}'
MatchArguments 	::= 	[Type] Term ( ',' [Type] Term )*
PatternAction 	::= 	[LabelName':'] PatternList '->' '{' BlockList '}'
PatternList 	::= 	Pattern( ',' Pattern )* [ ('&&' ∣'||') Constraint ]
ConstraintAction 	::= 	Constraint '->' '{' BlockList '}'
Constraint 	::= 	Pattern '<<' [Type] Term
	∣ 	Constraint '&&' Constraint
	∣ 	Constraint '||' Constraint
	∣ 	'(' Constraint ')'
	∣ 	Term Operator Term
Operator 	::= 	'>' ∣'>=' ∣'<' ∣'<=' ∣'==' ∣'!='
*/

//  grammaire pattern du wiki
/*

Term 	 ::= 	 VariableName['*']
	∣ 	Name '('[Term ( ',' Term )*]')'
Pattern 	::= 	[ AnnotedName '@' ] PlainPattern
PlainPattern 	::= 	['!']VariableName [ '*' ]
	∣ 	['!'] HeadSymbolList (ExplicitTermList ∣ ImplicitPairList)
	∣ 	ExplicitTermList
	∣ 	'_'
	∣ 	'_*'
	∣ 	XMLTerm
HeadSymbolList 	::= 	HeadSymbol [ '?' ]
	∣ 	'(' HeadSymbol ( '∣' HeadSymbol )+ ')'
ExplicitTermList 	::= 	'(' [ Pattern ( ',' Pattern )*] ')'
ImplicitPairList 	::= 	'[' [ PairPattern ( ',' PairPattern )*] ']'
PairPattern 	::= 	SlotName '=' Pattern
*/

// convention lexicales du wiki -> cf lexer
/*
Identifier 	 ::= 	 Letter ( Letter ∣ Digit ∣ '_' ∣ '-' )*
Integer 	::= 	(Digit )+
Double 	::= 	(Digit)+ ['.'] (Digit)* ∣ '.' (Digit)+
String 	::= 	'"' (Letter ∣ ('\' ('n' ∣ 't' ∣ 'b' ∣ 'r' ∣ 'f' ∣ '\' ∣ '’' ∣ '"') ) )* '"'
Letter 	::= 	'A' ... 'Z' ∣ 'a' ... 'z'
Digit 	::= 	'0' ... '9'
Char 	::= 	'’' (Letter ∣Digit) '’'
*/

// convention names  du wiki -> lexer
/*
SubjectName 	 ::= 	 Identifier
Type 	::= 	Identifier
SlotName 	::= 	Identifier
HeadSymbol 	::= 	Identifier
  ∣ 	Integer
	∣ 	Double
	∣ 	String
	∣ 	Char
VariableName 	::= 	Identifier
AnnotedName 	::= 	Identifier
LabelName 	::= 	Identifier
FileName 	::= 	Identifier
AttributeName 	::= 	Identifier
XMLName 	::= 	Identifier
Name 	::= 	Identifier
*/

// grammaire tom program  du wiki
/*
Tom 	 ::= 	 BlockList
BlockList 	::=
	( 	MatchConstruct
	∣ 	StrategyConstruct
	∣ 	BackQuoteTerm
	∣ 	IncludeConstruct
	∣ 	GomConstruct
	∣ 	TypeTerm
	∣ 	Operator
	∣ 	OperatorList
	∣ 	OperatorArray
	∣ 	'{' BlockList '}'
	)* 
*/


// grammaire anti pattern du wiki
/*
PlainPattern 	 ::= 	 ['!'] VariableName
	∣ 	['!'] HeadSymbolList ( ExplicitTermList ∣ ImplicitPairList )
	∣ 	... 
*/


// grammaire XML Term du wiki
/*
XMLTerm 	 ::= 	 '<' XMLNameList XMLAttrList '/>'
	∣ 	'<' XMLNameList XMLAttrList '>' XMLChilds '</' XMLNameList '>'
	∣ 	'#TEXT' '(' Identifier ∣ String ')'
	∣ 	'#COMMENT' '(' Identifier ∣ String ')'
	∣ 	'#PROCESSING-INSTRUCTION'
		'(' (Identifier ∣ String) ',' (Identifier ∣ String) ')'
XMLNameList 	::= 	XMLName
	∣ 	'(' XMLName ( '∣' XMLName )* ')'
XMLAttrList 	::= 	'[' [ XMLAttribute (',' XMLAttribute)* ] ']'
	∣ 	'(' [ XMLAttribute (',' XMLAttribute)* ] ')'
	∣ 	( XMLAttribute )*
XMLAttribute 	::= 	'_*'
	∣ 	VariableName '*'
	∣ 	AttributeName '=' [AnnotedName '@'] ( Identifier ∣ String )
	∣ 	[AnnotedName '@'] '_' '=' [AnnotedName '@'] ( Identifier ∣ String )
XMLChilds 	::= 	( Term )*
	∣ 	'[' Term ( ',' Term )* ']'
*/


/*
 *
 * */
