/* test ML_COMMENT */
//test SL_COMMENT
//backquote
//`(f(a,b))
//`(x.get(calc(3)))
//`(x())

//Tom

%include { mon/mapping.tom }

`(x*)
//`(f(new Foo(g(x*))))

%match (MyType subject, MySecondType s2) {
  pattern1 -> { something1 }
  pattern2 -> { `(somethingElse) }
}

%op TomPerson2 person2(name2:String,age2:int) {
  is_fsym(t) { `(aaa) }
}

%match (MyType subject, MySecondType s2) { 
  pattern -> {
    %match (A a1) { 
     pe1 -> {            
       %match (A a2) { 
         pe2 -> { `(b1) }
       }
     }
   }
  }
}

%op TomPerson2 person2(name2:String,age2:int) {
  is_fsym(t) { `(aaa) }
}

//ici on trouve un bloc de code
//@Annotation
//public String fonction(int value) {
//  return value.toString() //"var("+value+")";
//}

%typeterm TomPerson {
  implement { someCompositeTerm01 }
  is_sort(t) { someCompositeTerm02 }
  equals(t1,t2) { someCompositeTerm03 }
}

%op TomPerson person() { //name:String,age:int) {
  is_fsym(t) { s }
  make(t1,t2) { someCompositeTerm04 }
  get_slot(name,t) { someCompositeTerm05 }
  get_slot(age,t) { someCompositeTerm06 }
}

/*$s @Test get*/ 

%oparray TomList conc(Object*){
  is_fsym(t) { someCompositeTerm07 }
  make_empty(n) { someCompositeTerm08 }
  make_append(e,l) { someCompositeTerm09 }
  get_element(l,n) { someCompositeTerm10 }
  get_size(l) { someCompositeTerm11 }
}

%oplist TomList concT(T*){
  is_fsym(t) { someCompositeTerm12 }
  make_empty() { someCompositeTerm13 }
  make_insert(t1,t2) { someCompositeTerm14 }
  get_head(t) { someCompositeTerm15 }
  get_tail(t) { someCompositeTerm16 }
  is_empty(t) { someCompositeTerm17 }
}

