module minijava.MinijavaAst

imports int String

abstract syntax

/* 
 * Names in conflict with keywords used followed by a '_':
 *
 * Sorts names:
 *  - Boolean
 *  - Super
 *
 * Operator names:
 * - Try
 *
 * Slots names:
 * - class
 * - else
 * - extends
 * - finally
 * - if
 * - implements
 * - import
 * - package
 * - super
 *
 */

JavaCompilationUnit = JavaCompilationUnit( expression:Expression )

Type =
 | ArrayType( type:Type, dimensions:int )
 | ClassOrInterfaceType( classorinterfacetype:ClassOrInterfaceType )
 | Boolean()
 | Char()
 | Byte()
 | Short()
 | Int()
 | Long()
 | Float()
 | Double()
 | Void()

TypeList = TypeList( Type* )

QualifiedName =
 | QualifiedName( String* )

QualifiedNameList = QualifiedNameList( QualifiedName* )

Boolean_ =
 | True()
 | False()

ClassOrInterfaceType =
 | IndependentType( name:String, arguments:TypeArgumentList )
 | NestedType( outername:String, outerarguments:TypeArgumentList, innertype:ClassOrInterfaceType )

TypeArgumentList = TypeArgumentList( TypeArgument* )

TypeArgument =
 | ExplicitTypeArgument( type:Type )
 | ExtendTypeArgument( type:Type )
 | SuperTypeArgument( type:Type )
 | WildCardTypeArgument()

VariableInitializer =
 | ArrayInitializer( VariableInitializer* )
 | ExpressionToVariableInitializer( value:Expression )
 | EmptyVariableInitializer()

// EXPRESSIONS

ExpressionList = ExpressionList( Expression* )

ExpressionList:make_insert(h, t) {
  %match (h) {
    EmptyExpression() -> { return t; }
  }
}

Expression =
 | Assignment( bop:AssignmentOperator, lhs:Expression, rhs:Expression )
 | ConditionalExpression( if_:Expression, then:Expression, else_:Expression )
 | AssociativeOperation( nop:AssociativeOperator, operands:ExpressionList )
 | InstanceOf( expression:Expression, type:Type )
 | UnaryOperation( uop:UnaryOperator, operand:Expression )
 | TypeCast( casttype:Type, expression:Expression )
 | ExpressionCast( castexpression:Expression, expression:Expression ) // semantics ?
 | Primary( primary:Primary, selectors:SuffixList )
 | EmptyExpression()
 | Cons( nop:AssociativeOperator, lhs:Expression, rhs:Expression )
 | BinaryAnd( lhs:Expression, rhs:Expression )
 | BinaryEqual( lhs:Expression, rhs:Expression )
 | BinaryNotEqual( lhs:Expression, rhs:Expression )
 | BinaryPlus( lhs:Expression, rhs:Expression )
 | BinaryMinus( lhs:Expression, rhs:Expression )
 | BinaryMult( lhs:Expression, rhs:Expression )
 | BinaryDiv( lhs:Expression, rhs:Expression )
 | BinaryModulo( lhs:Expression, rhs:Expression )

AssociativeOperation:make(op, ops) {
  %match(ExpressionList ops) {
    ExpressionList(e) -> { return `e; }
  }
  realMake(op, ops);
}

AssignmentOperator =
 | Assign()
 | PlusAssign ()
 | MinusAssign()
 | TimesAssign()
 | DivAssign  ()
 | AndAssign  ()
 | OrAssign   ()
 | XOrAssign  ()
 | ModAssign  ()
 | LeftShiftAssign         ()
 | UnsignedRightShiftAssign()
 | SignedRightShiftAssign  ()

AssociativeOperator =
 | ConditionalOr ()
 | ConditionalAnd()
 | InclusiveOr   ()
 | ExclusiveOr   ()
 | And           ()
 | Equal   ()
 | NotEqual()
 | LowerOrEqual  ()
 | GreaterOrEqual()
 | Lower         ()
 | Greater       ()
 | LeftShift         ()
 | UnsignedRightShift()
 | SignedRightShift  ()
 | Plus ()
 | Minus()
 | Times()
 | Div  ()
 | Mod  ()

UnaryOperator =
 | UPlus ()
 | UMinus()
 | PreInc ()
 | PreDec ()
 | PostInc()
 | PostDec()
 | BitwiseNot()
 | LogicalNot()

Primary =
 | ExpressionToPrimary( expression:Expression )
 | This( nested:QualifiedName, suffix:Suffix )
 | Super( super_:Super_ )
 | HexLiteral          ( stringvalue:String )
 | OctalLiteral        ( stringvalue:String )
 | DecimalLiteral      ( stringvalue:String )
 | FloatingPointLiteral( stringvalue:String )
 | CharacterLiteral    ( stringvalue:String )
 | StringLiteral       ( stringvalue:String )
 | BooleanLiteral      ( booleanvalue:Boolean_ )
 | Null                ()
 | ClassCreator        ( typearguments:TypeList, class_:Type, arguments:ExpressionList )
 | InitializedArrayCreator   ( type:Type, initializer:VariableInitializer )
 | NonInitializedArrayCreator( fixedlengths:ExpressionList, nonfixeddimensions:int )
 | QualifiedNameToPrimary( name:QualifiedName, suffix:Suffix )
 | Class( type:Type )

SuffixList = SuffixList( Suffix* )

SuffixList:make_insert(h, t) {
  %match (h) {
    EmptySuffix() -> { return t; }
  }
}

// "identifierSuffix" and "selector" included

Suffix =
 | ArrayClassSuffix( dimension:int )
 | ArgumentsSuffix( arguments:ExpressionList )
 | VariableAccessSuffix( name:String )
 | CallSuffix( method:String, arguments:ExpressionList )
 | ExplicitGenericInvocation( typearguments:TypeList, name:String, arguments:ExpressionList )
 | ThisSuffix()
 | SuperSuffix( super_:Super_ )
/* | InnerCreator( typearguments:TypeList, class_:Type, arguments:ExpressionList, body:Body )*/
 | ArrayIndexSuffix( position:ExpressionList )
 | EmptySuffix()

Super_ =
 | SuperConstruction( arguments:ExpressionList )
 | SuperVariableAccess( name:String )
 | SuperCall( name:String, arguments:ExpressionList )
