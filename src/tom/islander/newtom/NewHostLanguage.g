/*
 * TOM - To One Matching Compiler
 *
 * Copyright (c) 2000-2010, INPL, INRIA
 * Nancy, France.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 *
 */

grammar NewHostLanguage;

options {
  backtrack=true;
  memoize=true;
  output=AST;
  ASTLabelType=Tree;
  //tokenVocab=HostTokens;
  tokenVocab=TomTokens;

//  k=6; // the default lookahead
  // a filter for the target language
  // permit to read every characters without defining them
//?  filter=TARGET;
  // fix the vocabulary to all characters
//?  charVocabulary='\u0000'..'\uffff';
}

@header{
  package newtom;
  //package tom.engine.parser;
  import org.antlr.runtime.tree.Tree;
//  import org.antlr.runtime.tree.*;
//  import org.antlr.runtime.*;
}

//@rulecatch { }
// equivalent to
/*options{
  // antlr does not catch exceptions automaticaly
  defaultErrorHandler = false;
}*/

@lexer::header{
  package newtom;
  //package tom.engine.parser;
  import org.antlr.runtime.tree.Tree;
  import org.antlr.runtime.Token;
  import org.antlr.runtime.CommonTokenStream;
  import org.antlr.runtime.ANTLRInputStream;
}

@lexer::members{
  public static int nesting = 0;
  public Tree result;

  // override standard token emission
  public Token emit() {
    TomToken t = new TomToken(input, state.type, state.channel,
        state.tokenStartCharIndex, getCharIndex()-1,result);
    t.setLine(state.tokenStartLine);
    t.setText(state.text);
    t.setCharPositionInLine(state.tokenStartCharPositionInLine);
    t.setTree(result);
    emit(t);
//    System.out.println("Host, emit(), t == " + t);
//    System.out.println("Host, emit(), t.result == " + t.getTree());
    result = null;
    return t;
  }

/*
  public NewTomLanguageParser parser(ANTLRInputStream input) {
    NewTomLanguageLexer lexer = new NewTomLanguageLexer(input);
    CommonTokenStream tokens = new CommonTokenStream(lexer);
    NewTomLanguageParser parser = new NewTomLanguageParser(tokens);
    return parser;
  }
*/
  public static final int TVALUE_MATCH         = 1;
  public static final int TVALUE_STRATEGY      = 2;
  public static final int TVALUE_OPERATOR      = 3;
  public static final int TVALUE_TYPETERM      = 4;
  public static final int TVALUE_OPERATORLIST  = 5;
  public static final int TVALUE_OPERATORARRAY = 6;
 
  /*
  public ParserRuleReturnScope parser(ANTLRInputStream input, int tvalue) {
    NewTomLanguageLexer lexer = new NewTomLanguageLexer(input);
    CommonTokenStream tokens = new CommonTokenStream(lexer);
    NewTomLanguageParser parser = new NewTomLanguageParser(tokens);
    ParserRuleReturnScope res;
    switch(tvalue) {
      case TVALUE_MATCH:
        res = (NewTomLanguageParser.matchConstruct_return)parser.matchConstruct();
        break;*/
/*
      case TVALUE_STRATEGY:
        res = parser.strategyConstruct();
        break;
      case TVALUE_OPERATOR:
        res = parser.operator();
        break;
      case TVALUE_TYPETERM:
        res = parser.typeTerm();
        break;
      case TVALUE_OPERATORLIST:
        res = parser.operatorList();
        break;
      case TVALUE_OPERATORARRAY:
        res = parser.operatorArray();
        break;
*//*
      default: System.out.println("Problem");break;
    }
    return res;
  }
  */

}

// The grammar starts here
program : blockList { System.out.println("DEBUG 4 ***");} -> ^(Program blockList);

/*input returns [Code result] throws TomException
@init{
    result = null;
    List<Code> list = new LinkedList<Code>();
}
  :
  blockList[list] t:EOF
        {
          // This TL is last block: do no need to specify line and column
          list.add(`TargetLanguageToCode(TL(getCode(),
                                            TextPosition(currentLine(),currentColumn()),
                                            TextPosition(t.getLine(), t.getColumn()))));
            //String comment = "Generated by TOM (version " + Tom.VERSION + "): Do not edit this file";
            //list.add(0,`TargetLanguageToCode(Comment(comment)));
            result = `Tom(ASTFactory.makeCodeList(list));
        }
    ;
*/

blockList : (block)* { System.out.println("DEBUG 3 ***");} -> ^(BlockList (block)* ) ;

block :
    // either a tom construct or everything else
//    matchConstruct
//  | strategyConstruct
//  | gomsignature
  | backquoteConstruct { System.out.println("DEBUG 2 ***");} -> ^(BackQuoteConstruct backquoteConstruct)
//  | operator
//  | operatorList
//  | operatorArray
//  | includeConstruct
//  | typeTerm
//  | code
//  | STRING
  | LBRACE blockList RBRACE -> blockList
  ;

/*goalLanguageBlock :
  LBRACE blockList RBRACE -> blockList  //^(BlockList blockList)
  ;*/

// the %strategy construct
//strategyConstruct [List<Code> list] throws TomException
/*strategyConstruct :
  t=STRATEGY -> ^({((TomToken)$t).getTree()})
  ;*/

//%match
//matchConstruct [List<Code> list] throws TomException
/*matchConstruct :
  t=MATCH -> ^({((TomToken)$t).getTree()})
  ;*/

//%gom
/*gomsignature [List<Code> list] throws TomException
gomsignature :
  t=GOM -> ^({((TomToken)$t).getTree()})
  ;*/

// `()
//backquoteTerm [List<Code> list]
backquoteConstruct :
  t=BACKQUOTE {System.out.println("in backquoteTerm, t = " + $t);} -> ^({((TomToken)$t).getTree()})
  ;

//%op
//operator [List<Code> list] throws TomException
/*operator :
  t=OPERATOR -> ^({((TomToken)$t).getTree()})
  ;*/

//%oplist
//operatorList [List list] throws TomException
/*operatorList :
  t=OPERATORLIST -> ^({((TomToken)$t).getTree()})
  ;*/

//%oparray
//operatorArray [List<Code> list] throws TomException
/*operatorArray :
  t=OPERATORARRAY -> ^({((TomToken)$t).getTree()})
  ;*/

//%include
//includeConstruct [List<Code> list] throws TomException
/*includeConstruct :
  t=INCLUDE -> ^({((TomToken)$t).getTree()})
  ;*/

//code [List<Code> list] throws TomException
//code :
//  t=CODE -> ^({((TomToken)$t).getTree()})
//  ;

//%typeterm
//typeTerm [List<Code> list] throws TomException
/*typeTerm :
  t=TYPETERM -> ^({((TomToken)$t).getTree()})
  ;*/

/*
  goalLanguage [List<Code> list] returns [TargetLanguage result] throws TomException
  goalLanguage :
  LBRACE RBRACE
  ;*/

/*
  targetLanguage [List<Code> list] returns [TargetLanguage result] throws TomException
  targetLanguage  :
  blockList
  ;*/

// here begins the lexer

// here begins tokens definition
// the following tokens are keywords for tom constructs
// when read, we switch lexers to tom

BACKQUOTE : '`('
  {
    System.out.println("\nbefore new BackQuote*");
    NewBackQuoteLanguageLexer lexer = new NewBackQuoteLanguageLexer(input);
    CommonTokenStream tokens = new CommonTokenStream(lexer);
    System.out.println("host, tokens = " + tokens.toString() + " /fin");
    System.out.println("host, tokens list = " + tokens.getTokens().toString());
    NewBackQuoteLanguageParser parser = new NewBackQuoteLanguageParser(tokens);
    System.out.println("before parser.backQuoteConstruct()");
    NewBackQuoteLanguageParser.backQuoteTerm_return res = parser.backQuoteTerm();
//    System.out.println("(host - bq) res.getTree() =\n" + ((Tree)res.getTree()).toStringTree());
//    System.out.println("(host - bq) res.getTree() =\n" + HostLanguageParser.intermediateBQResult.toStringTree());
    result = (Tree)res.getTree();
    System.out.println("(host - bq) end, result =\n" + result.toStringTree());
  }
  { System.out.println("DEBUG 1 ***");}
  ;

/*
MATCH : '%match'
  {
    //NewTomLanguageParser.matchConstruct_return res = parser(input).matchConstruct();
    result = (Tree)parser(input, TVALUE_MATCH).getTree();
  }
  ;

STRATEGY : '%strategy' 
  { result = (Tree)parser(input, TVALUE_STRATEGY).getTree(); }
  ;

OPERATOR : '%op' 
  { result = (Tree)parser(input, TVALUE_OPERATOR).getTree(); }
  ;

TYPETERM : '%typeterm'
  { result = (Tree)parser(input, TVALUE_TYPETERM).getTree(); }
  ;

OPERATORLIST : '%oplist' 
  { result = (Tree)parser(input, TVALUE_OPERATORLIST).getTree(); }
  ;

OPERATORARRAY : '%oparray'
  { result = (Tree)parser(input, TVALUE_OPERATORARRAY).getTree(); }
  ;
*/

// following tokens are keyword for tom constructs
// do not need to switch lexers
INCLUDE : '%include' ;

GOM
    : '%gom'
      (
      |
      (
       '('
       (
       options {
         greedy=false;
         //generateAmbigWarnings=false; // shut off newline errors
       }
       : '\r' '\n' //{newline();}
       | '\r'    //{newline();}
       | '\n'    //{newline();}
       | ~('\n'|'\r')
      )*
      ')')
      )
    ;

// basic tokens
LBRACE : '{' //{ nesting++; } //{System.out.println("host nesting++ = " + nesting);}
         ;

RBRACE : '}'
  /*{
    if ( nesting<=0 ) {
      emit(Token.EOF_TOKEN);
      //System.out.println("exit embedded hostlanguage\n");
    }
    else {
      nesting--;
      //System.out.println("host nesting-- = " + nesting);
    }
  }*/
  ;

STRING : '"' (ESC|~('"'|'\\'|'\n'|'\r'))* '"'
        /*{ target.append($getText); }*/
  ;

/*
fragment LETTER    :   ('a'..'z' | 'A'..'Z')   ;
fragment DIGIT     :   ('0'..'9')  ;
ID
options{testLiterals = true;}
    :
        ('_')? LETTER
        (
            options{greedy = true;}:
            ( LETTER | DIGIT | '_' )
        )*
        {
            target.append($getText);
        }
    ;
*/

fragment
ESC
  : '\\'
    ( 'n'
    | 'r'
    | 't'
    | 'b'
    | 'f'
    | '"'
    | '\''
    | '\\'
    | ('u')+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
    | '0'..'3'
      (
        /*options {
          warnWhenFollowAmbig = false;
        }*/
      : '0'..'7'
        (
          /*options {
            warnWhenFollowAmbig = false;
          }*/
        : '0'..'7'
        )?
      )?
    | '4'..'7'
      (
        /*options {
          warnWhenFollowAmbig = false;
        }*/
      : '0'..'7'
      )?
    )
  ;

fragment
HEX_DIGIT
  : ('0'..'9'|'A'..'F'|'a'..'f')
  ;

// tokens to skip : white spaces
WS : ( ' '
 | '\t'
 | '\f'
 // handle newlines
 | ( '\r\n'  // Evil DOS
   | '\r'    // Macintosh
   | '\n'    // Unix (the right way)
   )
//   { newline(); }
  )
  { $channel=HIDDEN; }
  ;

/*WS : 
  (' '|'\r'|'\t'|'\u000C'|'\n') 
  ;*/

// comments : HIDDEN for the moment, but should be kept
COMMENT :
  ( SL_COMMENT | ML_COMMENT )
  { $channel=HIDDEN; }
  ;

fragment
ML_COMMENT : 
  '/*' ( options {greedy=false;} : . )* '*/'
//  { $channel=HIDDEN; }
  ;

fragment
SL_COMMENT :
  '//' ~('\n'|'\r')* '\r'? '\n'
//  { $channel=HIDDEN; }
  ;

/*
CODE
    :
        '%' '['
        ( { LA(2)!='%' }? ']'
        |
        )
        (
            options {
                greedy=false;
                generateAmbigWarnings=false; // shut off newline errors
            }
        : '\r' '\n' {newline();}
        | '\r'    {newline();}
        | '\n'    {newline();}
        | ~('\n'|'\r')
        )*
        ']' '%'
;

// the rule for the filter: just append the text to the buffer
fragment
TARGET
    :
        ( . )
        {target.append($getText);}
    ;
*/
