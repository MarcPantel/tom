module sa.Rule
imports String int
abstract syntax

// New AST
Program = Program(productionList:ProductionList, functionList:ProductionList, stratList:StratDeclList)
Production = SortType(Type:GomType,AlternativeList:AlternativeList)
ProductionList = ConcProduction(Production*)

Alternative = Alternative(Name:String, DomainList:FieldList, Codomain:GomType)
AlternativeList = ConcAlternative(Alternative*)
GomType = GomType(Name:String)
GomTypeList = ConcGomType(GomType*)
Field = UnamedField(FieldType:GomType)
FieldList = ConcField(Field*)

StratDecl = StratDecl(Name:String, ParamList:ParamList, Body:Expression)
StratDeclList = ConcStratDecl(StratDecl*)
Param = Param(Name:String)
ParamList = ConcParam(Param*)

TypeEnvironment = EmptyEnvironment()
                | PushEnvironment(Name:String, Type:GomType, Env:TypeEnvironment)

// Old AST
Expression = 
           | List(list:RuleList)
           | Set(list:RuleList)
           | Strat(strat:Strat)

Symbol = Symbol(name:String,arity:int)
SymbolList = SymbolList(Symbol*)

ExpressionList = ExpressionList(Expression*)

Term = Appl(symbol:String,args:TermList)
     | Var(name:String)
     | BuiltinInt(i:int)
     | Anti(term:Term)
     | At(term1:Term,term2:Term)
     | Add(addlist:AddList)
     | Sub(term1:Term, term2:Term)
     | Match(term1:Term, term2:Term)
     | TrueMatch()
     | Empty()

TermList = TermList(Term*)
AddList = ConcAdd(Term*)

Rule = Rule(lhs:Term,rhs:Term)
     | ConditionalRule(lhs:Term,rhs:Term,cond:Condition)

Condition = 
          | CondEquals(t1:Term,t2:Term)
          | CondAnd(c1:Condition,c2:Condition)
          | CondNot(c1:Condition)
          | CondTrue()
          | CondFalse()

RuleList = ConcRule(Rule*)

Strat = StratName(name:String)
      | StratRule(rule:Rule)
      | StratSequence(s1:Strat, s2:Strat)
      | StratChoice(s1:Strat, s2:Strat)
      | StratIdentity()
      | StratFail()
      | StratAll(s:Strat)
      | StratOne(s:Strat)
      | StratExp(e:Expression)
      | StratMu(name:String, s:Strat)
      | StratAppl(name:String, args:StratList)

StratList = ConcStrat(Strat*)

module Rule:rules() {
  StratExp(Strat(s)) -> s
  StratName("Identity") -> StratIdentity()
  StratName("Fail") -> StratFail()

  //Add(ConcAdd()) -> Empty()
  //Add(ConcAdd(Empty(),tail*)) -> Add(ConcAdd(tail*))
  //Appl(_,TermList(Empty(),tail*)) -> Empty()
  

}

ConcAdd:make_insert(e,l) {
  %match(e) {
    Empty() -> { return l; }
    Add(ConcAdd(L*)) -> { return `ConcAdd(L*,l*); }
  }

  if(!l.isEmptyConcAdd()) {
    if(0 < e.compareToLPO(l.getHeadConcAdd())) {
      sa.rule.types.AddList newTail = l.getTailConcAdd();
      return realMake(l.getHeadConcAdd(), `ConcAdd(e,newTail*));
    } else {
      return realMake(e,l);
      }
  }
}

// sort Rule:block() {
//   public int compareTo(Object r){
//     return this.compareToLPO(r);
//   }
// }
