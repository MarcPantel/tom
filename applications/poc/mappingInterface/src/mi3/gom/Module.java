package mi3.gom;

import base.data.types.t1.*;
import base.data.types.t2.*;
import base.data.types.T2;
import base.data.types.T1;

import mi3.mapping.IntrospectorMapping;

public class Module {

  public static final Module instance = new Module();

  public static interface MappingI<C> extends tom.library.sl.Introspector {
    boolean isInstanceOf(Object subject, C classObject);
    C make(Object[] children);
  }

  /**
   * for each constructor f, the interface f_MappingI and the abstract class
   * f_Introspector can be generated by Tom from the Module specification. If
   * the user do not need introspector, he just has to implement f_MappingI. 
   */


  public static class a_Mapping implements MappingI<a> {
    private static MappingI<a> instance = new a_Mapping();

    public static MappingI<a> getInstance() {
      return instance;
    }

    public boolean isInstanceOf(Object subject, a classObject) {
      return subject instanceof a;
    }

    public a make(Object[] children) {
      return a.make();
    }

    // LocalIntrospector
    public a setChildren(Object o, Object[] children) {
      return a.make();
    }

    public Object[] getChildren(Object o) {
      return new Object[]{ };
    }

    public <T> T setChildAt(T o, int i, Object child) {
      assert false : "Unexpected call.";
      return null;
    }

    public Object getChildAt(Object o, int i) {
      return null;
    }

    public int getChildCount(Object o) {
      return 0;
    }

    public Class forType() {
      return a.class;
    }
  }

  /** ------------------------------ */

  public static class b_Mapping implements MappingI<b> {
    private static MappingI<b> instance = new b_Mapping();

    public static MappingI<b> getInstance() {
      return instance;
    }

    public boolean isInstanceOf(Object subject, b classObject) {
      return subject instanceof b;
    }
    
    public b make(Object[] children) {
      return b.make();
    }

    // LocalIntrospector
    public b setChildren(Object o, Object[] children) {
      return b.make();
    }

    public Object[] getChildren(Object o) {
      return new Object[]{ };
    }

    public <T> T setChildAt(T o, int i, Object child) {
      assert false : "Unexpected call.";
      return null;
    }

    public Object getChildAt(Object o, int i) {
      return null;
    }

    public int getChildCount(Object o) {
      return 0;
    }

    public Class forType() {
      return b.class;
    }
  }

  /** ------------------------------ */
  public static class f_Mapping implements MappingI<f> {
    private static MappingI<f> instance = new f_Mapping();

    public static MappingI<f> getInstance() {
      return instance;
    }

    public boolean isInstanceOf(Object subject, f classObject) {
      return subject instanceof f;
    }

    public f make(Object[] children) {
      return f.make((T1) children[0], (T2) children[1]);
    }

    // LocalIntrospector
    public f setChildren(Object o, Object[] children) {
      return f.make((T1) children[0], (T2) children[1]);
    }

    public Object[] getChildren(Object o) {
      return new Object[]{ ((f)o).gets1(), ((f)o).gets2() };
    }

    public Object setChildAt(Object o, int i, Object child) {
      switch (i) {
        case 0: return f.make((T1) child, ((f)o).gets2());
        case 1: return f.make(((f)o).gets1(), (T2) child);
      }
      assert false : "Unexpected call.";
      return null;
    }

    public Object getChildAt(Object o, int i) {
      switch (i) {
        case 0: return ((f)o).gets1();
        case 1: return ((f)o).gets2();
      }
      assert false : "Unexpected call.";
      return null;
    }

    public int getChildCount(Object o) {
      return 2;
    }

    public Class forType() {
      return f.class;
    }

  }

  /** ------------------------------ */
  public static class g_Mapping implements MappingI<g> {
    private static MappingI<g> instance = new g_Mapping();

    public static MappingI<g> getInstance() {
      return instance;
    }

    public boolean isInstanceOf(Object subject, g classObject) {
      return subject instanceof g;
    }

    public g make(Object[] children) {
      return g.make((T2) children[0]);
    }

    // LocalIntrospector
    public g setChildren(Object o, Object[] children) {
      return g.make((T2) children[0]);
    }

    public Object[] getChildren(Object o) {
      return new Object[]{ ((g)o).gets2() };
    }

    public Object setChildAt(Object o, int i, Object child) {
      switch (i) {
        case 0: return g.make((T2) child);
      }
      assert false : "Unexpected call.";
      return null;
    }

    public Object getChildAt(Object o, int i) {
      switch (i) {
        case 0: return ((g)o).gets2();
      }
      assert false : "Unexpected call.";
      return null;
    }

    public int getChildCount(Object o) {
      return 1;
    }

    public Class forType() {
      return g.class;
    }

  }


}
