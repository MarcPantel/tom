BodyDecl class_body_declaration =
  TYPEMAPPING IDENTIFIER LBRACE mapping_implement.t mapping_issort.m RBRACE {:
    return new MemberClassDecl(
      new TomTypeAlias(
        new Modifiers(new List()),
        IDENTIFIER,
        new Opt(),
        new List(),
        t,
        new List().add(m)
      )
    );
  :}
;

Access mapping_implement =
IMPLEMENT LBRACE type.t RBRACE {:
  return t;
  :}
;

BodyDecl mapping_issort =
  ISSORT LPAREN IDENTIFIER.name RPAREN LBRACE expression RBRACE {:
    return new MethodDecl(
      new Modifiers(new List()),
      new TypeAccess("boolean"),
      "is_sort",
      new List().add(new ParameterDeclaration(new Modifiers(new List()), new TypeAccess("java.lang","Object"), name)),
      new List(),
      new Opt(
        new Block(
          new List().add(
            new ReturnStmt(new Opt(expression))
          )
        )
      )
   );
:}
;
 
BodyDecl class_body_declaration =
  OPMAPPING IDENTIFIER.returnType IDENTIFIER.opName LPAREN tom_typed_parameter_list.l? RPAREN LBRACE 
    mapping_make.make mapping_isfsym.isfsym (mapping_get_slot)*
  RBRACE {:
    make.setTomTypedParameterList((List)l.fullCopy());
    make.setTypeAccess(new TypeAccess("#" + returnType));
    make.setID(make.getID() + "#" + opName);
    return make;
  :}
  ;

List tom_typed_parameter_list =
  tom_typed_parameter {: return new List().add(tom_typed_parameter); :}
  | tom_typed_parameter_list COMMA tom_typed_parameter {: return tom_typed_parameter_list.add(tom_typed_parameter); :}
  ;

ParameterDeclaration tom_typed_parameter =
  IDENTIFIER.name COLON IDENTIFIER.type {: return new ParameterDeclaration(new Modifiers(new List()), new TypeAccess("#" + type), name); :}
  ;

MethodMapping mapping_isfsym =
  ISFSYM LPAREN IDENTIFIER.name RPAREN LBRACE expression RBRACE {: 
    return new MethodMapping(
      new Modifiers(new List()),
      new TypeAccess("boolean"),
      "is_fsym",
      new List().add(new ParameterDeclaration(new Modifiers(new List()), new TypeAccess("java.lang","Object"), name)),
      new List(),
      new Opt(
        new Block(
          new List().add(
            new ReturnStmt(new Opt(expression))
          )
        )
      ),
      new List()
   );
:}
;
    
MethodMapping mapping_make =
  MAKE LPAREN tom_parameter_list.l? RPAREN LBRACE expression RBRACE {: 
    return new MethodMapping(
      new Modifiers(new List().add(new Modifier("static"))),
      new TypeAccess("java.lang", "Object"),
      MAKE,
      l,
      new List(),
      new Opt(
        new Block(
          new List().add(
            new ReturnStmt(new Opt(expression))
          )
        )
      ),
      new List()
    );
  :}
  ;

  
  MethodMapping mapping_get_slot =
  GETSLOT LPAREN IDENTIFIER.slotname COMMA IDENTIFIER.subjectname RPAREN LBRACE expression RBRACE {: 
    return new MethodMapping(
      new Modifiers(new List().add(new Modifier("static"))),
      new TypeAccess("java.lang", "Object"),
      GETSLOT+"_"+slotname,
      new List().add(new TomParameter(new Modifiers(new List()), new TypeAccess("java.lang", "Object"), subjectname)),
      new List(),
      new Opt(
        new Block(
          new List().add(
            new ReturnStmt(new Opt(expression))
          )
        )
      ),
      new List()
    );
  :}
  ;


List tom_parameter_list =
  tom_parameter {: return new List().add(tom_parameter); :}
  | tom_parameter_list COMMA tom_parameter {: return tom_parameter_list.add(tom_parameter); :}
  ;

ParameterDeclaration tom_parameter =
  IDENTIFIER.name {: return new TomParameter(new Modifiers(new List()), new TypeAccess("java.lang", "Object"), name); :}
  ;

Expr expression =
  BACKQUOTE expression {: return new BackQuoteExpr(expression); :}
  ;

Stmt statement =
  MATCH LPAREN simple_name.t? expression RPAREN LBRACE rule_list RBRACE {: return new MatchStmt(t, expression, rule_list); :}
  ;

List rule_list =
    rule {: return new List().add(rule); :}
  | rule_list rule {: return rule_list.add(rule); :}
  ;

Rule rule =
  expression ARROW block {: return new Rule(expression, block); :}
  ;

