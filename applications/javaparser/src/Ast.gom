module parser.Ast

imports int String

abstract syntax

/* Java keywords used followed by a '_' :

Sorts names :

Boolean
Super

Slots names :

class
else
extends
finally
if
implements
import
package
super

*/

CompilationUnit = CompilationUnit( annotations:AnnotationList, package_:QualifiedName, import_:ImportList, types:TypeDeclList )

/*
compilationUnit
    :   annotations
        (   packageDeclaration importDeclaration* typeDeclaration*
        |   classOrInterfaceDeclaration typeDeclaration*
        )
    |   packageDeclaration? importDeclaration* typeDeclaration*
    ;
*/

/*
packageDeclaration
    :   'package' qualifiedName ';'
    ;
*/

ImportList = ImportList( Import_* )

Import_ = Import( name:QualifiedName, modifier:Modifier, wholepackage:Boolean_ )

/*
importDeclaration
    :   'import' 'static'? qualifiedName ('.' '*')? ';'
    ;
*/

TypeDeclList = TypeDeclList( TypeDecl* )

TypeDecl =
 | NormalClass    ( name:String, modifiers:ModifierList, typeparameters:TypeParameterList, extends_:Type, implements_:TypeList, classbody:Body )
 | EnumClass      ( name:String, modifiers:ModifierList, implements_:TypeList, enumbody:EnumBody )
 | NormalInterface( name:String, modifiers:ModifierList, typeparameters:TypeParameterList, interfaceextends:TypeList, interfacebody:Body )
 | AnnotationType ( name:String, modifiers:ModifierList, annotationbody:AnnotationTypeBody )
 | EmptyTypeDecl()

/* 
typeDeclaration
    :   classOrInterfaceDeclaration
    |   ';'
    ;

classOrInterfaceDeclaration
    :   classOrInterfaceModifiers (classDeclaration | interfaceDeclaration)
    ;

classOrInterfaceModifiers
    :   classOrInterfaceModifier*
    ;

classOrInterfaceModifier
    :   annotation   // class or interface
    |   'public'     // class or interface
    |   'protected'  // class or interface
    |   'private'    // class or interface
    |   'abstract'   // class or interface
    |   'static'     // class or interface
    |   'final'      // class only -- does not apply to interfaces
    |   'strictfp'   // class or interface
    ;
*/

ModifierList = ModifierList( Modifier* )

/*
modifiers
    :   modifier*
    ;

classDeclaration
    :   normalClassDeclaration
    |   enumDeclaration
    ;

normalClassDeclaration
    :   'class' Identifier typeParameters?
        ('extends' type)?
        ('implements' typeList)?
        classBody
    ;
*/

TypeParameterList = TypeParameterList( TypeParameter* )

/*
typeParameters
    :   '<' typeParameter (',' typeParameter)* '>'
    ;
*/

TypeParameter = TypeParameter( name:String, extends_:TypeList )

/*
typeParameter
    :   Identifier ('extends' typeBound)?
    ;

typeBound
    :   type ('&' type)*
    ;

enumDeclaration
    :   ENUM Identifier ('implements' typeList)? enumBody
    ;
*/

EnumBody = EnumBody( constants:EnumConstantList, bodydecls:Body )

/*
enumBody
    :   '{' enumConstants? ','? enumBodyDeclarations? '}'
    ;
*/

EnumConstantList = EnumConstantList( EnumConstant* )

/*
enumConstants
    :   enumConstant (',' enumConstant)*
    ;
*/

EnumConstant = EnumConstant( name:String, annotations:AnnotationList, arguments:ExpressionList, classbody:Body )

/*
enumConstant
    :   annotations? Identifier arguments? classBody?
    ;
    
enumBodyDeclarations
    :   ';' (classBodyDeclaration)*
    ;

interfaceDeclaration
    :   normalInterfaceDeclaration
    |   annotationTypeDeclaration
    ;
    
normalInterfaceDeclaration
    :   'interface' Identifier typeParameters? ('extends' typeList)? interfaceBody
    ;
*/

TypeList = TypeList( Type* )

/*
typeList
    :   type (',' type)*
    ;
*/

Body = BodyDeclList( BodyDecl* )

/*
classBody
    :   '{' classBodyDeclaration* '}'
    ;

interfaceBody
    :   '{' interfaceBodyDeclaration* '}'
    ;
*/

BodyDecl =
 | BlockToBodyDecl( block:Block, modifier:Modifier )
 | FieldDecl( modifiers:ModifierList, decls:VariableDeclList )
 | MethodDecl( modifiers:ModifierList, typeparameters:TypeParameterList, type:Type, name:String, formalparameters:FormalParameterDeclList, throws:QualifiedNameList, methodbody:Block )
 | ConstructorDecl( modifiers:ModifierList, typeparameters:TypeParameterList, name:String, formalparameters:FormalParameterDeclList, throws:QualifiedNameList, constructorbody:ConstructorBody )
 | TypeDeclToBodyDecl( decl:TypeDecl )
 | EmptyBodyDecl()

/*
classBodyDeclaration
    :   ';'
    |   'static'? block
    |   modifiers memberDecl
    ;

memberDecl
    :   genericMethodOrConstructorDecl
    |   memberDeclaration
    |   'void' Identifier voidMethodDeclaratorRest
    |   Identifier constructorDeclaratorRest
    |   interfaceDeclaration
    |   classDeclaration
    ;
    
memberDeclaration
    :   type (methodDeclaration | fieldDeclaration)
    ;

genericMethodOrConstructorDecl
    :   typeParameters genericMethodOrConstructorRest
    ;
    
genericMethodOrConstructorRest
    :   (type | 'void') Identifier methodDeclaratorRest
    |   Identifier constructorDeclaratorRest
    ;

methodDeclaration
    :   Identifier methodDeclaratorRest
    ;

fieldDeclaration
    :   variableDeclarators ';'
    ;

interfaceBodyDeclaration
    :   modifiers interfaceMemberDecl
    |   ';'
    ;

interfaceMemberDecl
    :   interfaceMethodOrFieldDecl
    |   interfaceGenericMethodDecl
    |   'void' Identifier voidInterfaceMethodDeclaratorRest
    |   interfaceDeclaration
    |   classDeclaration
    ;
    
interfaceMethodOrFieldDecl
    :   type Identifier interfaceMethodOrFieldRest
    ;
    
interfaceMethodOrFieldRest
    :   constantDeclaratorsRest ';'
    |   interfaceMethodDeclaratorRest
    ;

methodDeclaratorRest
    :   formalParameters ('[' ']')*
        ('throws' qualifiedNameList)?
        (   methodBody
        |   ';'
        )
    ;
    
voidMethodDeclaratorRest
    :   formalParameters ('throws' qualifiedNameList)?
        (   methodBody
        |   ';'
        )
    ;
    
interfaceMethodDeclaratorRest
    :   formalParameters ('[' ']')* ('throws' qualifiedNameList)? ';'
    ;
    
interfaceGenericMethodDecl
    :   typeParameters (type | 'void') Identifier
        interfaceMethodDeclaratorRest
    ;
    
voidInterfaceMethodDeclaratorRest
    :   formalParameters ('throws' qualifiedNameList)? ';'
    ;
    
constructorDeclaratorRest
    :   formalParameters ('throws' qualifiedNameList)? constructorBody
    ;

constantDeclarator
    :   Identifier constantDeclaratorRest
    ;
*/

VariableDeclList = VariableDeclList( VariableDecl* )

/*
variableDeclarators
    :   variableDeclarator (',' variableDeclarator)*
    ;
*/

VariableDecl = VariableDecl( type:Type, name:String, initializer:VariableInitializer )

/*
variableDeclarator
    :   variableDeclaratorId ('=' variableInitializer)?
    ;
    
constantDeclaratorsRest
    :   constantDeclaratorRest (',' constantDeclarator)*
    ;

constantDeclaratorRest
    :   ('[' ']')* '=' variableInitializer
    ;

variableDeclaratorId
    :   Identifier ('[' ']')*
    ;
*/

VariableInitializer =
 | ArrayInitializer( VariableInitializer* )
 | ExpressionToVariableInitializer( value:Expression )
 | EmptyVariableInitializer()

/*
variableInitializer
    :   arrayInitializer
    |   expression
    ;
        
arrayInitializer
    :   '{' (variableInitializer (',' variableInitializer)* (',')? )? '}'
    ;
*/

Modifier =
 | AnnotationToModifier( annotation:Annotation )
 | Public()
 | Protected()
 | Private()
 | Abstract()
 | Static()
 | Final()
 | StrictFP()
 | Native()
 | Synchronized()
 | Transient()
 | Volatile()
 | EmptyModifier()

/*
modifier
    :   annotation
    |   'public'
    |   'protected'
    |   'private'
    |   'static'
    |   'abstract'
    |   'final'
    |   'native'
    |   'synchronized'
    |   'transient'
    |   'volatile'
    |   'strictfp'
    ;

packageOrTypeName
    :   qualifiedName
    ;

enumConstantName
    :   Identifier
    ;

typeName
    :   qualifiedName
    ;
*/

// Void in place of EmptyType
Type =
 | ArrayType           ( type:Type, dimensions:int )
 | ClassOrInterfaceType( classorinterfacetype:ClassOrInterfaceType )
 | PrimitiveType       ( primitivetype:PrimitiveType )
 | Void()

/*
type
	:	classOrInterfaceType ('[' ']')*
	|	primitiveType ('[' ']')*
	;
*/

ClassOrInterfaceType =
 | IndependentType( name:String, arguments:TypeArgumentList )
 | NestedType( outername:String, outerarguments:TypeArgumentList, innertype:ClassOrInterfaceType )

/*
classOrInterfaceType
	:	Identifier typeArguments? ('.' Identifier typeArguments? )*
	;
*/

PrimitiveType =
 | Boolean()
 | Char()
 | Byte()
 | Short()
 | Int()
 | Long()
 | Float()
 | Double()

/*
primitiveType
    :   'boolean'
    |   'char'
    |   'byte'
    |   'short'
    |   'int'
    |   'long'
    |   'float'
    |   'double'
    ;

variableModifier
    :   'final'
    |   annotation
    ;
*/

TypeArgumentList = TypeArgumentList( TypeArgument* )

/*
typeArguments
    :   '<' typeArgument (',' typeArgument)* '>'
    ;
*/

TypeArgument =
 | ExplicitTypeArgument( type:Type )
 | ExtendTypeArgument( type:Type )
 | SuperTypeArgument( type:Type )
 | WildCardTypeArgument()

/*
typeArgument
    :   type
    |   '?' (('extends' | 'super') type)?
    ;
*/

QualifiedNameList = QualifiedNameList( QualifiedName* )

/*
qualifiedNameList
    :   qualifiedName (',' qualifiedName)*
    ;
*/

FormalParameterDeclList = FormalParameterDeclList( FormalParameterDecl* )

/*
formalParameters
    :   '(' formalParameterDecls? ')'
    ;
*/

FormalParameterDecl = FormalParameterDecl( modifiers:ModifierList, type:Type, name:String, variablenumber:Boolean_ )

/*
formalParameterDecls
    :   variableModifiers type formalParameterDeclsRest
    ;
    
formalParameterDeclsRest
    :   variableDeclaratorId (',' formalParameterDecls)?
    |   '...' variableDeclaratorId
    ;
    
methodBody
    :   block
    ;
*/

ConstructorBody = ConstructorBody( constructorinvocation:ExplicitConstructorInvocation, block:Block )

/*
constructorBody
    :   '{' explicitConstructorInvocation? blockStatement* '}'
    ;
*/

ExplicitConstructorInvocation =
 | ThisInvocation        ( typearguments:TypeList, argument:ExpressionList )
 | SuperInvocation       ( typearguments:TypeList, argument:ExpressionList )
 | PrimarySuperInvocation( primary:Primary, typearguments:TypeList, argument:ExpressionList )
 | EmptyExplicitConstructorInvocation()

/*
explicitConstructorInvocation
    :   nonWildcardTypeArguments? ('this' | 'super') arguments ';'
    |   primary '.' nonWildcardTypeArguments? 'super' arguments ';'
    ;
*/

QualifiedName =
 | QualifiedName( String* )

/*
qualifiedName
    :   Identifier ('.' Identifier)*
    ;

literal 
    :   integerLiteral
    |   FloatingPointLiteral
    |   CharacterLiteral
    |   StringLiteral
    |   booleanLiteral
    |   'null'
    ;

integerLiteral
    :   HexLiteral
    |   OctalLiteral
    |   DecimalLiteral
    ;
*/

Boolean_ =
 | True()
 | False()

/*
booleanLiteral
    :   'true'
    |   'false'
    ;
*/

// ANNOTATIONS

AnnotationList = AnnotationList( Annotation* )

/*
annotations
    :   annotation+
    ;
*/

Annotation =
 | Element( name:QualifiedName, value:ElementValue )
 | Pairs( name:QualifiedName, pairs:ElementValuePairList )
 | NameToAnnotation( name:QualifiedName )

/*
annotation
    :   '@' annotationName ( '(' ( elementValuePairs | elementValue )? ')' )?
    ;

annotationName
    : Identifier ('.' Identifier)*
    ;
*/

ElementValuePairList = ElementValuePairList( ElementValuePair* )

/*
elementValuePairs
    :   elementValuePair (',' elementValuePair)*
    ;
*/

ElementValuePair = ElementValuePair( name:String, value:ElementValue )

/*
elementValuePair
    :   Identifier '=' elementValue
    ;
*/

ElementValue =
 | ExpressionToElementValue( expression:Expression )
 | AnnotationToElementValue( annotation:Annotation )
 | ElementValueArrayInitializer( ElementValue* )
 | EmptyElementValue()

/*
elementValue
    :   conditionalExpression
    |   annotation
    |   elementValueArrayInitializer
    ;
    
elementValueArrayInitializer
    :   '{' (elementValue (',' elementValue)*)? (',')? '}'
    ;

annotationTypeDeclaration
    :   '@' 'interface' Identifier annotationTypeBody
    ;
*/

AnnotationTypeBody = AnnotationTypeBody( AnnotationTypeElementDecl* )

/*
annotationTypeBody
    :   '{' (annotationTypeElementDeclaration)* '}'
    ;
*/

AnnotationTypeElementDecl =
 | AnnotationMethod  ( modifiers:ModifierList, type:Type, name:String, defaultvalue:ElementValue )
 | AnnotationConstant( modifiers:ModifierList, type:Type, decls:VariableDeclList )
 | TypeDeclToAnnotationElement( decl:TypeDecl )

/*
annotationTypeElementDeclaration
    :   modifiers annotationTypeElementRest
    ;
    
annotationTypeElementRest
    :   type annotationMethodOrConstantRest ';'
    |   normalClassDeclaration ';'?
    |   normalInterfaceDeclaration ';'?
    |   enumDeclaration ';'?
    |   annotationTypeDeclaration ';'?
    ;
    
annotationMethodOrConstantRest
    :   annotationMethodRest
    |   annotationConstantRest
    ;
    
annotationMethodRest
    :   Identifier '(' ')' defaultValue?
    ;
    
annotationConstantRest
    :   variableDeclarators
    ;
    
defaultValue
    :   'default' elementValue
    ;
*/

// STATEMENTS / BLOCKS

Block = BlockStatementList( BlockStatement* )

/*
block
    :   '{' blockStatement* '}'
    ;
*/

BlockStatement =
 | FieldDeclToBlockStatement( fielddecl:BodyDecl )
 | TypeDeclToBlockStatement( typedecl:TypeDecl )
 | Statement( statement:Statement )

/*
blockStatement
    :   localVariableDeclarationStatement
    |   classOrInterfaceDeclaration
    |   statement
    ;
    
localVariableDeclarationStatement
    :    localVariableDeclaration ';'
    ;

localVariableDeclaration
    :   variableModifiers type variableDeclarators
    ;

variableModifiers
    :   variableModifier*
    ;
*/

Statement =
 | BlockToStatement( block:Block )
 | Assert( expression:Expression, value:Expression )
 | If( test:Expression, then:Statement, else_:Statement )
 | For    ( control:ForControl, statementbody:Statement )
 | While  ( test:Expression, statementbody:Statement )
 | DoWhile( statementbody:Statement, test:Expression )
 | Try( blockbody:Block, catches:CatchClauseList, finally_:Block )
 | Switch( expression:Expression, groups:SwitchBlockStatementGroupList )
 | SynchronizedStatement( object:Expression, blockbody:Block )
 | Return( result:Expression )
 | Throw ( exception:Expression )
 | Break   ( label:String )
 | Continue( label:String )
 | EmptyStatement()
 | ExpressionToStatement( expression:Expression )
 | Label( name:String, statementbody:Statement )

/*
statement
    : block
    |   ASSERT expression (':' expression)? ';'
    |   'if' parExpression statement (options {k=1;}:'else' statement)?
    |   'for' '(' forControl ')' statement
    |   'while' parExpression statement
    |   'do' statement 'while' parExpression ';'
    |   'try' block
        ( catches 'finally' block
        | catches
        |   'finally' block
        )
    |   'switch' parExpression '{' switchBlockStatementGroups '}'
    |   'synchronized' parExpression block
    |   'return' expression? ';'
    |   'throw' expression ';'
    |   'break' Identifier? ';'
    |   'continue' Identifier? ';'
    |   ';' 
    |   statementExpression ';'
    |   Identifier ':' statement
    ;
*/

CatchClauseList = CatchClauseList( CatchClause* )

/*
catches
    :   catchClause (catchClause)*
    ;
*/

CatchClause = CatchClause( parameter:FormalParameter, body:Block )

/*
catchClause
    :   'catch' '(' formalParameter ')' block
    ;
*/

FormalParameter = FormalParameter( modifiers:ModifierList, type:Type, name:String )

/*
formalParameter
    :   variableModifiers type variableDeclaratorId
    ;
*/

SwitchBlockStatementGroupList = SwitchBlockStatementGroupList( SwitchBlockStatementGroup* )

/*
switchBlockStatementGroups
    :   (switchBlockStatementGroup)*
    ;
*/

SwitchBlockStatementGroup = SwitchBlockStatementGroup( labels:SwitchLabelList, body:Block )

/*
/* The change here (switchLabel -> switchLabel+) technically makes this grammar
   ambiguous; but with appropriately greedy parsing it yields the most
   appropriate AST, one in which each group, except possibly the last one, has
   labels and statements. * /
switchBlockStatementGroup
    :   switchLabel+ blockStatement*
    ;
*/

SwitchLabelList = SwitchLabelList( SwitchLabel* )

SwitchLabel =
 | ConstantExpressionToSwitchLabel( expression:Expression )
 | EnumConstantNameToSwitchLabel  ( name:String )
 | Default()

/*
switchLabel
    :   'case' constantExpression ':'
    |   'case' enumConstantName ':'
    |   'default' ':'
    ;
*/

ForControl =
 | EnhancedForControl( modifiers:ModifierList, type:Type, variable:String, items:Expression )
 | StandardForControl( init:ForInit, test:Expression, update:ExpressionList )

/*
forControl
options {k=3;} // be efficient for common case: for (ID ID : ID) ...
    :   enhancedForControl
    |   forInit? ';' expression? ';' forUpdate?
    ;
*/

ForInit =
 | FieldDeclToForInit( decl:BodyDecl )
 | ExpressionListToForInit( Expression* )
 | EmptyForInit()

/*
forInit
    :   localVariableDeclaration
    |   expressionList
    ;

enhancedForControl
    :   variableModifiers type Identifier ':' expression
    ;

forUpdate
    :   expressionList
    ;
*/

// EXPRESSIONS

/*
parExpression
    :   '(' expression ')'
    ;
*/

ExpressionList = ExpressionList( Expression* )

/*
expressionList
    :   expression (',' expression)*
    ;

statementExpression
    :   expression
    ;
    
constantExpression
    :   expression
    ;
*/

Expression =
 | Assign( lhs:Expression, rhs:Expression )
 | PlusAssign ( lhs:Expression, rhs:Expression )
 | MinusAssign( lhs:Expression, rhs:Expression )
 | TimesAssign( lhs:Expression, rhs:Expression )
 | DivAssign  ( lhs:Expression, rhs:Expression )
 | AndAssign  ( lhs:Expression, rhs:Expression )
 | OrAssign   ( lhs:Expression, rhs:Expression )
 | XOrAssign  ( lhs:Expression, rhs:Expression )
 | ModAssign  ( lhs:Expression, rhs:Expression )
 | LeftShiftAssign         ( lhs:Expression, rhs:Expression )
 | UnsignedRightShiftAssign( lhs:Expression, rhs:Expression )
 | SignedRightShiftAssign  ( lhs:Expression, rhs:Expression )
 | Conditional( if_:Expression, then:Expression, else_:Expression )
 | ConditionalOr ( lhs:Expression, rhs:Expression )
 | ConditionalAnd( lhs:Expression, rhs:Expression )
 | InclusiveOr   ( lhs:Expression, rhs:Expression )
 | ExclusiveOr   ( lhs:Expression, rhs:Expression )
 | And           ( lhs:Expression, rhs:Expression )
 | Equal   ( lhs:Expression, rhs:Expression )
 | NotEqual( lhs:Expression, rhs:Expression )
 | InstanceOf( lhs:Expression, rhs:Expression )
 | LowerOrEqual  ( lhs:Expression, rhs:Expression )
 | GreaterOrEqual( lhs:Expression, rhs:Expression )
 | Lower         ( lhs:Expression, rhs:Expression )
 | Greater       ( lhs:Expression, rhs:Expression )
 | LeftShift         ( lhs:Expression, rhs:Expression )
 | UnsignedRightShift( lhs:Expression, rhs:Expression )
 | SignedRightShift  ( lhs:Expression, rhs:Expression )
 | Plus ( lhs:Expression, rhs:Expression )
 | Minus( lhs:Expression, rhs:Expression )
 | Times( lhs:Expression, rhs:Expression )
 | Div  ( lhs:Expression, rhs:Expression )
 | Mod  ( lhs:Expression, rhs:Expression )
 | UPlus ( expression:Expression )
 | UMinus( expression:Expression )
 | PreInc ( expression:Expression )
 | PreDec ( expression:Expression )
 | PostInc( expression:Expression )
 | PostDec( expression:Expression )
 | BitwiseNot( expression:Expression )
 | LogicalNot( expression:Expression )
 | TypeCast( casttype:Type, expression:Expression )
 | ExpressionCast( castexpression:Expression, expression:Expression ) // semantics ?
 | Primary( primary:Primary, selectors:SuffixList )
 | EmptyExpression()

/*
expression
    :   conditionalExpression (assignmentOperator expression)?
    ;

assignmentOperator
    :   '='
    |   '+='
    |   '-='
    |   '*='
    |   '/='
    |   '&='
    |   '|='
    |   '^='
    |   '%='
    |   ('<' '<' '=')=> t1='<' t2='<' t3='=' 
        { $t1.getLine() == $t2.getLine() &&
          $t1.getCharPositionInLine() + 1 == $t2.getCharPositionInLine() && 
          $t2.getLine() == $t3.getLine() && 
          $t2.getCharPositionInLine() + 1 == $t3.getCharPositionInLine() }?
    |   ('>' '>' '>' '=')=> t1='>' t2='>' t3='>' t4='='
        { $t1.getLine() == $t2.getLine() && 
          $t1.getCharPositionInLine() + 1 == $t2.getCharPositionInLine() &&
          $t2.getLine() == $t3.getLine() && 
          $t2.getCharPositionInLine() + 1 == $t3.getCharPositionInLine() &&
          $t3.getLine() == $t4.getLine() && 
          $t3.getCharPositionInLine() + 1 == $t4.getCharPositionInLine() }?
    |   ('>' '>' '=')=> t1='>' t2='>' t3='='
        { $t1.getLine() == $t2.getLine() && 
          $t1.getCharPositionInLine() + 1 == $t2.getCharPositionInLine() && 
          $t2.getLine() == $t3.getLine() && 
          $t2.getCharPositionInLine() + 1 == $t3.getCharPositionInLine() }?
    ;

conditionalExpression
    :   conditionalOrExpression ( '?' expression ':' expression )?
    ;

conditionalOrExpression
    :   conditionalAndExpression ( '||' conditionalAndExpression )*
    ;

conditionalAndExpression
    :   inclusiveOrExpression ( '&&' inclusiveOrExpression )*
    ;

inclusiveOrExpression
    :   exclusiveOrExpression ( '|' exclusiveOrExpression )*
    ;

exclusiveOrExpression
    :   andExpression ( '^' andExpression )*
    ;

andExpression
    :   equalityExpression ( '&' equalityExpression )*
    ;

equalityExpression
    :   instanceOfExpression ( ('==' | '!=') instanceOfExpression )*
    ;

instanceOfExpression
    :   relationalExpression ('instanceof' type)?
    ;

relationalExpression
    :   shiftExpression ( relationalOp shiftExpression )*
    ;
    
relationalOp
    :   ('<' '=')=> t1='<' t2='=' 
        { $t1.getLine() == $t2.getLine() && 
          $t1.getCharPositionInLine() + 1 == $t2.getCharPositionInLine() }?
    |   ('>' '=')=> t1='>' t2='=' 
        { $t1.getLine() == $t2.getLine() && 
          $t1.getCharPositionInLine() + 1 == $t2.getCharPositionInLine() }?
    |   '<' 
    |   '>' 
    ;

shiftExpression
    :   additiveExpression ( shiftOp additiveExpression )*
    ;

shiftOp
    :   ('<' '<')=> t1='<' t2='<' 
        { $t1.getLine() == $t2.getLine() && 
          $t1.getCharPositionInLine() + 1 == $t2.getCharPositionInLine() }?
    |   ('>' '>' '>')=> t1='>' t2='>' t3='>' 
        { $t1.getLine() == $t2.getLine() && 
          $t1.getCharPositionInLine() + 1 == $t2.getCharPositionInLine() &&
          $t2.getLine() == $t3.getLine() && 
          $t2.getCharPositionInLine() + 1 == $t3.getCharPositionInLine() }?
    |   ('>' '>')=> t1='>' t2='>'
        { $t1.getLine() == $t2.getLine() && 
          $t1.getCharPositionInLine() + 1 == $t2.getCharPositionInLine() }?
    ;


additiveExpression
    :   multiplicativeExpression ( ('+' | '-') multiplicativeExpression )*
    ;

multiplicativeExpression
    :   unaryExpression ( ( '*' | '/' | '%' ) unaryExpression )*
    ;

unaryExpression
    :   '+' unaryExpression
    |   '-' unaryExpression
    |   '++' unaryExpression
    |   '--' unaryExpression
    |   unaryExpressionNotPlusMinus
    ;

unaryExpressionNotPlusMinus
    :   '~' unaryExpression
    |   '!' unaryExpression
    |   castExpression
    |   primary selector* ('++'|'--')?
    ;

castExpression
    :  '(' primitiveType ')' unaryExpression
    |  '(' (type | expression) ')' unaryExpressionNotPlusMinus
    ;
*/

Primary =
 | ExpressionToPrimary( expression:Expression )
 | This( nested:QualifiedName, suffix:Suffix )
 | Super( super_:Super_ )
 | HexLiteral          ( stringvalue:String )
 | OctalLiteral        ( stringvalue:String )
 | DecimalLiteral      ( stringvalue:String )
 | FloatingPointLiteral( stringvalue:String )
 | CharacterLiteral    ( stringvalue:String )
 | StringLiteral       ( stringvalue:String )
 | BooleanLiteral      ( booleanvalue:Boolean_ )
 | Null                ()
 | ClassCreator              ( typearguments:TypeList, class_:Type, arguments:ExpressionList, body:Body )
 | InitializedArrayCreator   ( type:Type, initializer:VariableInitializer )
 | NonInitializedArrayCreator( fixedlengths:ExpressionList, nonfixeddimensions:int )
 | QualifiedNameToPrimary( name:QualifiedName, suffix:Suffix )
 | Class( type:Type )

/*
primary
    :   parExpression
    |   'this' ('.' Identifier)* identifierSuffix?
    |   'super' superSuffix
    |   literal
    |   'new' creator
    |   Identifier ('.' Identifier)* identifierSuffix?
    |   primitiveType ('[' ']')* '.' 'class'
    |   'void' '.' 'class'
    ;
*/

// "identifierSuffix" and "selector" included

SuffixList = SuffixList( Suffix* )

Suffix =
 | ArrayClassSuffix( dimension:int )
 | ArgumentsSuffix( arguments:ExpressionList )
 | CallSuffix( method:String, arguments:ExpressionList )
 | ExplicitGenericInvocation( typearguments:TypeList, name:String, arguments:ExpressionList )
 | ThisSuffix()
 | SuperSuffix( super_:Super_ )
 | InnerCreator( typearguments:TypeList, class_:String, arguments:ExpressionList, body:Body )
 | ArrayIndexSuffix( position:ExpressionList )
 | EmptySuffix()

/*
identifierSuffix
    :   ('[' ']')+ '.' 'class'
    |   ('[' expression ']')+ // can also be matched by selector, but do here
    |   arguments
    |   '.' 'class'
    |   '.' explicitGenericInvocation
    |   '.' 'this'
    |   '.' 'super' arguments
    |   '.' 'new' innerCreator
    ;

creator
    :   nonWildcardTypeArguments createdName classCreatorRest
    |   createdName (arrayCreatorRest | classCreatorRest)
    ;

createdName
    :   classOrInterfaceType
    |   primitiveType
    ;

innerCreator
    :   nonWildcardTypeArguments? Identifier classCreatorRest
    ;

arrayCreatorRest
    :   '['
        (   ']' ('[' ']')* arrayInitializer
        |   expression ']' ('[' expression ']')* ('[' ']')*
        )
    ;

classCreatorRest
    :   arguments classBody?
    ;
    
explicitGenericInvocation
    :   nonWildcardTypeArguments Identifier arguments
    ;
    
nonWildcardTypeArguments
    :   '<' typeList '>'
    ;

selector
    :   '.' Identifier arguments?
    |   '.' 'this'
    |   '.' 'super' superSuffix
    |   '.' 'new' innerCreator
    |   '[' expression ']'
    ;
*/

Super_ =
 | SuperConstruction( arguments:ExpressionList )
 | SuperFieldAccess( name:String )
 | SuperCall( name:String, arguments:ExpressionList )

/*
superSuffix
    :   arguments
    |   '.' Identifier arguments?
    ;

arguments
    :   '(' expressionList? ')'
    ;
*/

// LEXER

/*
HexLiteral : '0' ('x'|'X') HexDigit+ IntegerTypeSuffix? ;

DecimalLiteral : ('0' | '1'..'9' '0'..'9'*) IntegerTypeSuffix? ;

OctalLiteral : '0' ('0'..'7')+ IntegerTypeSuffix? ;

fragment
HexDigit : ('0'..'9'|'a'..'f'|'A'..'F') ;

fragment
IntegerTypeSuffix : ('l'|'L') ;

FloatingPointLiteral
    :   ('0'..'9')+ '.' ('0'..'9')* Exponent? FloatTypeSuffix?
    |   '.' ('0'..'9')+ Exponent? FloatTypeSuffix?
    |   ('0'..'9')+ Exponent FloatTypeSuffix?
    |   ('0'..'9')+ FloatTypeSuffix
    ;

fragment
Exponent : ('e'|'E') ('+'|'-')? ('0'..'9')+ ;

fragment
FloatTypeSuffix : ('f'|'F'|'d'|'D') ;

CharacterLiteral
    :   '\'' ( EscapeSequence | ~('\''|'\\') ) '\''
    ;

StringLiteral
    :  '"' ( EscapeSequence | ~('\\'|'"') )* '"'
    ;

fragment
EscapeSequence
    :   '\\' ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
    |   UnicodeEscape
    |   OctalEscape
    ;

fragment
OctalEscape
    :   '\\' ('0'..'3') ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7')
    ;

fragment
UnicodeEscape
    :   '\\' 'u' HexDigit HexDigit HexDigit HexDigit
    ;

ENUM:   'enum' {if (!enumIsKeyword) $type=Identifier;}
    ;
    
ASSERT
    :   'assert' {if (!assertIsKeyword) $type=Identifier;}
    ;

Identifier 
    :   Letter (Letter|JavaIDDigit)*
    ;

/**I found this char range in JavaCC's grammar, but Letter and Digit overlap.
   Still works, but...
 * /
fragment
Letter
    :  '\u0024' |
       '\u0041'..'\u005a' |
       '\u005f' |
       '\u0061'..'\u007a' |
       '\u00c0'..'\u00d6' |
       '\u00d8'..'\u00f6' |
       '\u00f8'..'\u00ff' |
       '\u0100'..'\u1fff' |
       '\u3040'..'\u318f' |
       '\u3300'..'\u337f' |
       '\u3400'..'\u3d2d' |
       '\u4e00'..'\u9fff' |
       '\uf900'..'\ufaff'
    ;

fragment
JavaIDDigit
    :  '\u0030'..'\u0039' |
       '\u0660'..'\u0669' |
       '\u06f0'..'\u06f9' |
       '\u0966'..'\u096f' |
       '\u09e6'..'\u09ef' |
       '\u0a66'..'\u0a6f' |
       '\u0ae6'..'\u0aef' |
       '\u0b66'..'\u0b6f' |
       '\u0be7'..'\u0bef' |
       '\u0c66'..'\u0c6f' |
       '\u0ce6'..'\u0cef' |
       '\u0d66'..'\u0d6f' |
       '\u0e50'..'\u0e59' |
       '\u0ed0'..'\u0ed9' |
       '\u1040'..'\u1049'
   ;

WS  :  (' '|'\r'|'\t'|'\u000C'|'\n') {$channel=HIDDEN;}
    ;

COMMENT
    :   '/*' ( options {greedy=false;} : . )* '* /' {$channel=HIDDEN;}
    ;

LINE_COMMENT
    : '//' ~('\n'|'\r')* '\r'? '\n' {$channel=HIDDEN;}
    ;

*/

