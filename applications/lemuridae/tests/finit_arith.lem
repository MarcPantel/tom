termrule appl(t,nil()) -> t.
termrule appl(one(),cons(t,l)) -> t.
termrule appl(S(n),cons(t,l)) -> appl(n,l).
termrule appl(succ(t),l) -> succ(appl(t,l)).
termrule appl(pred(t),l) -> pred(appl(t,l)).
termrule appl(t1+t2,l) -> appl(t1,l) + appl(t2,l).
termrule appl(t1*t2,l) -> appl(t1,l) * appl(t2,l).

termrule pred(0) -> 0.
termrule pred(succ(x)) -> x.
termrule 0 + y -> y.
termrule 0 * y -> 0.
termrule succ(x) + y -> succ(x+y).
termrule succ(x) * y -> x * y + y.

proprule in(l,fNull(t)) -> Null(appl(t,l)).
proprule in(l,fEq(t1,t2)) -> eq( appl(t1,l), appl(t2,l) ).
proprule in(l,fN(t)) -> N(appl(t,l)).
rule eq(x,y) -> \AA.(  in(cons(x,nil()),A) => in(cons(y,nil()),A) ).
rule N(n) -> \AA.( in(cons(0,nil()),A) => ( \Ay.(in(cons(y,nil()),A) =>  in(cons(succ(y),nil()),A)) => in(cons(n,nil()),A) )).
hered.
rule Null(0) -> \T.
rule Null(succ(x)) -> \B.
proprule in(l,inter(A,B)) -> in(l,A) /\ in(l,B).
proprule in(l,union(A,B)) -> in(l,A) \/ in(l,B).
proprule in(l,supset(A,B)) -> in(l,A) => in(l,B).
proprule in(l,emptyset()) -> \B.
proprule in(l,P(p)) -> \En.(in(cons(n,l),p)).
proprule in(l,C(p)) -> \An.(in(cons(n,l),p)).


rule Pair(0) -> \T.
rule Pair(succ(n)) -> Impair(n).
rule Impair(succ(n)) -> Pair(n).

proprule in(l,fPair(t)) -> Pair(appl(t,l)).
proprule in(l,fImpair(t)) -> Impair(appl(t,l)).



proof zisnat: N(0).
rule. 
axiom.

proof oneisnat: N(1).
rule.
focus h2. rule. 0.
axiom. axiom.

proof ind: \A n. (N(n) => N(succ(n))).
auto.
focus h3. rule. inter(fN(one()),A0).
reduce.
intro.
axiom.
theorem zisnat. axiom.
next.
reduce.
intros.
focus h4. rule. n0.
axiom.
axiom.
rule. reduce.
intros.
focus h4. rule. y0.
axiom.
axiom.
focus h4. rule. n0.
next. axiom.
focus h5. rule. A0.
axiom.
axiom.
axiom.

proof eqrefl: \Ax.eq(x,x).
auto.

proof succisafun: \Ax.(\Ay.( eq(x,y) => eq(succ(x),succ(y)) )).
intros.
focus h1. rule. fEq(S(succ(x0)),succ(one())).
reduce.
axiom.
reduce.
theorem eqrefl.
focus h2. intro. succ(x0). axiom.

proof natcase: \A n.(N(n) => (Null(n) \/ \E m.(N(m) /\ eq(n,succ(m))))).
intros.
focus h1. rule. inter(fN(one()),union(fNull(one()),P(inter(fN(one()),fEq(S(one()),succ(one())))))).
next. 
reduce. intros.
focus c2. intro. n1. 
intros.
reduce.
intro. intro. rule.
theorem zisnat. axiom.
focus h1. remove. focus c2. remove. focus c2. remove.
rule. reduce.
intros.
focus c2. intro. succ(n0).
intros.
theorem succisafun.
focus h4. intro. y0. focus h4. intro. succ(n0).
intros.
theorem ind.
focus h4. intro. n0.
intros.
focus c2. intro. y0.
auto.
theorem ind.
focus h4. intro. y0.
intros.
theorem ind.
focus h3. intro. y0.
intros.

proof predsucc: \An.(N(n) => (~Null(n)) => eq(pred(succ(n)), succ(pred(n)))).
intros.
focus h1. rule. union(fNull(one()), fEq(pred(succ(one())),succ(pred(one())))).
reduce.
intro.
rule.
next.
reduce.
intros.
rule. reduce.
auto.

proof discriminate: \An.(~eq(0,succ(n))).
intros.
focus h1. rule. fNull(one()).
reduce.
auto.
reduce.
rule.

proof pair2n : \Ax.(\Ay.eq(x+y,y+x)) => \An.(N(n) => Pair(succ(succ(0))*n)).
reduce.
intros.
focus h2. rule. fPair(one()+one()).
reduce.
rule.
rule.
reduce.
rule.
focus h2. intro. succ(y0).
focus h2. intro. y0.
focus h2. rule. fImpair(one()).
reduce.
axiom.
reduce. auto.
reduce. axiom.


proof eqsym: \Ax.(\Ay.( eq(x,y) => eq(y,x) )).
intros.
focus h1. rule. fEq(one(),S(x0)).
reduce.
axiom.
reduce.
theorem eqrefl.
focus h2. intro. x0. axiom.

proof eqtrans:  \Ax.(\Ay.(\Az.( eq(x,y) => (eq(y,z) => eq(x,z)) ))).
auto.
focus h2. rule. A0.
focus h4. rule. A0.
axiom.
axiom.
axiom.


proof nplus0:   \An.(N(n) => eq(n+0,n)).
intros.
focus h1. rule. fEq(one()+S(0),one()).
next.
reduce. axiom.
reduce.
theorem eqrefl.
focus h2. intro. 0.
axiom.
rule.
reduce.
theorem succisafun.
focus h3. intro. (y0+0). focus h3. intro. (y0).
intros.

proof plusassoc:   \Ax.(\Ay.(\Az.(N(x) => eq( x+(y+z) , (x+y)+z )))).
intros.
focus h1. rule. fEq( one()+(S(y0)+S(z0)) , one()+S(y0)+S(z0) ).
next. reduce. axiom.
reduce. 
theorem eqrefl.
focus h2. intro. y0+z0. axiom.
rule.
reduce.
theorem succisafun.
focus h3. intro. y1+(y0+z0). focus h3. intro. (y1+y0)+z0. 
intros.

proof plusnSm:  \An.(\Am.( N(n) => eq(succ(n+m),n+succ(m)))).
intros.
focus h1. rule. fEq(succ(one()+S(m0)),one()+succ(S(m0))).
next. reduce. axiom.
reduce.
theorem eqrefl.
focus h2. intro. succ(m0). axiom.
rule.
reduce.
theorem succisafun.
focus h3. intro. succ(y0+m0). focus h3. intro. y0+succ(m0).
intros.


proof pluscommut:  \An.(\Am.(N(n)=>(N(m)=>eq(n+m,m+n)))).
intros.
focus h1. rule. fEq(one()+S(m0),S(m0)+one()).
next. reduce. axiom.
reduce.
theorem nplus0.
focus h3. intro. m0.
intros.
theorem eqsym.
focus h4. intro. m0+0.
focus h4. intro. m0.
intros.
rule. reduce.
theorem plusnSm.
focus h4. intro. m0.
focus h4. intro. y0.
intros.
theorem succisafun.
focus h5. intro. y0+m0. focus h5. intro. m0+y0. 
intros.
theorem eqtrans.
focus h6. intro. succ(y0+m0).
focus h6. intro. succ(m0+y0).
focus h6. intro. m0+succ(y0).
intros.

proof multn0:  \An.(N(n) => eq(0,n*0)).
intros..
focus h1. rule. fEq(S(0),one()*S(0)).
next. reduce. axiom.
reduce.
theorem eqrefl.
focus h2. intro. 0. axiom.
rule. reduce.
focus h1. rule. fEq(S(0),one()+S(0)).
reduce. axiom.
reduce.
theorem eqrefl.
focus h3. intro. 0. axiom.



/*

rule le(0,n) -> \T.
rule le(succ(n),0) -> \B.
proprule le(succ(n),succ(m)) ->  le(n,m).
proprule in(l,fLe(n1,n2)) -> le(appl(n1,l),appl(n2,l)).


proof lerefl : \A n.(N(n) => le(n,n)).
intros.
focus h1. rule. fLe(one(),one()).
reduce. rule.
rule. reduce.
axiom.
reduce. axiom.



proof letrans : \An.(\Am.(\Ap.( N(n) => N(m) => N(p) => le(n,m) => le(m,p) => le(n,p)))).
intro.intro.intro. intro.intro.intro.
focus h1. rule. supset(fLe(one(),S(m0)),supset(fLe(S(m0),S(p0)),fLe(one(),S(p0)))).
next. reduce. axiom.
reduce.
intros. rule.
rule. reduce.
focus h3. rule. supset( supset(fLe(S(y0),one()),supset(fLe(one(),S(p0)),fLe(S(y0),S(p0)))),
                        supset(fLe(S(succ(y0)),one()),supset(fLe(one(),S(p0)),fLe(S(succ(y0)),S(p0))))        ).
next. reduce. axiom.
reduce.


termrule fib(0) -> 1.
termrule fib(1) -> 1.
termrule fib(succ(succ(n))) -> fib(succ(n)) + fib(n).

termrule appl(fib(n),l) -> fib(appl(n,l)).


proof ltnsm: \An.(\Am.(N(n) => N(m) => lt(n,m) => lt(n,succ(m)))).
intro. intro. intro. intro.
focus h1. rule. supset(fLt(one(),S(m0)),fLt(one(),S(succ(m0)))).
reduce.
intros.
rule.
next.
reduce. axiom.
rule. reduce.

pas fini




proof plusmonoton: \An.(\Am.(N(n) => N(m) => lt(0,n) => lt(0,m) => lt(0,n+m))).
focus h1. rule. supset(fLt(S(0),one()),fLt(S(0),plus(one(),S(m0)))).
reduce. intros.
next.
reduce. intros.
rule. reduce.
intros.

pas fini



proof fibmonoton: \Ax.(\Ay.(N(x) => N(y) => lt(x,y) => lt(fib(x),fib(y)))).
intro.intro.intro.intro.
focus h1. rule. supset(fLt(one(),S(y0)),fLt(fib(one()),fib(S(y0)))).
next. reduce. axiom.
reduce.
focus h2. rule. supset(fLt(S(0),one()),fLt(fib(S(1)),fib(one()))).
reduce. intros.
next. next. 
reduce. axiom.
rule. reduce.

*/







