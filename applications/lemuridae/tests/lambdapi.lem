termrule lappl(lambda(a),b) -> subst(a,lcons(b,id())) .
termrule subst(lappl(b,a),s) -> lappl(subst(b,s),subst(a,s)).
termrule subst(one(),lcons(a,s)) -> a.
termrule subst(a,id()) -> a.
termrule subst(lambda(a),s) -> lambda(subst(a,lcons(one(),rond(s,shift())))).
termrule subst(subst(a,s),t) -> subst(a,rond(s,t)).
termrule rond(id(),s) -> s.
termrule rond(shift(),lcons(a,s)) -> s.
termrule rond(rond(s1,s2),s3) -> rond(s1,rond(s2,s3)).
termrule rond(lcons(a,s),t) -> lcons(subst(a,t),rond(s,t)).
termrule rond(s,id()) -> s.
termrule lcons(one(),shift()) -> id().
termrule lcons(subst(one(),s), rond(shift(), s)) -> s.

termrule subst(pitype(a,b),s) -> pitype(subst(a,s),subst(b,lcons(one(),rond(s,shift())))).
termrule subst(pikind(a,b),s) -> pikind(subst(a,s),subst(b,lcons(one(),rond(s,shift())))).

rule in(type(),kind()) -> \T.
rule in(pitype(a,b),type()) -> in(a,type()) /\ 
		    \Az. (in(z,a) => in(subst(b,lcons(z,id())), type())).
rule in(pikind(a,b),kind()) -> in(a,type()) /\ 
		    \Az. (in(z,a) => in(subst(b,lcons(z,id())), kind())).
rule in(a,pitype(b,c)) -> in(b,type()) /\ \Az. (in(z,b) =>
	       	  (in(lappl(a,z),subst(c,lcons(z,id()))) /\ in(subst(c,lcons(z,id())),type()))).
rule in(a,pikind(b,c)) -> in(b,type()) /\ \Az. (in(z,b) =>
	       	  (in(lappl(a,z),subst(c,lcons(z,id()))) /\ in(subst(c,lcons(z,id())),kind()))).
 	        

rule NatListTheory() ->
     in(nat,type) /\ 
     in(z,nat) /\ 
     in(succ,pitype(nat,subst(nat,shift()))) /\
     in(natList, pikind(nat, subst(type(),shift()))) /\ 
     in(nil,lappl(natList,z)) /\ 
     in(cons, pitype(nat, pitype(subst(nat,shift()), (pitype(lappl(subst(natList,rond(shift(),shift())), one()), 
      	 	  	    lappl(subst(natList,rond(shift(),rond(shift(),shift()))), lappl(subst(succ,rond(shift(),rond(shift(),shift()))),subst(one(),shift())))))))).

proof singletonZ: NatListTheory() =>
      in(lappl(lappl(lappl(cons, lappl(succ, z)), z), nil), lappl(natList,lappl(succ,z))).
intro. focus h1. rule.
focus h6. rule. lappl(succ, z). reduce.
focus h4. rule. z. reduce.
axiom.
reduce. axiom.
reduce. focus h2. rule. z. 
axiom.
reduce. focus h2. rule. nil.
axiom.
reduce. axiom.

rule SimpleTypeTheory() ->
       in(tp,type) /\
       in(arrow, pitype(tp, pitype(subst(tp,shift()),subst(tp,rond(shift(),shift()))))) /\
       in(nat, tp) /\
       in(lterm, pikind(tp,subst(type(),shift()))) /\
       in(z, lappl(lterm, nat)) /\
       in(s, lappl(lterm, lappl(lappl(arrow,nat),nat))) /\
       \AA. (\AB. (in(app, pitype(lappl(lterm, lappl(lappl(arrow,A),B)),
	       			pitype(lappl(subst(lterm,shift()),subst(A,shift())),
				lappl(subst(lterm,rond(shift(),shift())),subst(B,rond(shift(),shift())))))))) /\
       \AA.(\AB. (in(lam, pitype(pitype(lappl(lterm, A), lappl(subst(lterm,shift()),subst(B,shift()))), lappl(subst(lterm,shift()),lappl(lappl(subst(arrow,shift()),subst(A,shift())),subst(B,shift()))))))).

proof lambdaXsX: SimpleTypeTheory() =>
	       in(lappl(lam, lambda(lappl(lappl(subst(app,shift()),subst(s,shift())),one()))),
	          lappl(lterm, lappl(lappl(arrow, nat), nat))).
intro. focus h1. rule. nat. nat. nat. nat.
focus h8. rule. lambda(lappl(lappl(subst(app,shift()),subst(s,shift())),one())).
rule.
reduce.
focus h6. rule. nat.
reduce. axiom.
axiom.
focus h5. rule. nat.
reduce. axiom.
axiom.
reduce.
focus h9. rule. s.
axiom.
reduce. focus h2. rule. z0.
axiom.
reduce. axiom.
reduce. axiom.
