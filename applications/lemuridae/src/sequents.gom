module sequents
imports String int 

abstract syntax

Term = Var(name:String)
     | funAppl(fun:Fun, p:TermList)
     | NewVar(name:String, base_name: String) // asks for a new var
     | FreshVar(name:String, base_name: String) // asks for a fresh var

Fun  = fun(name:String)

TermList = concTerm(Term*)

Relation = relation(name:String)

Prop = relationAppl(r:Relation, t:TermList)
     | and(p1:Prop, p2:Prop)
     | or(p1:Prop, p2:Prop)
     | implies(left:Prop, right:Prop)
     | forAll(var:String, p:Prop)
     | exists(var:String, p:Prop)
     | bottom()
     | top()

Context = context(Prop*)

Sequent = sequent(h:Context,c:Context)

Premisses = premisses(Tree*)

// st == symbol table
Tree = rule(type:RuleType, p:Premisses, c:Sequent, active:Prop)
RuleType = axiomInfo()
         | impliesLeftInfo()
         | impliesRightInfo()
         | andLeftInfo()
         | andRightInfo()
         | orLeftInfo()
         | orRightInfo()
         | forAllRightInfo(freshvar:Term)
         | forAllLeftInfo(newterm:Term)
         | existsRightInfo(newterm:Term)
         | existsLeftInfo(freshvar:Term)
         | bottomInfo()
         | topInfo()
         | cutInfo(name:String)
         | contractionLeftInfo()
         | contractionRightInfo()
         | openInfo() // open leaf
         | reductionInfo() // reduction step
         | customRuleInfo(name:String)

//--- new rules ---
SeqList = concSeq(Sequent*)

VarList = varlist(String*)

// hs == hand-side : 0 left, 1 right
Rule = ruledesc(hs:int, concl:Prop, prem:SeqList)

TermRule = termrule(lhs:Term,rh:Term)

TermRuleList = termrulelist(TermRule*)

// --- for the new rules computing---
// sequents and constraints
RuleList = rlist(Rule*)

// parsed in interactive mode
Command = rewritep(l:Prop, r:Prop)
        | rewritet(lt:Term, rt:Term)
        | proof(name:String, s:Sequent)
        | display(name:String)
        | quit()
        | proofcheck(name:String)
        | print(name:String)
	
ProofCommand = proofCommand(text:String)
             | focusCommand(hyp:String)
             | cutCommand(p:Prop)
             | ruleCommand(n:int)
             | askrulesCommand()
             | theoremCommand(name:String)

